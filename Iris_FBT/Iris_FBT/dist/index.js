/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/camera-manager.js":
/*!*******************************!*\
  !*** ./src/camera-manager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\nclass Camera {\n    el_div;\n    el_canvas;\n    el_video;\n    deviceID;\n    flip_horizontal = false;\n    threshold = 0.3;\n    ai_worker;\n    ctx;\n    constructor(deviceID) {\n        this.deviceID = deviceID;\n    }\n    createElement(videoReadyCallback = undefined) {\n        this.el_div = document.createElement(\"div\");\n        this.el_div.id = this.deviceID;\n        this.el_div.className = \"camera-card\";\n        var div_label = document.createElement(\"div\");\n        div_label.className = \"camera-label\";\n        Camera.GetCameraByID(this.deviceID).then(v => div_label.innerText = v == undefined ? \"ERROR GETTING NAME\" : Camera.GetMixedName(v));\n        this.el_div.appendChild(div_label);\n        var div_camera = document.createElement(\"div\");\n        div_camera.className = \"camera-display\";\n        this.el_video = document.createElement(\"video\");\n        Camera.GetCameraStream(this.deviceID)\n            .then(stream => {\n            this.el_video.srcObject = stream;\n            this.el_video.play()\n                .then(() => {\n                this.el_canvas.width = this.el_video.videoWidth;\n                this.el_canvas.height = this.el_video.videoHeight;\n                if (videoReadyCallback != undefined)\n                    videoReadyCallback(this);\n            });\n        });\n        div_camera.appendChild(this.el_video);\n        this.el_canvas = document.createElement(\"canvas\");\n        this.ctx = this.el_canvas.getContext(\"2d\");\n        div_camera.appendChild(this.el_canvas);\n        this.el_div.appendChild(div_camera);\n        var div_controls = document.createElement(\"div\");\n        div_controls.classList = \"camera-controls\";\n        div_controls.innerText = \"a\";\n        this.el_div.appendChild(div_controls);\n        return this.el_div;\n    }\n    processPose(canvas, ctx) {\n        canvas.width = this.el_video.videoWidth;\n        canvas.height = this.el_video.videoHeight;\n        ctx.drawImage(this.el_video, 0, 0, this.el_video.videoWidth, this.el_video.videoHeight);\n        this.ai_worker.postMessage({\n            type: \"video\",\n            image: ctx.getImageData(0, 0, this.el_video.videoWidth, this.el_video.videoHeight)\n        });\n    }\n    startWorker() {\n        if (typeof (Worker) === \"undefined\") {\n            Camera.GetCameraByID(this.deviceID).then(v => {\n                console.log(`Camera worker ${Camera.GetMixedName(v)} failed`);\n            });\n            return;\n        }\n        this.ai_worker = new Worker(\"CameraWorker.js\", { type: \"module\" });\n        this.ai_worker.onmessage = async (ev) => {\n            var data = ev.data;\n            switch (data.type) {\n                case \"debug\":\n                    console.log(`Camera worker ${Camera.GetMixedName(await Camera.GetCameraByID(this.deviceID))}`, data.message);\n                    break;\n                case \"error\":\n                    console.log(`Camera worker ${Camera.GetMixedName(await Camera.GetCameraByID(this.deviceID))} error`, data.error);\n                    break;\n                case \"pose\":\n                    this.ctx.clearRect(0, 0, this.el_canvas.width, this.el_canvas.height);\n                    this.ctx.strokeStyle = 'White';\n                    this.ctx.lineWidth = 1;\n                    for (var pose of data.pose) {\n                        for (var key in pose) {\n                            let spl = key.split(\"_\");\n                            if (spl[0] == \"right\")\n                                this.ctx.fillStyle = \"red\";\n                            else if (spl[0] == \"left\")\n                                this.ctx.fillStyle = \"green\";\n                            else\n                                this.ctx.fillStyle = \"blue\";\n                            let point = pose[key];\n                            const circle = new Path2D();\n                            circle.arc(point.x, point.y, 5, 0, 2 * Math.PI);\n                            this.ctx.fill(circle);\n                            this.ctx.stroke(circle);\n                        }\n                    }\n                    break;\n            }\n        };\n        this.ai_worker.onerror = async (ev) => {\n            console.log(`Camera worker ${Camera.GetMixedName(await Camera.GetCameraByID(this.deviceID))} onerror`, ev);\n        };\n        this.ai_worker.onmessageerror = async (ev) => {\n            console.log(`Camera worker ${Camera.GetMixedName(await Camera.GetCameraByID(this.deviceID))} onmessageerror`, ev);\n        };\n        this.ai_worker.postMessage({ type: \"config\", flip_horizontal: this.flip_horizontal, threshold: this.threshold });\n        this.ai_worker.postMessage({ type: \"start\" });\n    }\n    close() {\n        this.ai_worker.terminate();\n        this.ai_worker = undefined;\n    }\n    static async GetCameraStream(deviceID = \"\") {\n        if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {\n            let properties = {\n                video: {} /*{\n                    width: {\n                        ideal: 640\n                    },\n                    height: {\n                        ideal: 480\n                    }\n                }*/\n            };\n            if (deviceID)\n                properties.video[\"deviceId\"] = { exact: deviceID };\n            return await navigator.mediaDevices.getUserMedia(properties);\n        }\n        return undefined;\n    }\n    static async GetCamerasByName(deviceName) {\n        var cameras = await Camera.GetCameras();\n        if (!cameras)\n            return undefined;\n        return cameras.filter(v => v.label == deviceName);\n    }\n    static async GetCameraByID(deviceID) {\n        var cameras = await Camera.GetCameras();\n        if (cameras == undefined)\n            return undefined;\n        return cameras.find(v => v.id == deviceID);\n    }\n    static async GetCameras() {\n        if (!('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices))\n            return undefined;\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const videoDevices = devices.filter(device => device.kind === 'videoinput');\n        if (videoDevices[0].deviceId == '') {\n            await Camera.GetCameraStream();\n            return await Camera.GetCameras();\n        }\n        return videoDevices.map((videoDevice) => {\n            return {\n                label: videoDevice.label,\n                id: videoDevice.deviceId\n            };\n        });\n    }\n    static async UpdateCameraSelector(camSelect) {\n        let cameras = await Camera.GetCameras();\n        if (cameras == undefined)\n            return;\n        cameras = cameras.filter(v => document.getElementById(v.id) == undefined);\n        camSelect.innerHTML = `<option value=\"\">Select camera</option>`;\n        cameras.forEach((camera) => {\n            camSelect.innerHTML += `\\n<option value=${camera.id}>${Camera.GetMixedName(camera)}</option>`;\n        });\n    }\n    static GetMixedName(info) {\n        return `${info.label.split(\" (\")[0]} (${info.id.substring(0, 6)})`;\n    }\n}\n//# sourceMappingURL=camera-manager.js.map\n\n//# sourceURL=webpack://remote-one-camera-processing/./src/camera-manager.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _camera_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera-manager */ \"./src/camera-manager.js\");\n\nlet span_fps = document.getElementById(\"fps\");\nlet div_cameras = document.getElementById(\"camera-display\");\nlet select_camera = document.getElementById(\"camera-select\");\nlet hidden_canvas = document.getElementById(\"hidden-canvas\");\nlet ctx_hidden_canvas = hidden_canvas.getContext(\"2d\", { willReadFrequently: true });\nlet cameras = [];\n_camera_manager__WEBPACK_IMPORTED_MODULE_0__.Camera.UpdateCameraSelector(select_camera);\nselect_camera.onchange = () => {\n    if (select_camera.value == \"\")\n        return;\n    var camera = new _camera_manager__WEBPACK_IMPORTED_MODULE_0__.Camera(select_camera.value);\n    div_cameras.appendChild(camera.createElement(() => {\n        camera.startWorker();\n        cameras.push(camera);\n        //setInterval(() => {\n        //\tvar context = camera.el_canvas.getContext(\"2d\")\n        //\tcontext.drawImage(camera.el_video, 0, 0, camera.el_canvas.width, camera.el_canvas.height)\n        //\tconsole.log({ w: camera.el_canvas.width, h: camera.el_canvas.height })\n        //\twindow.location.href = camera.el_canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\")\n        //}, 5000)\n    }));\n    select_camera.value = \"\";\n    _camera_manager__WEBPACK_IMPORTED_MODULE_0__.Camera.UpdateCameraSelector(select_camera);\n};\nwindow.onclose = () => {\n    for (var cam of cameras) {\n        cam.close();\n    }\n};\nasync function AILoop() {\n    var start, end, delta;\n    while (true) {\n        start = (performance || Date).now();\n        for (var camera of cameras) {\n            await camera.processPose(hidden_canvas, ctx_hidden_canvas);\n        }\n        end = (performance || Date).now();\n        delta = end - start;\n        span_fps.innerText = delta.toString().substr(0, 4);\n        if (delta < 16.66) {\n            await sleep(16.66 - delta);\n        }\n    }\n}\nAILoop();\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/*\nconst controlPanel = document.getElementsByClassName(\"control-panel\")[0];\n\nconst lblState = document.getElementById(\"lbl-state\");\n\nconst btnStart = document.getElementById(\"btn-start\");\nconst btnStop = document.getElementById(\"btn-stop\");\nconst cbxAutostart = document.getElementById(\"cbx-autostart\");\n\nconst camSelect = document.getElementById(\"camera-select\");\nconst btnCamRef = document.getElementById(\"btn-camref\");\nconst video = document.getElementsByTagName(\"video\")[0];\nconst canvas = document.getElementsByTagName(\"canvas\")[0];\n\nconst btnApply = document.getElementById(\"btn-apply\");\nconst btnCancel = document.getElementById(\"btn-cancel\");\nconst btnReset = document.getElementById(\"btn-reset\");\nconst configSelect = document.getElementById(\"config-select\");\nconst lblPutState = document.getElementById(\"lbl-put-state\");\nvar lblPutStateTimeout;\n\nconst width = video.clientWidth;\nconsole.log(width);\n\nlblState.innerHTML = \"<i>Loading Camera...</i>\";\n\nconst camera = new Camera();\nconst poseDetector = new PoseDetector(true, width);\n\nlblState.innerHTML = \"<i>Loading...</i>\";\n\nconst DefaultConfig = {\n    id: -1,\n    cameraName: \"\",\n    cameraID: \"\",\n    autostart: false,\n    confidenceThreshold: 0.3\n};\nlet config = DefaultConfig;\nlet configUpdate = {};\n\nvar activeState = false;\n\nvar numConfigs = 0;\n\nasync function fetchAsync(port) {\n    let response = await fetch(port);\n    let data = await response.json();\n    return data;\n}\nasync function fetchAsyncText(port) {\n    let response = await fetch(port);\n    let data = await response.text();\n    return data;\n}\nasync function putAsync(port, data) {\n    return await fetch(port, {\n        method: 'PUT',\n        headers: {\n            'Content-type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n}\nasync function putAsyncText(port, data) {\n    return await fetch(port, {\n        method: 'PUT',\n        headers: {\n            'Content-type': 'text/text'\n        },\n        body: data\n    });\n}\n\nfunction hidePutState() {\n    lblPutState.classList.add(\"d-none\");\n}\nfunction setPutState(text, timeout) {\n    lblPutState.innerHTML = text;\n    if (lblPutStateTimeout) clearTimeout(lblPutStateTimeout);\n    lblPutState.classList.remove(\"d-none\");\n    lblPutStateTimeout = setTimeout(hidePutState, timeout);\n}\n\nfunction applyConfigChange() {\n    let madeChange = false;\n    let hadError = false;\n    if (\"autostart\" in configUpdate) {\n        madeChange = true;\n        config.autostart = configUpdate.autostart;\n        cbxAutostart.checked = config.autostart;\n    }\n    if (\"cameraID\" in configUpdate) {\n        madeChange = true;\n        config.cameraID = configUpdate.cameraID;\n        config.cameraName = configUpdate.cameraName;\n        if (configUpdate.cameraID != \"\") {\n            camSelect.value = configUpdate.cameraID;\n            if (activeState) {\n                camera.getCameraStream(configUpdate.cameraID).then((cam) => {\n                    video.srcObject = cam;\n                    resizeCanvas();\n                });\n            }\n        } else {\n            video.srcObject = undefined;\n        }\n    }\n    return madeChange\n}\n\nbtnApply.onclick = () => {\n    try {\n        applyConfigChange();\n        putAsync(\"config\", config)\n            .then((e) => {\n                switch (e.status) {\n                    case 200:\n                        setPutState(\"Successfully Applied Settings\", 1000);\n                        break;\n                    case 400:\n                    case 404:\n                    case 405:\n                    default:\n                        console.log(e);\n                        setPutState(\"Failed to Apply Settings\", 5000);\n                        break;\n                }\n            })\n    } catch (err) {\n        console.error(err);\n        setPutState(\"Failed to Apply Settings\", 5000);\n    }\n};\nbtnReset.onclick = () => {\n    try {\n        configUpdate = DefaultConfig;\n        if (applyConfigChange()) {\n            putAsync(\"config\", config)\n                .then((e) => {\n                    switch (e.status) {\n                        case 200:\n                            setPutState(\"Successfully Reset Settings\", 1000);\n                            break;\n                        case 400:\n                        case 404:\n                        case 405:\n                        default:\n                            console.log(e);\n                            setPutState(\"Failed to Reset Settings\", 5000);\n                            break;\n                    }\n                })\n        }\n    } catch (err) {\n        console.error(err);\n        setPutState(\"Failed to Reset Settings\", 5000);\n    }\n};\nbtnCancel.onclick = () => {\n    configUpdate = {};\n    cbxAutostart.checked = config.autostart;\n    if ('cameraID' in config) camSelect.value = config.cameraID;\n    else camera.getCameraIDByName(config.cameraName).then((id) => { camSelect.value = id; });\n};\n\nbtnStart.onclick = () => {\n    startAILoop();\n};\nbtnStop.onclick = () => {\n    activeState = false;\n    //Stop();\n};\n\ncamera.updateCameraSelector(camSelect);\n\nbtnCamRef.onclick = () => {\n    btnCamRef.disabled = true;\n    let v = camSelect.value;\n    camera.updateCameraSelector(camSelect).then(() => {\n        camSelect.value = v;\n        btnCamRef.disabled = false;\n    });\n};\n\ncamSelect.onchange = () => {\n    camera.getCameraNameByID(camSelect.value).then((name) => {\n        if (name === \"\") {\n            camera.updateCameraSelector(camSelect);\n            camSelect.value = \"\";\n            console.log(\"Invalid Camera Selected\");\n        } else {\n            configUpdate.cameraName = name;\n            configUpdate.cameraID = camSelect.value;\n        }\n    })\n};\ncbxAutostart.onchange = () => {\n    configUpdate.autostart = cbxAutostart.checked;\n};\n\nconfigSelect.onclick = () => {\n    GetConfigs();\n}\nconfigSelect.onchange = () => {\n    let value = Number(configSelect.value);\n    if (value != config.id) {\n        SwitchConfig(value);\n    }\n}\n\nasync function drawPose(pose) {\n    let ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    Object.keys(pose).forEach((key) => {\n        let spl = key.split(\"_\");\n        if (spl[0] == \"right\") ctx.fillStyle = \"red\";\n        else if (spl[0] == \"left\") ctx.fillStyle = \"green\";\n        else ctx.fillStyle = \"blue\";\n        let point = pose[key];\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\nfunction debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this, args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n};\n\nfunction resizeCanvas() {\n    let rect = video.getBoundingClientRect();\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n    if (poseDetector) poseDetector.width = rect.width;\n}\nresizeCanvas();\n\nwindow.addEventListener(\"resize\", debounce(resizeCanvas, 250, false));\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function sendPose(pose) {\n    await putAsync(\"poseData\", {\n        \"id\": config.id,\n        \"pose\": pose\n    });\n}\nasync function sendSize() {\n    let rect = video.getBoundingClientRect();\n    await putAsync(\"cameraSize\", {\n        \"id\": config.id,\n        \"width\": rect.width,\n        \"height\": rect.height\n    });\n}\nasync function sendStart() {\n    let rect = video.getBoundingClientRect();\n    await putAsyncText(\"start\", config.id);\n}\nasync function sendConnect() {\n    let rect = video.getBoundingClientRect();\n    await putAsyncText(\"connect\", config.id);\n}\n\nasync function AILoop() {\n    let pose = await poseDetector.getFilteredPose(video, config.confidenceThreshold);\n    await sendPose(pose);\n    drawPose(pose);\n}\n\nasync function startAILoop() {\n    try {\n        activeState = true;\n\n        if (!('cameraID' in config) || config.cameraID == \"\") config.cameraID = await camera.getCameraIDByName(config.cameraName);\n        video.srcObject = await camera.getCameraStream(config.cameraID);\n        \n        if (!poseDetector.detector) await poseDetector.createDetector();\n\n        resizeCanvas();\n        canvas.classList.remove(\"d-none\");\n        let start, end, delta;\n\n        /*poseDetector.estimatePose(video).then((data) => {\n            console.log(data[0].keypoints.map((d) => {\n                return d.name;\n            }))});* /\n        sendConnect();\n        sendSize();\n\n        lblState.innerHTML = \"Started Successfully\"\n\n        await AILoop();\n        sendStart();\n\n        while (activeState) {\n            start = (performance || Date).now();\n            await AILoop();\n            end = (performance || Date).now();\n            delta = end - start;\n            if (delta < 16.66) {\n                await sleep(16.66 - delta);\n            }\n        }\n    } catch (err) {\n        console.error(err);\n        activeState = false;\n        lblState.innerHTML = \"Failed To Start...\"\n    }\n}\n\nasync function GetConfigs() {\n    var response;\n    try {\n        response = await fetch(\"config.json\");\n        let data = await response.json();\n        let configs = data.windowConfigs;\n        //console.log(configs);\n        numConfigs = configs.length;\n        configSelect.innerHTML = \"<option value=-1>Select:</option>\\n<option value=-2>Create New</option>\";\n        for (let i = 0; i < numConfigs; i++) {\n            configSelect.innerHTML += `\\n<option value=${i}>${i}</option>`;\n        }\n    } catch (err) {\n        console.error(err);\n        return;\n    }\n}\nasync function SwitchConfig(fetchID) {\n    var response;\n    try {\n        response = await putAsync(\"SwitchConfig\", {\n            now: config.id,\n            to: fetchID\n        });\n    } catch (err) {\n        console.error(err);\n        return;\n    }\n    let data = await response.json();\n    //if confirmed, getConfig\n    lblState.innerHTML = \"Loaded Config, reading...\";\n    data.status = null;\n    config = data;\n    if (config.id >= numConfigs) {\n        for (let i = numConfigs; i <= config.id; i++) {\n            configSelect.innerHTML += `\\n<option value=${i}>${i}</option>`;\n        }\n    }\n    configSelect.value = config.id;\n    let camid = \"\";\n    if ('cameraID' in data) camid = data.cameraID\n    else camID = await camera.getCameraIDByName(data.cameraName);\n    camSelect.value = camid;\n    //camSelect.dispatchEvent(new Event('change'));\n\n    cbxAutostart.checked = data.autostart;\n\n    if (data.autostart) {\n        lblState.innerHTML = \"Autostarting...\";\n        startAILoop();\n    }\n    lblState.innerHTML = \"Loaded!\";\n}\nasync function GetConfig(fetchID) {\n    var response;\n    try {\n        if (fetchID < 0) {\n            response = await fetch(\"config\");\n        }\n        else {\n            response = await putAsync(\"config\", fetchID);\n        }\n    } catch (err) {\n        console.error(err);\n        return;\n    }\n\n    //console.log(response);\n    let data = await response.json();\n    //console.log(data);\n    let status = data.status;\n    data.status = null;\n    if (status != \"ok\") {\n        console.log(`Error: ${status}`);\n        lblState.innerHTML = `Loaded Error/Status:<br>${status}`;\n    }\n    lblState.innerHTML = \"Loaded Config, reading...\";\n    config = data;\n    if (config.id >= numConfigs) {\n        for (let i = numConfigs; i <= config.id; i++) {\n            configSelect.innerHTML += `\\n<option value=${i}>${i}</option>`;\n        }\n    }\n    configSelect.value = config.id;\n    let camid = await camera.getCameraIDByName(data.cameraName);\n    camSelect.value = camid;\n    //camSelect.dispatchEvent(new Event('change'));\n\n    cbxAutostart.checked = data.autostart;\n\n    if (data.autostart) {\n        lblState.innerHTML = \"Autostarting...\";\n        startAILoop();\n    }\n    lblState.innerHTML = \"Loaded!\";\n    setPutState(\"Connected To Server\", 1000);\n    controlPanel.classList.remove(\"d-none\");\n}\n\nlblState.innerHTML = \"<i>Getting Config...</i>\";\nGetConfigs();\nGetConfig(-1);*/ \n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://remote-one-camera-processing/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;