/*! For license information please see 540.js.LICENSE.txt */
(self.webpackChunkremote_one_camera_processing=self.webpackChunkremote_one_camera_processing||[]).push([[540],{264:function(e,t,n){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var r="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e},i=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof n.g&&n.g];for(var t=0;t<e.length;++t){var r=e[t];if(r&&r.Math==Math)return r}throw Error("Cannot find global object")}(this);function a(e,t){if(t)e:{var n=i;e=e.split(".");for(var a=0;a<e.length-1;a++){var s=e[a];if(!(s in n))break e;n=n[s]}(t=t(a=n[e=e[e.length-1]]))!=a&&null!=t&&r(n,e,{configurable:!0,writable:!0,value:t})}}function s(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function o(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function u(e){if(!(e instanceof Array)){e=o(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}a("Symbol",(function(e){function t(e,t){this.h=e,r(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.h};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",i=0;return function e(r){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(r||"")+"_"+i++,r)}})),a("Symbol.iterator",(function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),a=0;a<n.length;a++){var o=i[n[a]];"function"==typeof o&&"function"!=typeof o.prototype[e]&&r(o.prototype,e,{configurable:!0,writable:!0,value:function(){return s(t(this))}})}return e}));var l="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(e[i]=r[i])}return e};a("Object.assign",(function(e){return e||l}));var c,d="function"==typeof Object.create?Object.create:function(e){function t(){}return t.prototype=e,new t};if("function"==typeof Object.setPrototypeOf)c=Object.setPrototypeOf;else{var h;e:{var p={};try{p.__proto__={a:!0},h=p.a;break e}catch(e){}h=!1}c=h?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var f=c;function m(e,t){if(e.prototype=d(t.prototype),e.prototype.constructor=e,f)f(e,t);else for(var n in t)if("prototype"!=n)if(Object.defineProperties){var r=Object.getOwnPropertyDescriptor(t,n);r&&Object.defineProperty(e,n,r)}else e[n]=t[n];e.za=t.prototype}function g(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function x(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0}function b(e,t){e.l={ma:t,na:!0},e.h=e.s||e.v}function y(e,t,n){return e.h=n,{value:t}}function w(e){this.h=new g,this.i=e}function v(e,t,n,r){try{var i=t.call(e.h.j,n);if(!(i instanceof Object))throw new TypeError("Iterator result "+i+" is not an object");if(!i.done)return e.h.m=!1,i;var a=i.value}catch(t){return e.h.j=null,b(e.h,t),k(e)}return e.h.j=null,r.call(e.h,a),k(e)}function k(e){for(;e.h.h;)try{var t=e.i(e.h);if(t)return e.h.m=!1,{value:t.value,done:!1}}catch(t){e.h.i=void 0,b(e.h,t)}if(e.h.m=!1,e.h.l){if(t=e.h.l,e.h.l=null,t.na)throw t.ma;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function C(e){this.next=function(t){return x(e.h),e.h.j?t=v(e,e.h.j.next,t,e.h.u):(e.h.u(t),t=k(e)),t},this.throw=function(t){return x(e.h),e.h.j?t=v(e,e.h.j.throw,t,e.h.u):(b(e.h,t),t=k(e)),t},this.return=function(t){return function(e,t){x(e.h);var n=e.h.j;return n?v(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.h.return):(e.h.return(t),k(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function I(e){return function(e){function t(t){return e.next(t)}function n(t){return e.throw(t)}return new Promise((function(r,i){!function e(a){a.done?r(a.value):Promise.resolve(a.value).then(t,n).then(e,i)}(e.next())}))}(new C(new w(e)))}function S(e){return e||Array.prototype.fill}g.prototype.u=function(e){this.i=e},g.prototype.return=function(e){this.l={return:e},this.h=this.v},a("Promise",(function(e){function t(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(e){t.reject(e)}}function n(){this.h=null}function r(e){return e instanceof t?e:new t((function(t){t(e)}))}if(e)return e;n.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j((function(){t.m()}))}this.h.push(e)};var a=i.setTimeout;n.prototype.j=function(e){a(e,0)},n.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(e){this.l(e)}}}this.h=null},n.prototype.l=function(e){this.j((function(){throw e}))},t.prototype.l=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},t.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.L(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.F(e):this.s(e)}},t.prototype.F=function(e){var t=void 0;try{t=e.then}catch(e){return void this.m(e)}"function"==typeof t?this.M(t,e):this.s(e)},t.prototype.m=function(e){this.v(2,e)},t.prototype.s=function(e){this.v(1,e)},t.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},t.prototype.K=function(){var e=this;a((function(){if(e.D()){var t=i.console;void 0!==t&&t.error(e.j)}}),1)},t.prototype.D=function(){if(this.u)return!1;var e=i.CustomEvent,t=i.Event,n=i.dispatchEvent;return void 0===n||("function"==typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"==typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=i.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},t.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)s.i(this.h[e]);this.h=null}};var s=new n;return t.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},t.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(e){n.reject(e)}},t.prototype.then=function(e,n){function r(e,t){return"function"==typeof e?function(t){try{i(e(t))}catch(e){a(e)}}:t}var i,a,s=new t((function(e,t){i=e,a=t}));return this.T(r(e,i),r(n,a)),s},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.T=function(e,t){function n(){switch(r.i){case 1:e(r.j);break;case 2:t(r.j);break;default:throw Error("Unexpected state: "+r.i)}}var r=this;null==this.h?s.i(n):this.h.push(n),this.u=!0},t.resolve=r,t.reject=function(e){return new t((function(t,n){n(e)}))},t.race=function(e){return new t((function(t,n){for(var i=o(e),a=i.next();!a.done;a=i.next())r(a.value).T(t,n)}))},t.all=function(e){var n=o(e),i=n.next();return i.done?r([]):new t((function(e,t){function a(t){return function(n){s[t]=n,0==--o&&e(s)}}var s=[],o=0;do{s.push(void 0),o++,r(i.value).T(a(s.length-1),t),i=n.next()}while(!i.done)}))},t})),a("Array.prototype.keys",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,i={next:function(){if(!r&&n<e.length){var i=n++;return{value:t(i,e[i]),done:!1}}return r=!0,{done:!0,value:void 0}}};return i[Symbol.iterator]=function(){return i},i}(this,(function(e){return e}))}})),a("Array.prototype.fill",(function(e){return e||function(e,t,n){var r=this.length||0;for(0>t&&(t=Math.max(0,r+t)),(null==n||n>r)&&(n=r),0>(n=Number(n))&&(n=Math.max(0,r+n)),t=Number(t||0);t<n;t++)this[t]=e;return this}})),a("Int8Array.prototype.fill",S),a("Uint8Array.prototype.fill",S),a("Uint8ClampedArray.prototype.fill",S),a("Int16Array.prototype.fill",S),a("Uint16Array.prototype.fill",S),a("Int32Array.prototype.fill",S),a("Uint32Array.prototype.fill",S),a("Float32Array.prototype.fill",S),a("Float64Array.prototype.fill",S),a("Object.is",(function(e){return e||function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}})),a("Array.prototype.includes",(function(e){return e||function(e,t){var n=this;n instanceof String&&(n=String(n));var r=n.length;for(0>(t=t||0)&&(t=Math.max(t+r,0));t<r;t++){var i=n[t];if(i===e||Object.is(i,e))return!0}return!1}})),a("String.prototype.includes",(function(e){return e||function(e,t){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(e,t||0)}}));var $=this||self;function R(e,t){e=e.split(".");var n,r=$;e[0]in r||void 0===r.execScript||r.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=t}function T(e){var t;return(t=$.navigator)&&(t=t.userAgent)||(t=""),-1!=t.indexOf(e)}var A=Array.prototype.map?function(e,t){return Array.prototype.map.call(e,t,void 0)}:function(e,t){for(var n=e.length,r=Array(n),i="string"==typeof e?e.split(""):e,a=0;a<n;a++)a in i&&(r[a]=t.call(void 0,i[a],a,e));return r},E={},N=null;function D(){if(!N){N={};for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),t=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var r=e.concat(t[n].split(""));E[n]=r;for(var i=0;i<r.length;i++){var a=r[i];void 0===N[a]&&(N[a]=i)}}}}var _="undefined"!=typeof Uint8Array,F=!(T("Trident")||T("MSIE"))&&"function"==typeof $.btoa;function P(e){if(!F){var t;void 0===t&&(t=0),D(),t=E[t];for(var n=Array(Math.floor(e.length/3)),r=t[64]||"",i=0,a=0;i<e.length-2;i+=3){var s=e[i],o=e[i+1],u=e[i+2],l=t[s>>2];s=t[(3&s)<<4|o>>4],o=t[(15&o)<<2|u>>6],u=t[63&u],n[a++]=l+s+o+u}switch(l=0,u=r,e.length-i){case 2:u=t[(15&(l=e[i+1]))<<2]||r;case 1:e=e[i],n[a]=t[e>>2]+t[(3&e)<<4|l>>4]+u+r}return n.join("")}for(t="";10240<e.length;)t+=String.fromCharCode.apply(null,e.subarray(0,10240)),e=e.subarray(10240);return t+=String.fromCharCode.apply(null,e),btoa(t)}var O,U=RegExp("[-_.]","g");function B(e){switch(e){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function L(e){if(!F)return function(e){var t=e.length,n=3*t/4;n%3?n=Math.floor(n):-1!="=.".indexOf(e[t-1])&&(n=-1!="=.".indexOf(e[t-2])?n-2:n-1);var r=new Uint8Array(n),i=0;return function(e,t){function n(t){for(;r<e.length;){var n=e.charAt(r++),i=N[n];if(null!=i)return i;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return t}D();for(var r=0;;){var i=n(-1),a=n(0),s=n(64),o=n(64);if(64===o&&-1===i)break;t(i<<2|a>>4),64!=s&&(t(a<<4&240|s>>2),64!=o&&t(s<<6&192|o))}}(e,(function(e){r[i++]=e})),i!==n?r.subarray(0,i):r}(e);U.test(e)&&(e=e.replace(U,B)),e=atob(e);for(var t=new Uint8Array(e.length),n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}function z(){return O||(O=new Uint8Array(0))}var M={},W="function"==typeof Uint8Array.prototype.slice,V=0,G=0;function H(e){var t=0>e,n=(e=Math.abs(e))>>>0;e=Math.floor((e-n)/4294967296),t&&(t=(n=o(K(n,e))).next().value,e=n.next().value,n=t),V=n>>>0,G=e>>>0}var j,X="function"==typeof BigInt;function K(e,t){return t=~t,e?e=1+~e:t+=1,[e,t]}function q(e,t){this.i=e>>>0,this.h=t>>>0}function Y(e){if(!e)return j||(j=new q(0,0));if(!/^-?\d+$/.test(e))return null;if(16>e.length)H(Number(e));else if(X)e=BigInt(e),V=Number(e&BigInt(4294967295))>>>0,G=Number(e>>BigInt(32)&BigInt(4294967295));else{var t=+("-"===e[0]);G=V=0;for(var n=e.length,r=t,i=(n-t)%6+t;i<=n;r=i,i+=6)r=Number(e.slice(r,i)),G*=1e6,4294967296<=(V=1e6*V+r)&&(G+=V/4294967296|0,V%=4294967296);t&&(e=(t=o(K(V,G))).next().value,t=t.next().value,V=e,G=t)}return new q(V,G)}function Q(e,t){return Error("Invalid wire type: "+e+" (at position "+t+")")}function Z(){return Error("Failed to read varint, encoding is invalid.")}function J(e,t){return Error("Tried to read past the end of the data "+t+" > "+e)}function ee(){throw Error("Invalid UTF8")}function te(e,t){return t=String.fromCharCode.apply(null,t),null==e?t:e+t}var ne,re,ie,ae=void 0,se="undefined"!=typeof TextDecoder,oe="undefined"!=typeof TextEncoder;function ue(e){if(e!==M)throw Error("illegal external caller")}function le(e,t){if(ue(t),this.V=e,null!=e&&0===e.length)throw Error("ByteString should be constructed with non-empty values")}function ce(){return ie||(ie=new le(null,M))}function de(e){ue(M);var t=e.V;return null==(t=null==t||_&&null!=t&&t instanceof Uint8Array?t:"string"==typeof t?L(t):null)?t:e.V=t}function he(e,t){this.i=null,this.m=!1,this.h=this.j=this.l=0,pe(this,e,t)}function pe(e,t,n){n=void 0===n?{}:n,e.S=void 0!==n.S&&n.S,t&&(t=function(e){if("string"==typeof e)return{buffer:L(e),C:!1};if(Array.isArray(e))return{buffer:new Uint8Array(e),C:!1};if(e.constructor===Uint8Array)return{buffer:e,C:!1};if(e.constructor===ArrayBuffer)return{buffer:new Uint8Array(e),C:!1};if(e.constructor===le)return{buffer:de(e)||z(),C:!0};if(e instanceof Uint8Array)return{buffer:new Uint8Array(e.buffer,e.byteOffset,e.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(t),e.i=t.buffer,e.m=t.C,e.l=0,e.j=e.i.length,e.h=e.l)}function fe(e,t){if(e.h=t,t>e.j)throw J(e.j,t)}function me(e){var t=e.i,n=e.h,r=t[n++],i=127&r;if(128&r&&(i|=(127&(r=t[n++]))<<7,128&r&&(i|=(127&(r=t[n++]))<<14,128&r&&(i|=(127&(r=t[n++]))<<21,128&r&&(i|=(r=t[n++])<<28,128&r&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++])))))throw Z();return fe(e,n),i}function ge(e,t){if(0>t)throw Error("Tried to read a negative byte length: "+t);var n=e.h,r=n+t;if(r>e.j)throw J(t,e.j-n);return e.h=r,n}he.prototype.reset=function(){this.h=this.l};var xe=[];function be(){this.h=[]}function ye(e,t,n){for(;0<n||127<t;)e.h.push(127&t|128),t=(t>>>7|n<<25)>>>0,n>>>=7;e.h.push(t)}function we(e,t){for(;127<t;)e.h.push(127&t|128),t>>>=7;e.h.push(t)}function ve(e,t){if(xe.length){var n=xe.pop();pe(n,e,t),e=n}else e=new he(e,t);this.h=e,this.j=this.h.h,this.i=this.l=-1,this.setOptions(t)}function ke(e){var t=e.h;if(t.h==t.j)return!1;e.j=e.h.h;var n=me(e.h)>>>0;if(t=n>>>3,!(0<=(n&=7)&&5>=n))throw Q(n,e.j);if(1>t)throw Error("Invalid field number: "+t+" (at position "+e.j+")");return e.l=t,e.i=n,!0}function Ce(e){switch(e.i){case 0:if(0!=e.i)Ce(e);else e:{for(var t=(e=e.h).h,n=t+10,r=e.i;t<n;)if(0==(128&r[t++])){fe(e,t);break e}throw Z()}break;case 1:fe(e=e.h,e.h+8);break;case 2:2!=e.i?Ce(e):(t=me(e.h)>>>0,fe(e=e.h,e.h+t));break;case 5:fe(e=e.h,e.h+4);break;case 3:for(t=e.l;;){if(!ke(e))throw Error("Unmatched start-group tag: stream EOF");if(4==e.i){if(e.l!=t)throw Error("Unmatched end-group tag");break}Ce(e)}break;default:throw Q(e.i,e.j)}}be.prototype.length=function(){return this.h.length},be.prototype.end=function(){var e=this.h;return this.h=[],e},ve.prototype.setOptions=function(e){e=void 0===e?{}:e,this.ca=void 0!==e.ca&&e.ca},ve.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Ie=[];function Se(){this.j=[],this.i=0,this.h=new be}function $e(e,t){0!==t.length&&(e.j.push(t),e.i+=t.length)}var Re="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol():void 0;function Te(e,t){return Re?e[Re]|=t:void 0!==e.A?e.A|=t:(Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}}),t)}function Ae(e,t){Re?e[Re]&&(e[Re]&=~t):void 0!==e.A&&(e.A&=~t)}function Ee(e){var t;return null==(t=Re?e[Re]:e.A)?0:t}function Ne(e,t){Re?e[Re]=t:void 0!==e.A?e.A=t:Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}})}function De(e){return Te(e,1),e}function _e(e,t){Ne(t,-51&(0|e))}function Fe(e,t){Ne(t,-41&(18|e))}var Pe={};function Oe(e){return null!==e&&"object"==typeof e&&!Array.isArray(e)&&e.constructor===Object}var Ue,Be,Le=[];function ze(e){if(2&Ee(e.o))throw Error("Cannot mutate an immutable Message")}function Me(e){var t=e.length;(t=t?e[t-1]:void 0)&&Oe(t)?t.g=1:(t={},e.push((t.g=1,t)))}function We(e){var t=e.i+e.G;return e.B||(e.B=e.o[t]={})}function Ve(e,t){return-1===t?null:t>=e.i?e.B?e.B[t]:void 0:e.o[t+e.G]}function Ge(e,t,n,r){ze(e),He(e,t,n,r)}function He(e,t,n,r){e.j&&(e.j=void 0),t>=e.i||r?We(e)[t]=n:(e.o[t+e.G]=n,(e=e.B)&&t in e&&delete e[t])}function je(e,t,n,r){var i=Ve(e,t);Array.isArray(i)||(i=Ue);var a=Ee(i);if(1&a||De(i),r)2&a||Te(i,2),1&n||Object.freeze(i);else{r=!(2&n);var s=2&a;1&n||!s?r&&16&a&&!s&&Ae(i,16):He(e,t,i=De(Array.prototype.slice.call(i)))}return i}function Xe(e,t){var n=Ve(e,t),r=null==n?n:"number"==typeof n||"NaN"===n||"Infinity"===n||"-Infinity"===n?Number(n):void 0;return null!=r&&r!==n&&He(e,t,r),r}function Ke(e,t,n,r,i){e.h||(e.h={});var a=e.h[n],s=je(e,n,3,i);if(!a){var o=s;a=[];var u=!!(16&Ee(e.o));s=!!(2&Ee(o));var l=o;!i&&s&&(o=Array.prototype.slice.call(o));for(var c=s,d=0;d<o.length;d++){var h=o[d],p=t,f=!1;if(f=void 0!==f&&f,void 0!==(h=Array.isArray(h)?new p(h):f?new p:void 0)){var m=f=Ee(p=h.o);s&&(m|=2),u&&(m|=16),m!=f&&Ne(p,m),p=m,c=c||!!(2&p),a.push(h)}}return e.h[n]=a,t=33|(u=Ee(o)),u!=(t=c?-9&t:8|t)&&(c=o,Object.isFrozen(c)&&(c=Array.prototype.slice.call(c)),Ne(c,t),o=c),l!==o&&He(e,n,o),(i||r&&s)&&Te(a,2),r&&Object.freeze(a),a}return i||(i=Object.isFrozen(a),r&&!i?Object.freeze(a):!r&&i&&(a=Array.prototype.slice.call(a),e.h[n]=a)),a}function qe(e,t,n){var r=!!(2&Ee(e.o));if(t=Ke(e,t,n,r,r),e=je(e,n,3,r),!(r||8&Ee(e))){for(r=0;r<t.length;r++){if(2&Ee((n=t[r]).o)){var i=ot(n,!1);i.j=n}else i=n;n!==i&&(t[r]=i,e[r]=i.o)}Te(e,8)}return t}function Ye(e,t,n){if(null!=n&&"number"!=typeof n)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof n+": "+n);Ge(e,t,n)}function Qe(e,t,n,r,i){ze(e);var a=Ke(e,n,t,!1,!1);return n=null!=r?r:new n,e=je(e,t,2,!1),null!=i?(a.splice(i,0,n),e.splice(i,0,n.o)):(a.push(n),e.push(n.o)),n.C()&&Ae(e,8),n}function Ze(e,t){return null==e?t:e}function Je(e,t,n){return n=void 0===n?0:n,Ze(Xe(e,t),n)}function et(e,t,n,r){if(null!=e){if(Array.isArray(e))e=tt(e,t,n,void 0!==r);else if(Oe(e)){var i,a={};for(i in e)a[i]=et(e[i],t,n,r);e=a}else e=t(e,r);return e}}function tt(e,t,n,r){var i=Ee(e);r=r?!!(16&i):void 0,e=Array.prototype.slice.call(e);for(var a=0;a<e.length;a++)e[a]=et(e[a],t,n,r);return n(i,e),e}function nt(e){return e.ja===Pe?e.toJSON():function(e){switch(typeof e){case"number":return isFinite(e)?e:String(e);case"object":if(e)if(Array.isArray(e)){if(0!=(128&Ee(e)))return Me(e=Array.prototype.slice.call(e)),e}else{if(_&&null!=e&&e instanceof Uint8Array)return P(e);if(e instanceof le){var t=e.V;return null==t?"":"string"==typeof t?t:e.V=P(t)}}}return e}(e)}function rt(e,t){128&e&&Me(t)}function it(e,t,n){if(n=void 0===n?Fe:n,null!=e){if(_&&e instanceof Uint8Array)return e.length?new le(new Uint8Array(e),M):ce();if(Array.isArray(e)){var r=Ee(e);return 2&r?e:!t||32&r||!(16&r||0===r)?(4&(t=Ee(e=tt(e,it,4&r?Fe:n,!0)))&&2&t&&Object.freeze(e),e):(Ne(e,2|r),e)}return e.ja===Pe?st(e):e}}function at(e,t,n,r,i,a,s){if(e=e.h&&e.h[n]){if(2&(r=Ee(e))?r=e:(Fe(r,a=A(e,st)),Object.freeze(a),r=a),ze(t),s=null==r?Ue:De([]),null!=r){for(a=!!r.length,e=0;e<r.length;e++){var o=r[e];a=a&&!(2&Ee(o.o)),s[e]=o.o}a=1|(a?8:0),((e=Ee(s))&a)!==a&&(Object.isFrozen(s)&&(s=Array.prototype.slice.call(s)),Ne(s,e|a)),t.h||(t.h={}),t.h[n]=r}else t.h&&(t.h[n]=void 0);He(t,n,s,i)}else Ge(t,n,it(r,a,s),i)}function st(e){return 2&Ee(e.o)||Te((e=ot(e,!0)).o,2),e}function ot(e,t){var n=e.o,r=[];Te(r,16);var i=e.constructor.h;if(i&&r.push(i),i=e.B){r.length=n.length,r.fill(void 0,r.length,n.length);var a={};r[r.length-1]=a}0!=(128&Ee(n))&&Me(r),t=t||e.C()?Fe:_e,a=e.constructor,Be=r,r=new a(r),Be=void 0,e.R&&(r.R=e.R.slice()),a=!!(16&Ee(n));for(var s=i?n.length-1:n.length,o=0;o<s;o++)at(e,r,o-e.G,n[o],!1,a,t);if(i)for(var u in i)at(e,r,+u,i[u],!0,a,t);return r}function ut(e,t,n){null==e&&(e=Be),Be=void 0;var r,i=this.constructor.i||0,a=0<i,s=this.constructor.h,o=!1;if(null==e){var u=48,l=!0;a&&(i=0,u|=128),Ne(e=s?[s]:[],u)}else{if(!Array.isArray(e))throw Error();if(s&&s!==e[0])throw Error();var c=u=Te(e,0);if((l=0!=(16&c))&&((o=0!=(32&c))||(c|=32)),a){if(128&c)i=0;else if(0<e.length){var d=e[e.length-1];if(Oe(d)&&"g"in d){i=0,c|=128,delete d.g;var h,p=!0;for(h in d){p=!1;break}p&&e.pop()}}}else if(128&c)throw Error();u!==c&&Ne(e,c)}if(this.G=(s?0:-1)-i,this.h=void 0,this.o=e,i=(s=this.o.length)-1,s&&Oe(s=this.o[i])?(this.B=s,this.i=i-this.G):void 0!==t&&-1<t?(this.i=Math.max(t,i+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!a&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(n)for(t=l&&!o&&!0,a=this.i,l=0;l<n.length;l++)(o=n[l])<a?(i=e[o+=this.G])?lt(i,t):e[o]=Ue:(r||(r=We(this)),(i=r[o])?lt(i,t):r[o]=Ue)}function lt(e,t){if(Array.isArray(e)){var n=Ee(e),r=1;!t||2&n||(r|=16),(n&r)!==r&&Ne(e,n|r)}}function ct(e,t,n){if(n){var r,i={};for(r in n){var a=n[r],s=a.ra;s||(i.J=a.xa||a.oa.W,a.ia?(i.aa=bt(a.ia),s=function(e){return function(t,n,r){return e.J(t,n,r,e.aa)}}(i)):a.ka?(i.Z=yt(a.da.P,a.ka),s=function(e){return function(t,n,r){return e.J(t,n,r,e.Z)}}(i)):s=i.J,a.ra=s),s(t,e,a.da),i={J:i.J,aa:i.aa,Z:i.Z}}}!function(e,t){if(t=t.R){$e(e,e.h.end());for(var n=0;n<t.length;n++)$e(e,de(t[n])||z())}}(t,e)}Ne(Le,23),Ue=Object.freeze(Le),ut.prototype.toJSON=function(){return tt(this.o,nt,rt)},ut.prototype.C=function(){return!!(2&Ee(this.o))},ut.prototype.ja=Pe,ut.prototype.toString=function(){return this.o.toString()};var dt=Symbol();function ht(e,t,n){return e[dt]||(e[dt]=function(e,r){return t(e,r,n)})}function pt(e){var t=e[dt];if(!t){var n=Nt(e);t=function(e,t){return Dt(e,t,n)},e[dt]=t}return t}function ft(e){var t=function(e){var t=e.ia;return t?pt(t):(t=e.wa)?ht(e.da.P,t,e.ka):void 0}(e),n=e.da,r=e.oa.U;return t?function(e,i){return r(e,i,n,t)}:function(e,t){return r(e,t,n)}}function mt(e,t){var n=e[t];return"function"==typeof n&&0===n.length&&(n=n(),e[t]=n),Array.isArray(n)&&($t in n||wt in n||0<n.length&&"function"==typeof n[0])?n:void 0}function gt(e,t,n,r,i,a){t.P=e[0];var s=1;if(e.length>s&&"number"!=typeof e[s]){var o=e[s++];n(t,o)}for(;s<e.length;){n=e[s++];for(var u=s+1;u<e.length&&"number"!=typeof e[u];)u++;switch(o=e[s++],u-=s){case 0:r(t,n,o);break;case 1:(u=mt(e,s))?(s++,i(t,n,o,u)):r(t,n,o,e[s++]);break;case 2:i(t,n,o,u=mt(e,u=s++),e[s++]);break;case 3:a(t,n,o,e[s++],e[s++],e[s++]);break;case 4:a(t,n,o,e[s++],e[s++],e[s++],e[s++]);break;default:throw Error("unexpected number of binary field arguments: "+u)}}return t}var xt=Symbol();function bt(e){var t=e[xt];if(!t){var n=St(e);t=function(e,t){return _t(e,t,n)},e[xt]=t}return t}function yt(e,t){var n=e[xt];return n||(n=function(e,n){return ct(e,n,t)},e[xt]=n),n}var wt=Symbol();function vt(e,t){e.push(t)}function kt(e,t,n){e.push(t,n.W)}function Ct(e,t,n,r){var i=bt(r),a=St(r).P,s=n.W;e.push(t,(function(e,t,n){return s(e,t,n,a,i)}))}function It(e,t,n,r,i,a){var s=yt(r,a),o=n.W;e.push(t,(function(e,t,n){return o(e,t,n,r,s)}))}function St(e){var t=e[wt];return t||(t=gt(e,e[wt]=[],vt,kt,Ct,It),$t in e&&wt in e&&(e.length=0),t)}var $t=Symbol();function Rt(e,t){e[0]=t}function Tt(e,t,n,r){var i=n.U;e[t]=r?function(e,t,n){return i(e,t,n,r)}:i}function At(e,t,n,r,i){var a=n.U,s=pt(r),o=Nt(r).P;e[t]=function(e,t,n){return a(e,t,n,o,s,i)}}function Et(e,t,n,r,i,a,s){var o=n.U,u=ht(r,i,a);e[t]=function(e,t,n){return o(e,t,n,r,u,s)}}function Nt(e){var t=e[$t];return t||(t=gt(e,e[$t]={},Rt,Tt,At,Et),$t in e&&wt in e&&(e.length=0),t)}function Dt(e,t,n){for(;ke(t)&&4!=t.i;){var r=t.l,i=n[r];if(!i){var a=n[0];a&&(a=a[r])&&(i=n[r]=ft(a))}if(!i||!i(t,e,r)){r=e,a=(i=t).j,Ce(i);var s=i;if(!s.ca){if(i=s.h.h-a,s.h.h=a,s=s.h,0==i)i=ce();else{if(a=ge(s,i),s.S&&s.m)i=s.i.subarray(a,a+i);else{s=s.i;var o=a;i=o===(i=a+i)?z():W?s.slice(o,i):new Uint8Array(s.subarray(o,i))}i=0==i.length?ce():new le(i,M)}(a=r.R)?a.push(i):r.R=[i]}}}return e}function _t(e,t,n){for(var r=n.length,i=1==r%2,a=i?1:0;a<r;a+=2)(0,n[a+1])(t,e,n[a]);ct(e,t,i?n[0]:void 0)}function Ft(e,t){return{U:e,W:t}}var Pt=Ft((function(e,t,n){if(5!==e.i)return!1;var r=(e=e.h).i,i=e.h,a=r[i],s=r[i+1],o=r[i+2];return r=r[i+3],fe(e,e.h+4),e=2*((s=(a<<0|s<<8|o<<16|r<<24)>>>0)>>31)+1,a=s>>>23&255,s&=8388607,Ge(t,n,255==a?s?NaN:1/0*e:0==a?e*Math.pow(2,-149)*s:e*Math.pow(2,a-150)*(s+Math.pow(2,23))),!0}),(function(e,t,n){if(null!=(t=Xe(t,n))){we(e.h,8*n+5),e=e.h;var r=+t;0===r?0<1/r?V=G=0:(G=0,V=2147483648):isNaN(r)?(G=0,V=2147483647):34028234663852886e22<(r=(n=0>r?-2147483648:0)?-r:r)?(G=0,V=(2139095040|n)>>>0):11754943508222875e-54>r?(r=Math.round(r/Math.pow(2,-149)),G=0,V=(n|r)>>>0):(t=Math.floor(Math.log(r)/Math.LN2),r*=Math.pow(2,-t),16777216<=(r=Math.round(8388608*r))&&++t,G=0,V=(n|t+127<<23|8388607&r)>>>0),n=V,e.h.push(n>>>0&255),e.h.push(n>>>8&255),e.h.push(n>>>16&255),e.h.push(n>>>24&255)}})),Ot=Ft((function(e,t,n){if(0!==e.i)return!1;var r=e.h,i=0,a=e=0,s=r.i,o=r.h;do{var u=s[o++];i|=(127&u)<<a,a+=7}while(32>a&&128&u);for(32<a&&(e|=(127&u)>>4),a=3;32>a&&128&u;a+=7)e|=(127&(u=s[o++]))<<a;if(fe(r,o),!(128>u))throw Z();return r=i>>>0,(e=2147483648&(u=e>>>0))&&(u=~u>>>0,0==(r=1+~r>>>0)&&(u=u+1>>>0)),r=4294967296*u+(r>>>0),Ge(t,n,e?-r:r),!0}),(function(e,t,n){null!=(t=Ve(t,n))&&("string"==typeof t&&Y(t),null!=t&&(we(e.h,8*n),"number"==typeof t?(e=e.h,H(t),ye(e,V,G)):(n=Y(t),ye(e.h,n.i,n.h))))})),Ut=Ft((function(e,t,n){return 0===e.i&&(Ge(t,n,me(e.h)),!0)}),(function(e,t,n){if(null!=(t=Ve(t,n))&&null!=t)if(we(e.h,8*n),e=e.h,0<=(n=t))we(e,n);else{for(t=0;9>t;t++)e.h.push(127&n|128),n>>=7;e.h.push(1)}})),Bt=Ft((function(e,t,n){if(2!==e.i)return!1;var r=me(e.h)>>>0,i=ge(e=e.h,r);if(e=e.i,se){var a,s=e;(a=ne)||(a=ne=new TextDecoder("utf-8",{fatal:!0})),e=i+r,s=0===i&&e===s.length?s:s.subarray(i,e);try{var o=a.decode(s)}catch(e){if(void 0===ae){try{a.decode(new Uint8Array([128]))}catch(e){}try{a.decode(new Uint8Array([97])),ae=!0}catch(e){ae=!1}}throw!ae&&(ne=void 0),e}}else{r=(o=i)+r,i=[];for(var u,l,c=null;o<r;)128>(u=e[o++])?i.push(u):224>u?o>=r?ee():(l=e[o++],194>u||128!=(192&l)?(o--,ee()):i.push((31&u)<<6|63&l)):240>u?o>=r-1?ee():128!=(192&(l=e[o++]))||224===u&&160>l||237===u&&160<=l||128!=(192&(s=e[o++]))?(o--,ee()):i.push((15&u)<<12|(63&l)<<6|63&s):244>=u?o>=r-2?ee():128!=(192&(l=e[o++]))||0!=l-144+(u<<28)>>30||128!=(192&(s=e[o++]))||128!=(192&(a=e[o++]))?(o--,ee()):(u=(7&u)<<18|(63&l)<<12|(63&s)<<6|63&a,u-=65536,i.push(55296+(u>>10&1023),56320+(1023&u))):ee(),8192<=i.length&&(c=te(c,i),i.length=0);o=te(c,i)}return Ge(t,n,o),!0}),(function(e,t,n){if(null!=(t=Ve(t,n))){var r=!1;if(r=void 0!==r&&r,oe){if(r&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(t))throw Error("Found an unpaired surrogate");t=(re||(re=new TextEncoder)).encode(t)}else{for(var i=0,a=new Uint8Array(3*t.length),s=0;s<t.length;s++){var o=t.charCodeAt(s);if(128>o)a[i++]=o;else{if(2048>o)a[i++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&s<t.length){var u=t.charCodeAt(++s);if(56320<=u&&57343>=u){o=1024*(o-55296)+u-56320+65536,a[i++]=o>>18|240,a[i++]=o>>12&63|128,a[i++]=o>>6&63|128,a[i++]=63&o|128;continue}s--}if(r)throw Error("Found an unpaired surrogate");o=65533}a[i++]=o>>12|224,a[i++]=o>>6&63|128}a[i++]=63&o|128}}t=i===a.length?a:a.subarray(0,i)}we(e.h,8*n+2),we(e.h,t.length),$e(e,e.h.end()),$e(e,t)}})),Lt=Ft((function(e,t,n,r,i){if(2!==e.i)return!1;t=Qe(t,n,r),n=e.h.j,r=me(e.h)>>>0;var a=e.h.h+r,s=a-n;if(0>=s&&(e.h.j=a,i(t,e,void 0,void 0,void 0),s=a-e.h.h),s)throw Error("Message parsing ended unexpectedly. Expected to read "+r+" bytes, instead read "+(r-s)+" bytes, either the data ended unexpectedly or the message misreported its own length");return e.h.h=a,e.h.j=n,!0}),(function(e,t,n,r,i){if(null!=(t=qe(t,r,n)))for(r=0;r<t.length;r++){var a=e;we(a.h,8*n+2);var s=a.h.end();$e(a,s),s.push(a.i),a=s,i(t[r],e),s=e;var o=a.pop();for(o=s.i+s.h.length()-o;127<o;)a.push(127&o|128),o>>>=7,s.i++;a.push(o),s.i++}}));function zt(e){return function(t,n){e:{if(Ie.length){var r=Ie.pop();r.setOptions(n),pe(r.h,t,n),t=r}else t=new ve(t,n);try{var i=Nt(e),a=Dt(new i.P,t,i);break e}finally{(i=t.h).i=null,i.m=!1,i.l=0,i.j=0,i.h=0,i.S=!1,t.l=-1,t.i=-1,100>Ie.length&&Ie.push(t)}a=void 0}return a}}function Mt(e){return function(){var t=new Se;_t(this,t,St(e)),$e(t,t.h.end());for(var n=new Uint8Array(t.i),r=t.j,i=r.length,a=0,s=0;s<i;s++){var o=r[s];n.set(o,a),a+=o.length}return t.j=[n],n}}function Wt(e){ut.call(this,e)}m(Wt,ut);var Vt=[Wt,1,Ut,2,Pt,3,Bt,4,Bt];function Gt(e){ut.call(this,e,-1,Ht)}Wt.prototype.l=Mt(Vt),m(Gt,ut),Gt.prototype.addClassification=function(e,t){return Qe(this,1,Wt,e,t),this};var Ht=[1],jt=zt([Gt,1,Lt,Vt]);function Xt(e){ut.call(this,e)}m(Xt,ut);var Kt=[Xt,1,Pt,2,Pt,3,Pt,4,Pt,5,Pt];function qt(e){ut.call(this,e,-1,Yt)}Xt.prototype.l=Mt(Kt),m(qt,ut);var Yt=[1],Qt=zt([qt,1,Lt,Kt]);function Zt(e){ut.call(this,e)}m(Zt,ut);var Jt=[Zt,1,Pt,2,Pt,3,Pt,4,Pt,5,Pt,6,Ot],en=zt(Jt);function tn(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function nn(e){return qe(e,Wt,1).map((function(e){var t=Ve(e,1);return{index:null==t?0:t,qa:Je(e,2),label:null!=Ve(e,3)?Ze(Ve(e,3),""):void 0,displayName:null!=Ve(e,4)?Ze(Ve(e,4),""):void 0}}))}function rn(e){return{x:Je(e,1),y:Je(e,2),z:Je(e,3),visibility:null!=Xe(e,4)?Je(e,4):void 0}}function an(e){return qe(Qt(e),Xt,1).map(rn)}function sn(e,t){this.i=e,this.h=t,this.m=0}function on(e,t,n){return function(e,t){var n=e.h;if(void 0===e.s){var r=tn(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),i=tn(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),a=n.createProgram();if(n.attachShader(a,r),n.attachShader(a,i),n.linkProgram(a),!n.getProgramParameter(a,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(a));r=e.s=a,n.useProgram(r),i=n.getUniformLocation(r,"sampler0"),e.l={O:n.getAttribLocation(r,"aVertex"),N:n.getAttribLocation(r,"aTex"),ya:i},e.v=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.enableVertexAttribArray(e.l.O),n.vertexAttribPointer(e.l.O,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.u=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.enableVertexAttribArray(e.l.N),n.vertexAttribPointer(e.l.N,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(i,0)}r=e.l,n.useProgram(e.s),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.i.bindTexture2d(t.glName),n.enableVertexAttribArray(r.O),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.vertexAttribPointer(r.O,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(r.N),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.vertexAttribPointer(r.N,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(r.O),n.disableVertexAttribArray(r.N),n.bindBuffer(n.ARRAY_BUFFER,null),e.i.bindTexture2d(0)}(e,t),"function"==typeof e.h.canvas.transferToImageBitmap?Promise.resolve(e.h.canvas.transferToImageBitmap()):n?Promise.resolve(e.h.canvas):"function"==typeof createImageBitmap?createImageBitmap(e.h.canvas):(void 0===e.j&&(e.j=document.createElement("canvas")),new Promise((function(t){e.j.height=e.h.canvas.height,e.j.width=e.h.canvas.width,e.j.getContext("2d",{}).drawImage(e.h.canvas,0,0,e.h.canvas.width,e.h.canvas.height),t(e.j)})))}function un(e){this.h=e}Zt.prototype.l=Mt(Jt);var ln=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function cn(e,t){return t+e}function dn(e,t){window[e]=t}function hn(e){if(this.h=e,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=e&&e.locateFile||cn,"object"==typeof window)var t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=t,e.options)for(var n=(t=o(Object.keys(e.options))).next();!n.done;n=t.next()){n=n.value;var r=e.options[n].default;void 0!==r&&(this.l[n]="function"==typeof r?r():r)}}function pn(e,t){var n,r;return I((function(i){return t in e.L?i.return(e.L[t]):(n=e.locateFile(t,""),r=fetch(n).then((function(e){return e.arrayBuffer()})),e.L[t]=r,i.return(r))}))}function fn(e,t){for(var n=t.name||"$",r=[].concat(u(t.wants)),i=new e.i.StringList,a=o(t.wants),s=a.next();!s.done;s=a.next())i.push_back(s.value);a=e.i.PacketListener.implement({onResults:function(i){for(var a={},s=0;s<t.wants.length;++s)a[r[s]]=i.get(s);var u=e.listeners[n];u&&(e.I=function(e,t,n){var r,i,a,s,u,l,c,d,h,p,f,m,g,x;return I((function(b){switch(b.h){case 1:if(!n)return b.return(t);for(r={},i=0,a=o(Object.keys(n)),s=a.next();!s.done;s=a.next())u=s.value,"string"!=typeof(l=n[u])&&"texture"===l.type&&void 0!==t[l.stream]&&++i;1<i&&(e.M=!1),c=o(Object.keys(n)),s=c.next();case 2:if(s.done){b.h=4;break}if(d=s.value,"string"==typeof(h=n[d]))return g=r,x=d,y(b,function(e,t,n){var r;return I((function(i){return"number"==typeof n||n instanceof Uint8Array||n instanceof e.i.Uint8BlobList?i.return(n):n instanceof e.i.Texture2dDataOut?((r=e.v[t])||(r=new sn(e.i,e.K),e.v[t]=r),i.return(on(r,n,e.M))):i.return(void 0)}))}(e,d,t[h]),14);if(p=t[h.stream],"detection_list"===h.type){if(p){for(var w=p.getRectList(),v=p.getLandmarksList(),k=p.getClassificationsList(),C=[],S=0;S<w.size();++S){var $=en(w.get(S)),R=void 0;R=void 0===R?0:R,$={la:{sa:Je($,1),ta:Je($,2),height:Je($,3),width:Je($,4),rotation:Je($,5,0),pa:Ze(Ve($,6),R)},ea:an(v.get(S)),ba:nn(jt(k.get(S)))},C.push($)}w=C}else w=[];r[d]=w,b.h=7;break}if("proto_list"===h.type){if(p){for(w=Array(p.size()),v=0;v<p.size();v++)w[v]=p.get(v);p.delete()}else w=[];r[d]=w,b.h=7;break}if(void 0===p){b.h=3;break}if("float_list"===h.type){r[d]=p,b.h=7;break}if("proto"===h.type){r[d]=p,b.h=7;break}if("texture"!==h.type)throw Error("Unknown output config type: '"+h.type+"'");return(f=e.v[d])||(f=new sn(e.i,e.K),e.v[d]=f),y(b,on(f,p,e.M),13);case 13:m=b.i,r[d]=m;case 7:h.transform&&r[d]&&(r[d]=h.transform(r[d])),b.h=3;break;case 14:g[x]=b.i;case 3:s=c.next(),b.h=2;break;case 4:return b.return(r)}}))}(e,a,t.outs).then((function(n){n=u(n);for(var i=0;i<t.wants.length;++i){var s=a[r[i]];"object"==typeof s&&s.hasOwnProperty&&s.hasOwnProperty("delete")&&s.delete()}n&&(e.I=n)})))}}),e.j.attachMultiListener(i,a),i.delete()}function mn(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function gn(e){var t=this;e=e||{},this.h=new hn({locateFile:e.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:mn(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:an},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:an},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){var n,r,i;return I((function(a){return 1==a.h?(n=mn(e),r="third_party/mediapipe/modules/pose_landmark/"+n,y(a,pn(t.h,n),2)):(i=a.i,t.h.overrideFile(r,i),a.return(!0))}))}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=hn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},e.reset=function(){var e=this;return I((function(t){e.j&&(e.j.reset(),e.s={},e.v={}),t.h=0}))},e.setOptions=function(e,t){var n=this;if(t=t||this.h.options){for(var r=[],i=[],a={},s=o(Object.keys(e)),u=s.next();!u.done;a={X:a.X,Y:a.Y},u=s.next())if(!((u=u.value)in this.l)||this.l[u]!==e[u]){this.l[u]=e[u];var l=t[u];void 0!==l&&(l.onChange&&(a.X=l.onChange,a.Y=e[u],r.push(function(e){return function(){return I((function(t){if(1==t.h)return y(t,e.X(e.Y),2);!0===t.i&&(n.u=!0),t.h=0}))}}(a))),l.graphOptionXref&&(u=Object.assign({},{calculatorName:"",calculatorIndex:0},l.graphOptionXref,{valueNumber:1===l.type?e[u]:0,valueBoolean:0===l.type&&e[u],valueString:2===l.type?e[u]:""}),i.push(u)))}0===r.length&&0===i.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(i),this.F=(void 0===this.F?[]:this.F).concat(r))}},e.initialize=function(){var e=this;return I((function(t){return 1==t.h?y(t,function(e){var t,n,r,i,a,s,o,l,c,d,h;return I((function(p){switch(p.h){case 1:return e.ga?(t=void 0===e.h.files?[]:"function"==typeof e.h.files?e.h.files(e.l):e.h.files,y(p,I((function(e){switch(e.h){case 1:return e.s=2,y(e,WebAssembly.instantiate(ln),4);case 4:e.h=3,e.s=0;break;case 2:return e.s=0,e.l=null,e.return(!1);case 3:return e.return(!0)}})),2)):p.return();case 2:if(n=p.i,"object"==typeof window)return dn("createMediapipeSolutionsWasm",{locateFile:e.locateFile}),dn("createMediapipeSolutionsPackedAssets",{locateFile:e.locateFile}),s=t.filter((function(e){return void 0!==e.data})),o=t.filter((function(e){return void 0===e.data})),l=Promise.all(s.map((function(t){var n=pn(e,t.url);if(void 0!==t.path){var r=t.path;n=n.then((function(t){return e.overrideFile(r,t),Promise.resolve(t)}))}return n}))),c=Promise.all(o.map((function(t){return void 0===t.simd||t.simd&&n||!t.simd&&!n?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),new Promise((function(e){t.addEventListener("load",(function(){e()}),!1),t.addEventListener("error",(function(){e()}),!1),document.body.appendChild(t)}))}(e.locateFile(t.url,e.ha)):Promise.resolve()}))).then((function(){var t,n,r;return I((function(i){if(1==i.h)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,r=e,y(i,t(n),2);r.i=i.i,i.h=0}))})),d=I((function(t){return e.h.graph&&e.h.graph.url?t=y(t,pn(e,e.h.graph.url),0):(t.h=0,t=void 0),t})),y(p,Promise.all([c,l,d]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return r=t.filter((function(e){return void 0===e.simd||e.simd&&n||!e.simd&&!n})).map((function(t){return e.locateFile(t.url,e.ha)})),importScripts.apply(null,u(r)),i=e,y(p,createMediapipeSolutionsWasm(Module),6);case 6:i.i=p.i,e.m=new OffscreenCanvas(1,1),e.i.canvas=e.m,a=e.i.GL.createContext(e.m,{antialias:!1,alpha:!1,va:"undefined"!=typeof WebGL2RenderingContext?2:1}),e.i.GL.makeContextCurrent(a),p.h=4;break;case 7:if(e.m=document.createElement("canvas"),!(h=e.m.getContext("webgl2",{}))&&!(h=e.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();e.K=h,e.i.canvas=e.m,e.i.createContext(e.m,!0,!0,{});case 4:e.j=new e.i.SolutionWasm,e.ga=!1,p.h=0}}))}(e),2):3!=t.h?y(t,function(e){var t,n,r,i,a,s,u,l;return I((function(c){if(1==c.h)return e.h.graph&&e.h.graph.url&&e.fa===e.h.graph.url?c.return():(e.u=!0,e.h.graph&&e.h.graph.url?(e.fa=e.h.graph.url,y(c,pn(e,e.h.graph.url),3)):void(c.h=2));for(2!=c.h&&(t=c.i,e.j.loadGraph(t)),n=o(Object.keys(e.D)),r=n.next();!r.done;r=n.next())i=r.value,e.j.overrideFile(i,e.D[i]);if(e.D={},e.h.listeners)for(a=o(e.h.listeners),s=a.next();!s.done;s=a.next())u=s.value,fn(e,u);l=e.l,e.l={},e.setOptions(l),c.h=0}))}(e),3):y(t,function(e){var t,n,r,i,a,s;return I((function(u){switch(u.h){case 1:if(!e.u)return u.return();if(!e.F){u.h=2;break}t=o(e.F),n=t.next();case 3:if(n.done){u.h=5;break}return y(u,(0,n.value)(),4);case 4:n=t.next(),u.h=3;break;case 5:e.F=void 0;case 2:if(e.H){for(r=new e.i.GraphOptionChangeRequestList,i=o(e.H),a=i.next();!a.done;a=i.next())s=a.value,r.push_back(s);e.j.changeOptions(r),r.delete(),e.H=void 0}e.u=!1,u.h=0}}))}(e),0)}))},e.overrideFile=function(e,t){this.j?this.j.overrideFile(e,t):this.D[e]=t},e.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},e.send=function(e,t){var n,r,i,a,s,u,l,c,d,h=this;return I((function(p){switch(p.h){case 1:return h.h.inputs?(n=1e3*(null==t?performance.now():t),y(p,h.I,2)):p.return();case 2:return y(p,h.initialize(),3);case 3:for(r=new h.i.PacketDataList,i=o(Object.keys(e)),a=i.next();!a.done;a=i.next())if(s=a.value,u=h.h.inputs[s]){e:{var f=e[s];switch(u.type){case"video":var m=h.s[u.stream];if(m||(m=new sn(h.i,h.K),h.s[u.stream]=m),0===m.m&&(m.m=m.i.createTexture()),"undefined"!=typeof HTMLVideoElement&&f instanceof HTMLVideoElement)var g=f.videoWidth,x=f.videoHeight;else"undefined"!=typeof HTMLImageElement&&f instanceof HTMLImageElement?(g=f.naturalWidth,x=f.naturalHeight):(g=f.width,x=f.height);x={glName:m.m,width:g,height:x},(g=m.h).canvas.width=x.width,g.canvas.height=x.height,g.activeTexture(g.TEXTURE0),m.i.bindTexture2d(m.m),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,f),m.i.bindTexture2d(0),m=x;break e;case"detections":for((m=h.s[u.stream])||(m=new un(h.i),h.s[u.stream]=m),m.data||(m.data=new m.h.DetectionListData),m.data.reset(f.length),x=0;x<f.length;++x){g=f[x];var b=m.data,w=b.setBoundingBox,v=x,k=g.la,C=new Zt;if(Ye(C,1,k.sa),Ye(C,2,k.ta),Ye(C,3,k.height),Ye(C,4,k.width),Ye(C,5,k.rotation),Ge(C,6,k.pa),k=C.l(),w.call(b,v,k),g.ea)for(b=0;b<g.ea.length;++b){C=g.ea[b],v=(w=m.data).addNormalizedLandmark,k=x,C=Object.assign({},C,{visibility:C.visibility?C.visibility:0});var I=new Xt;Ye(I,1,C.x),Ye(I,2,C.y),Ye(I,3,C.z),C.visibility&&Ye(I,4,C.visibility),C=I.l(),v.call(w,k,C)}if(g.ba)for(b=0;b<g.ba.length;++b)v=(w=m.data).addClassification,k=x,C=g.ba[b],Ye(I=new Wt,2,C.qa),C.index&&Ge(I,1,C.index),C.label&&Ge(I,3,C.label),C.displayName&&Ge(I,4,C.displayName),C=I.l(),v.call(w,k,C)}m=m.data;break e;default:m={}}}switch(l=m,c=u.stream,u.type){case"video":r.pushTexture2d(Object.assign({},l,{stream:c,timestamp:n}));break;case"detections":(d=l).stream=c,d.timestamp=n,r.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+u.type+"'")}}return h.j.send(r),y(p,h.I,4);case 4:r.delete(),p.h=0}}))},e.onResults=function(e,t){this.listeners[t||"$"]=e},R("Solution",hn),R("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(e=gn.prototype).reset=function(){this.h.reset()},e.close=function(){return this.h.close(),Promise.resolve()},e.onResults=function(e){this.h.onResults(e)},e.initialize=function(){var e=this;return I((function(t){return y(t,e.h.initialize(),0)}))},e.send=function(e,t){var n=this;return I((function(r){return y(r,n.h.send(e,t),0)}))},e.setOptions=function(e){this.h.setOptions(e)},R("Pose",gn),R("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),R("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),R("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),R("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),R("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),R("VERSION","0.5.1675469404")}).call(this)},451:(e,t,n)=>{"use strict";var r,i,a=n(264),s=n(320);(0,s.OBj)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(r||(r={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(i||(i={})),new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);var o=function(e,t){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}o(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var l=function(){return(l=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function c(e,t,n,r){return new(n||(n=Promise))((function(i,a){function s(e){try{u(r.next(e))}catch(e){a(e)}}function o(e){try{u(r.throw(e))}catch(e){a(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}u((r=r.apply(e,t||[])).next())}))}function d(e,t){var n,r,i,a,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!((i=(i=s.trys).length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=t.call(e,s)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function h(e,t,n){if(n||2===arguments.length)for(var r,i=0,a=t.length;i<a;i++)!r&&i in t||(r||(r=Array.prototype.slice.call(t,0,i)),r[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}var p=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],f=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],m={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},g={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},x=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],b=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function y(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function w(e){return c(this,void 0,void 0,(function(){var t,n;return d(this,(function(r){switch(r.label){case 0:return t=document.createElement("canvas"),e instanceof s.esB?[4,s.Xhn.toPixels(e,t)]:[3,2];case 1:return r.sent(),[3,3];case 2:t.width=y(e.width),t.height=y(e.height),n=t.getContext("2d"),e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0),r.label=3;case 3:return[2,t]}}))}))}function v(e){return c(this,void 0,void 0,(function(){var t,n,r,i,a,o;return d(this,(function(u){switch(u.label){case 0:return e instanceof s.esB?(t=e.shape.slice(0,2),n=t[0],r=t[1],i=ImageData.bind,[4,s.Xhn.toPixels(e)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,u.sent(),r,n]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=y(e.width),a.height=y(e.height),o.drawImage(e,0,0),[2,o.getImageData(0,0,a.width,a.height)]}}))}))}function k(e){return c(this,void 0,void 0,(function(){var t,n;return d(this,(function(r){switch(r.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,w(e)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=e,r.label=3;case 3:return t=n,[2,s.Xhn.fromPixels(t,4)]}}))}))}function C(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var I=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,this.mask]}))}))},e.prototype.toImageData=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,v(this.mask)]}))}))},e.prototype.toTensor=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,k(this.mask)]}))}))},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function S(e){return C(e),"person"}function $(e){return e instanceof s.esB?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function R(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function T(e){return e instanceof s.esB?e:s.Xhn.fromPixels(e)}function A(e,t,n){return E(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function E(e,t){s.D5U.assert(0!==e.width,(function(){return"".concat(t," width cannot be 0.")})),s.D5U.assert(0!==e.height,(function(){return"".concat(t," height cannot be 0.")}))}function N(e,t,n){var r=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex,a=e.locationData,s=a.relativeKeypoints[r].x*t.width,o=a.relativeKeypoints[r].y*t.height,u=a.relativeKeypoints[i].x*t.width,l=a.relativeKeypoints[i].y*t.height,c=2*Math.sqrt((u-s)*(u-s)+(l-o)*(l-o)),d=function(e,t,n){var r,i=e.locationData,a=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex;r=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var o=i.relativeKeypoints[a].x*t.width,u=i.relativeKeypoints[a].y*t.height,l=i.relativeKeypoints[s].x*t.width,c=i.relativeKeypoints[s].y*t.height;return R(r-Math.atan2(-(c-u),l-o))}(e,t,n);return{xCenter:s/t.width,yCenter:o/t.height,width:c/t.width,height:c/t.height,rotation:d}}function D(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function _(e,t,n,r,i,a,s){return e[t][i]*(e[n][a]*e[r][s]-e[n][s]*e[r][a])}function F(e,t,n){var r=(t+1)%4,i=(t+2)%4,a=(t+3)%4,s=(n+1)%4,o=(n+2)%4,u=(n+3)%4;return _(e,r,i,a,s,o,u)+_(e,i,a,r,s,o,u)+_(e,a,r,i,s,o,u)}function P(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],i=0,a=e;i<a.length;i++){var s=a[i],o=s.x-.5,u=s.y-.5,c=n.ignoreRotation?0:t.rotation,d=Math.cos(c)*o-Math.sin(c)*u,h=Math.sin(c)*o+Math.cos(c)*u;d=d*t.width+t.xCenter,h=h*t.height+t.yCenter;var p=s.z*t.width,f=l({},s);f.x=d,f.y=h,f.z=p,r.push(f)}return r}function O(e,t){var n=function(e,t,n,r){var i=(r-n)/255;return{scale:i,offset:n-0*i}}(0,0,t[0],t[1]);return(0,s.lub)((function(){return(0,s.IHx)((0,s.dC7)(e,n.scale),n.offset)}))}function U(e,t,n){var r,i,a,o,u,l,c,d,h,p,f,m,g=t.outputTensorSize,x=t.keepAspectRatio,b=t.borderMode,y=t.outputTensorFloatRange,w=$(e),v=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(w,n),k=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,i=t.width;E(t,"targetSize"),E(e,"roi");var a,s,o=r/i,u=e.height/e.width,l=0,c=0;return o>u?(a=e.width,s=e.width*o,c=(1-u/o)/2):(a=e.height/o,s=e.height,l=(1-o/u)/2),e.width=a,e.height=s,{top:c,left:l,right:l,bottom:c}}(v,g,x),C=(r=v,i=w.width,a=w.height,o=r.width,u=r.height,l=Math.cos(r.rotation),c=Math.sin(r.rotation),d=r.xCenter,h=r.yCenter,p=1/i,f=1/a,(m=new Array(16))[0]=o*l*1*p,m[1]=-u*c*p,m[2]=0,m[3]=(-.5*o*l*1+.5*u*c+d)*p,m[4]=o*c*1*f,m[5]=u*l*f,m[6]=0,m[7]=(-.5*u*l-.5*o*c*1+h)*f,m[8]=0,m[9]=0,m[10]=o*p,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,D(m));return{imageTensor:(0,s.lub)((function(){var t=T(e),n=(0,s.odF)(A(C,w,g),[1,8]),r="zero"===b?"constant":"nearest",i=s.BHj.transform((0,s.dt4)((0,s.pju)(t,"float32")),n,"bilinear",r,0,[g.height,g.width]);return null!=y?O(i,y):i})),padding:k,transformationMatrix:C}}function B(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function L(e){return null!=e&&null!=e.currentTime}function z(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,s=0;s<e.length;++s){var o=e[s];n=Math.min(n,o.x),r=Math.max(r,o.x),i=Math.min(i,o.y),a=Math.max(a,o.y),t.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:i,xMax:r,yMax:a,width:r-n,height:a-i},t}function M(e,t,n,r){return c(this,void 0,void 0,(function(){var r,i,a,o,u;return d(this,(function(l){switch(l.label){case 0:return e.sort((function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)})),r=(0,s.odF)(e.map((function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]}))),i=(0,s.RRF)(e.map((function(e){return e.score[0]}))),[4,s.BHj.nonMaxSuppressionAsync(r,i,t,n)];case 1:return[4,(a=l.sent()).array()];case 2:return o=l.sent(),u=e.filter((function(e,t){return o.indexOf(t)>-1})),(0,s.B90)([r,i,a]),[2,u]}}))}))}function W(e,t){return e.map((function(e){var n=l(l({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n}))}function V(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,o,u,c,h,p,f,m,g,x,b,y,w,v,k,C,I,S,$,R,T,A;return d(this,(function(d){switch(d.label){case 0:if(r=(0,s.L9e)(t,[0]),i=r.shape,a=i[0],o=i[1],u=i[2],e.length!==u)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(u));return c=[],[4,r.buffer()];case 1:for(h=d.sent(),p=0;p<e.length;p++)if(f=e[p],m=l({},f),c.push(m),g=Math.trunc(m.x*o),x=Math.trunc(m.y*a),!(g<0||g>=o||x<0||g>=a)){for(b=Math.trunc((n.kernelSize-1)/2),y=Math.max(0,g-b),w=Math.min(o,g+b+1),v=Math.max(0,x-b),k=Math.min(a,x+b+1),C=0,I=0,S=0,$=0,R=v;R<k;++R)for(T=y;T<w;++T)A=h.get(R,T,p),C+=A,$=Math.max($,A),I+=T*A,S+=R*A;$>=n.minConfidenceToRefine&&C>0&&(m.x=I/o/C,m.y=S/a/C)}return r.dispose(),[2,c]}}))}))}function G(e,t){var n=t.left,r=t.top,i=t.left+t.right,a=t.top+t.bottom;return e.map((function(e){return l(l({},e),{x:(e.x-n)/(1-i),y:(e.y-r)/(1-a),z:e.z/(1-i)})}))}function H(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,o,u;return d(this,(function(l){switch(l.label){case 0:return r=e[0],i=e[1],a=function(e,t,n){return(0,s.lub)((function(){var r,i,a,o;n.reverseOutputOrder?(i=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+0],[-1,1])),r=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+1],[-1,1])),o=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+2],[-1,1])),a=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+0],[-1,1])),i=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+1],[-1,1])),a=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+2],[-1,1])),o=(0,s.L9e)((0,s.tPi)(e,[0,n.boxCoordOffset+3],[-1,1]))),i=(0,s.IHx)((0,s.dC7)((0,s.hiC)(i,n.xScale),t.w),t.x),r=(0,s.IHx)((0,s.dC7)((0,s.hiC)(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(a=(0,s.dC7)((0,s.Qqt)((0,s.hiC)(a,n.hScale)),t.h),o=(0,s.dC7)((0,s.Qqt)((0,s.hiC)(o,n.wScale)),t.w)):(a=(0,s.dC7)((0,s.hiC)(a,n.hScale),t.h),o=(0,s.dC7)((0,s.hiC)(o,n.wScale),t.h));var u=(0,s.luU)(r,(0,s.hiC)(a,2)),l=(0,s.luU)(i,(0,s.hiC)(o,2)),c=(0,s.IHx)(r,(0,s.hiC)(a,2)),d=(0,s.IHx)(i,(0,s.hiC)(o,2)),h=(0,s.zoF)([(0,s.XLQ)(u,[n.numBoxes,1]),(0,s.XLQ)(l,[n.numBoxes,1]),(0,s.XLQ)(c,[n.numBoxes,1]),(0,s.XLQ)(d,[n.numBoxes,1])],1);if(n.numKeypoints)for(var p=0;p<n.numKeypoints;++p){var f=n.keypointCoordOffset+p*n.numValuesPerKeypoint,m=void 0,g=void 0;n.reverseOutputOrder?(m=(0,s.L9e)((0,s.tPi)(e,[0,f],[-1,1])),g=(0,s.L9e)((0,s.tPi)(e,[0,f+1],[-1,1]))):(g=(0,s.L9e)((0,s.tPi)(e,[0,f],[-1,1])),m=(0,s.L9e)((0,s.tPi)(e,[0,f+1],[-1,1])));var x=(0,s.IHx)((0,s.dC7)((0,s.hiC)(m,n.xScale),t.w),t.x),b=(0,s.IHx)((0,s.dC7)((0,s.hiC)(g,n.yScale),t.h),t.y);h=(0,s.zoF)([h,(0,s.XLQ)(x,[n.numBoxes,1]),(0,s.XLQ)(b,[n.numBoxes,1])],1)}return h}))}(i,t,n),o=(0,s.lub)((function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=(0,s.iUl)(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=(0,s.XD2)(e)):e})),[4,j(a,o,n)];case 1:return u=l.sent(),(0,s.B90)([a,o]),[2,u]}}))}))}function j(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h,p,f,m;return d(this,(function(d){switch(d.label){case 0:return r=[],[4,e.data()];case 1:return i=d.sent(),[4,t.data()];case 2:for(a=d.sent(),s=0;s<n.numBoxes;++s)if(!(null!=n.minScoreThresh&&a[s]<n.minScoreThresh||(o=s*n.numCoords,u=X(i[o+0],i[o+1],i[o+2],i[o+3],a[s],n.flipVertically,s),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,p=0;p<h;p+=n.numValuesPerKeypoint)f=o+n.keypointCoordOffset+p,m={x:i[f+0],y:n.flipVertically?1-i[f+1]:i[f+1]},c.relativeKeypoints.push(m);r.push(u)}return[2,r]}}))}))}function X(e,t,n,r,i,a,s){return{score:[i],ind:s,locationData:{relativeBoundingBox:{xMin:t,yMin:a?1-n:e,xMax:r,yMax:a?1-e:n,width:r-t,height:n-e}}}}function K(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function q(e,t,n,r){return c(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h;return d(this,(function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,r=r||t.flipVertically||!1,i=e.size,a=i/t.numLandmarks,[4,e.data()];case 1:for(s=d.sent(),o=[],u=0;u<t.numLandmarks;++u)l=u*a,(h={x:0,y:0}).x=n?t.inputImageWidth-s[l]:s[l],a>1&&(h.y=r?t.inputImageHeight-s[l+1]:s[l+1]),a>2&&(h.z=s[l+2]),a>3&&(h.score=K(t.visibilityActivation,s[l+3])),o.push(h);for(c=0;c<o.length;++c)(h=o[c]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,o]}}))}))}function Y(e,t,n){var r=e.width,i=e.height,a=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(a=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),R(e)}(a,n)),0===a)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+i*n.shiftY;else{var s=(t.width*r*n.shiftX*Math.cos(a)-t.height*i*n.shiftY*Math.sin(a))/t.width,o=(t.width*r*n.shiftX*Math.sin(a)+t.height*i*n.shiftY*Math.cos(a))/t.height;e.xCenter=e.xCenter+s,e.yCenter=e.yCenter+o}if(n.squareLong){var u=Math.max(r*t.width,i*t.height);r=u/t.width,i=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,i*t.height);r=l/t.width,i=l/t.height}return e.width=r*n.scaleX,e.height=i*n.scaleY,e}!function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new a.Pose({locateFile:function(t,n){if(e.solutionPath){var r=e.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(t)}return"".concat(n,"/").concat(t)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(e){if(n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks)n.poses=[];else{var t=n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:S,mask:new I(e.segmentationMask)}),n.poses=[t]}}))}e.prototype.translateOutput=function(e,t){var n=this,r={keypoints:e.map((function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:f[t]}}))};return null!=t&&(r.keypoints3D=t.map((function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:f[t]}}))),r},e.prototype.estimatePoses=function(e,t,n){return c(this,void 0,void 0,(function(){var r,i;return d(this,(function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof s.esB?(i=ImageData.bind,[4,s.Xhn.toPixels(e)]):[3,2];case 1:return r=new(i.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},n)];case 4:return a.sent(),[2,this.poses]}}))}))},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()}}();var Q=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),Z=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Q(this.getAlpha(this.minCutOff)),this.dx=new Q(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,a=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),s=this.minCutOff+this.beta*Math.abs(a),o=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(s),o)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),J=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return h([],e,!0);i=1/n}return e.map((function(e,n){var a=l(l({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(a.z=r.zFilters[n].apply(e.z,t,i)),a}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new Z(t.config)})),this.yFilters=e.map((function(e){return new Z(t.config)})),this.zFilters=e.map((function(e){return new Z(t.config)})))},e}(),ee=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new Q(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(-1===this.lastTimestamp)r=1;else{for(var a=e*n-this.lastValue*this.lastValueScale,s=i-this.lastTimestamp,o=a,u=s,l=(1+this.window.length)*(1e6/30),c=0,d=this.window;c<d.length;c++){var h=d[c];if(u+h.duration>l)break;o+=h.distance,u+=h.duration}var p=o/(1e-6*u);r=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:a,duration:s}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},e}(),te=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return h([],e,!0);i=1/n}return this.initializeFiltersIfEmpty(e),e.map((function(e,n){var a=l(l({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(a.z=r.zFilters[n].apply(e.z,t,i)),a}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new ee(t.config)})),this.yFilters=e.map((function(e){return new ee(t.config)})),this.zFilters=e.map((function(e){return new ee(t.config)})))},e}(),ne=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new te(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new J(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,i){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var a=null!=i?function(e,t){return(e.width*t.width+e.height*t.height)/2}(i,n):1,s=r?W(e,n):e,o=this.keypointsFilter.apply(s,t,a);return r?function(e,t){return e.map((function(e){var n=l(l({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n}))}(o,n):o},e}(),re=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(e){return new Q(t.alpha)})));for(var n=[],r=0;r<e.length;++r){var i=e[r],a=l({},i);a.score=this.visibilityFilters[r].apply(i.score),n.push(a)}return n},e}(),ie={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},ae={maxPoses:1,flipHorizontal:!1},se={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},oe={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},ue={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},le={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},ce={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},de={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},he={kernelSize:7,minConfidenceToRefine:.5},pe={alpha:.1},fe={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},me={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},ge={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},xe={activation:"none"},be={combineWithPreviousRatio:.7},ye=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,w(this.mask)]}))}))},e.prototype.toImageData=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,v(this.mask)]}))}))},e.prototype.toTensor=function(){return c(this,void 0,void 0,(function(){return d(this,(function(e){return[2,this.mask]}))}))},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function we(e){return C(e),"person"}!function(){function e(e,t,n,r,i,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var r=[],i=[],a=[],s=[],o=n;o<e.strides.length&&e.strides[o]===e.strides[n];){var u=B(e.minScale,e.maxScale,o,e.strides.length);if(0===o&&e.reduceBoxesInLowestLayer)a.push(1),a.push(2),a.push(.5),s.push(.1),s.push(u),s.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)a.push(e.aspectRatios[l]),s.push(u);if(e.interpolatedScaleAspectRatio>0){var c=o===e.strides.length-1?1:B(e.minScale,e.maxScale,o+1,e.strides.length);s.push(Math.sqrt(u*c)),a.push(e.interpolatedScaleAspectRatio)}}o++}for(var d=0;d<a.length;++d){var h=Math.sqrt(a[d]);r.push(s[d]/h),i.push(s[d]*h)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var x=0;x<f;++x)for(var b=0;b<r.length;++b){var y={xCenter:(x+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(y.width=1,y.height=1):(y.width=i[b],y.height=r[b]),t.push(y)}n=o}return t}(ie);var o=(0,s.RRF)(this.anchors.map((function(e){return e.width}))),u=(0,s.RRF)(this.anchors.map((function(e){return e.height}))),l=(0,s.RRF)(this.anchors.map((function(e){return e.xCenter}))),c=(0,s.RRF)(this.anchors.map((function(e){return e.yCenter})));this.anchorTensor={x:l,y:c,w:o,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?(0,s.odF)([],[0,0]):null}e.prototype.estimatePoses=function(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,o,u,c,h,p,m,g,x,b,y,w,v,k,C,I,S,R,A,E,N;return d(this,(function(d){switch(d.label){case 0:return r=function(e){var t;if(null==(t=null==e?ae:l({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:L(e)?1e6*e.currentTime:null,i=$(e),a=(0,s.lub)((function(){return(0,s.pju)(T(e),"float32")})),null!=(o=this.regionOfInterest)?[3,2]:[4,this.detectPose(a)]);case 1:if(0===(u=d.sent()).length)return this.reset(),a.dispose(),[2,[]];c=u[0],o=this.poseDetectionToRoi(c,i),d.label=2;case 2:return[4,this.poseLandmarksByRoi(o,a)];case 3:return h=d.sent(),a.dispose(),null==h?(this.reset(),[2,[]]):(p=h.landmarks,m=h.auxiliaryLandmarks,g=h.poseScore,x=h.worldLandmarks,b=h.segmentationMask,y=this.poseLandmarkFiltering(p,m,x,i),w=y.actualLandmarksFiltered,v=y.auxiliaryLandmarksFiltered,k=y.actualWorldLandmarksFiltered,C=this.poseLandmarksToRoi(v,i),this.regionOfInterest=C,I=this.smoothSegmentation&&null!=b?this.poseSegmentationFiltering(b):b,null!=(S=null!=w?W(w,i):null)&&S.forEach((function(e,t){e.name=f[t]})),null!=(R=k)&&R.forEach((function(e,t){e.name=f[t]})),A={score:g,keypoints:S,keypoints3D:R},null!==I&&(E=(0,s.lub)((function(){var e=(0,s.dt4)(I,2),t=(0,s.vku)(e,[[0,0],[0,0],[0,1]]);return(0,s.VdP)(t,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||(0,s.B90)(I),N={maskValueToLabel:we,mask:new ye(E)},A.segmentation=N),[2,[A]])}}))}))},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function(e,t,n){return"webgl"===(0,s.N_N)()?function(e,t,n){var r=n.combineWithPreviousRatio.toFixed(2),i={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(r,");\n\n      setOutput(outputValue);\n    }\n")},a=(0,s.y3$)();return(0,s.lub)((function(){var n=a.compileAndRun(i,[e,t]);return(0,s.SRH)().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}))}(e,t,n):(0,s.lub)((function(){var r=(0,s.luU)(t,.5),i=(0,s.h62)(r),a=(0,s.luU)(1,(0,s.LTh)(1,(0,s.dC7)(i,(0,s.IHx)(5.68842,(0,s.dC7)(i,(0,s.IHx)(-.748699,(0,s.dC7)(i,(0,s.IHx)(-57.8051,(0,s.dC7)(i,(0,s.IHx)(291.309,(0,s.dC7)(i,-624.717)))))))))));return(0,s.IHx)(t,(0,s.dC7)((0,s.luU)(e,t),(0,s.dC7)(a,n.combineWithPreviousRatio)))}))}(t,e,be),(0,s.B90)(e)),(0,s.B90)(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),(0,s.B90)([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&((0,s.B90)(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=(0,s.odF)([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return c(this,void 0,void 0,(function(){var t,n,r,i,a,o,u,l,c,h;return d(this,(function(d){switch(d.label){case 0:return t=U(e,ue),n=t.imageTensor,r=t.padding,i=this.detectorModel.predict(n),a=function(e){return(0,s.lub)((function(){var t=function(e){return(0,s.lub)((function(){return[(0,s.tPi)(e,[0,0,0],[1,-1,1]),(0,s.tPi)(e,[0,0,1],[1,-1,-1])]}))}(e),n=t[0],r=t[1];return{boxes:(0,s.L9e)(r),logits:(0,s.L9e)(n)}}))}(i),o=a.boxes,[4,H([u=a.logits,o],this.anchorTensor,se)];case 1:return 0===(l=d.sent()).length?((0,s.B90)([n,i,u,o]),[2,l]):[4,M(l,this.maxPoses,.3)];case 2:return c=d.sent(),h=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,i=t.left+t.right,a=t.top+t.bottom,s=0;s<e.length;s++){var o=e[s],u=o.locationData.relativeBoundingBox,l=(u.xMin-n)/(1-i),c=(u.yMin-r)/(1-a),d=u.width/(1-i),h=u.height/(1-a);u.xMin=l,u.yMin=c,u.width=d,u.height=h,u.xMax=l+d,u.yMax=c+h;var p=o.locationData.relativeKeypoints;p&&p.forEach((function(e){var t=(e.x-n)/(1-i),s=(e.y-r)/(1-a);e.x=t,e.y=s}))}return e}(c,r),(0,s.B90)([n,i,u,o]),[2,h]}}))}))},e.prototype.poseDetectionToRoi=function(e,t){return Y(N(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,oe)},e.prototype.poseLandmarksByRoi=function(e,t){return c(this,void 0,void 0,(function(){var n,r,i,a,o,u,c,h,p,f,m,g,x,b;return d(this,(function(d){switch(d.label){case 0:if(n=$(t),r=U(t,le,e),i=r.imageTensor,a=r.padding,o=r.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),c=this.landmarkModel.execute(i,u),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return null==(h=d.sent())?((0,s.B90)(c),(0,s.B90)(i),[2,null]):(p=h.landmarks,f=h.auxiliaryLandmarks,m=h.poseScore,g=h.worldLandmarks,x=h.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,a,o,p,f,g,x)]);case 2:return b=d.sent(),(0,s.B90)(c),(0,s.B90)(i),[2,l({poseScore:m},b)]}}))}))},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,r,i,a,o,u){return c(this,void 0,void 0,(function(){var c,h,p,f,m,g;return d(this,(function(d){return c=G(i,n),h=G(a,n),p=P(c,t),f=P(h,t),m=function(e,t){for(var n=[],r=0,i=e;r<i.length;r++){var a=i[r],s=a.x,o=a.y,u=t.rotation,c=Math.cos(u)*s-Math.sin(u)*o,d=Math.sin(u)*s+Math.cos(u)*o,h=l({},a);h.x=c,h.y=d,n.push(h)}return n}(o,t),g=null,this.enableSegmentation&&(g=(0,s.lub)((function(){var t=u.shape,n=t[0],i=t[1],a=function(e){var t=D(new Array(16).fill(0));t[0][0]=F(e,0,0),t[1][0]=-F(e,0,1),t[2][0]=F(e,0,2),t[3][0]=-F(e,0,3),t[0][2]=F(e,2,0),t[1][2]=-F(e,2,1),t[2][2]=F(e,2,2),t[3][2]=-F(e,2,3),t[0][1]=-F(e,1,0),t[1][1]=F(e,1,1),t[2][1]=-F(e,1,2),t[3][1]=F(e,1,3),t[0][3]=-F(e,3,0),t[1][3]=F(e,3,1),t[2][3]=-F(e,3,2),t[3][3]=F(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],r=0;r<t.length;r++)for(var i=0;i<t.length;i++)t[r][i]/=n;return t}(r),o=(0,s.odF)(A(a,{width:i,height:n},e),[1,8]),l=[1,n,i,1];return(0,s.L9e)(s.BHj.transform((0,s.XLQ)(u,l),o,"bilinear","constant",0,[e.height,e.width]),[0,3])})),(0,s.B90)(u)),[2,{landmarks:p,auxiliaryLandmarks:f,worldLandmarks:m,segmentationMask:g}]}))}))},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return c(this,void 0,void 0,(function(){var t,n,r,i,a,o,u,c,h,p,f,m,g;return d(this,(function(d){switch(d.label){case 0:return t=e[0],n=e[1],r=e[2],i=e[3],a=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(o=d.sent()[0])<.5?[2,null]:[4,q(t,ce)];case 2:return[4,V(d.sent(),r,he)];case 3:return u=d.sent(),c=u.slice(0,33),h=u.slice(33,35),[4,q(i,de)];case 4:return p=d.sent(),f=p.slice(0,33),m=function(e,t,n){void 0===n&&(n=!0);for(var r=[],i=0;i<e.length;i++){var a=l({},t[i]);n&&(a.score=e[i].score),r.push(a)}return r}(c,f,!0),g=this.enableSegmentation?function(e,t,n){return(0,s.lub)((function(){var n=(0,s.L9e)(e,[0]),r=n.shape[2];if(1===r){var i=n;switch(t.activation){case"none":break;case"sigmoid":i=(0,s.XD2)(i);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}var a=i;return(0,s.L9e)(a,[2])}throw new Error("Unsupported number of tensor channels ".concat(r))}))}(a,xe):null,[2,{landmarks:c,auxiliaryLandmarks:h,poseScore:o,worldLandmarks:m,segmentationMask:g}]}}))}))},e.prototype.poseLandmarksToRoi=function(e,t){return Y(N(z(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,oe)},e.prototype.poseLandmarkFiltering=function(e,t,n,r){var i,a,s;if(null!=this.timestamp&&this.enableSmoothing){var o=N(z(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new re(pe)),i=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new re(pe)),a=this.visibilitySmoothingFilterAuxiliary.apply(t),s=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new ne(fe)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new ne(me)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,o),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new ne(ge)),s=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else i=e,a=t,s=n;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:s}}}();var ve,ke,Ce,Ie=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var r=n[t];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(n){return e-n.lastTimestamp<=t.maxAge}))},e.prototype.assignTracks=function(e,t,n){for(var r=Array.from(Array(t[0].length).keys()),i=[],a=0,s=Array.from(Array(e.length).keys());a<s.length;a++){var o=s[a];if(0!==r.length){for(var u=-1,l=-1,c=0,d=r;c<d.length;c++){var h=d[c],p=t[o][h];p>=this.minSimilarity&&p>l&&(u=h,l=p)}if(u>=0){var f=this.tracks[u];f=Object.assign(f,this.createTrack(e[o],n,f.id)),e[o].id=f.id;var m=r.indexOf(u);r.splice(m,1)}else i.push(o)}else i.push(o)}for(var g=0,x=i;g<x.length;g++){o=x[g];var b=this.createTrack(e[o],n);this.tracks.push(b),e[o].id=b.id}},e.prototype.updateTracks=function(e){this.tracks.sort((function(e,t){return t.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var r={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:h([],e.keypoints,!0).map((function(e){return l({},e)}))};return void 0!==e.box&&(r.box=l({},e.box)),r},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(t){return!e.includes(t.id)}))},e.prototype.reset=function(){this.tracks=[]},e}(),Se=function(e){function t(t){return e.call(this,t)||this}return u(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map((function(e){return t.tracks.map((function(n){return t.iou(e,n)}))}))},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),r=Math.max(e.box.yMin,t.box.yMin),i=Math.min(e.box.xMax,t.box.xMax),a=Math.min(e.box.yMax,t.box.yMax);if(n>=i||r>=a)return 0;var s=(i-n)*(a-r);return s/(e.box.width*e.box.height+t.box.width*t.box.height-s)},t}(Ie),$e=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return u(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,r=e;n<r.length;n++){for(var i=r[n],a=[],s=0,o=this.tracks;s<o.length;s++){var u=o[s];a.push(this.oks(i,u))}t.push(a)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,r=0,i=0,a=0;a<e.keypoints.length;++a){var s=e.keypoints[a],o=t.keypoints[a];if(!(s.score<this.keypointThreshold||o.score<this.keypointThreshold)){i+=1;var u=Math.pow(s.x-o.x,2)+Math.pow(s.y-o.y,2),l=2*this.keypointFalloff[a];r+=Math.exp(-1*u/(2*n*Math.pow(l,2)))}}return i<this.minNumKeyoints?0:r/i},t.prototype.area=function(e){var t=this,n=e.filter((function(e){return e.score>t.keypointThreshold})),r=Math.min.apply(Math,h([1],n.map((function(e){return e.x})),!1)),i=Math.max.apply(Math,h([0],n.map((function(e){return e.x})),!1)),a=Math.min.apply(Math,h([1],n.map((function(e){return e.y})),!1));return(i-r)*(Math.max.apply(Math,h([0],n.map((function(e){return e.y})),!1))-a)},t}(Ie);function Re(e){switch(e){case ke.BlazePose:return f.reduce((function(e,t,n){return e[t]=n,e}),{});case ke.PoseNet:case ke.MoveNet:return p.reduce((function(e,t,n){return e[t]=n,e}),{});default:throw new Error("Model ".concat(e," is not supported."))}}(Ce=ve||(ve={})).Keypoint="keypoint",Ce.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(ke||(ke={})),Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case ke.BlazePose:return m;case ke.PoseNet:case ke.MoveNet:return g;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case ke.BlazePose:return b;case ke.PoseNet:case ke.MoveNet:return x;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:Re});var Te={},Ae={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0};function Ee(e,t){var n,r,i,a;return e?t.width>t.height?(n=1,r=t.height/t.width,i=0,a=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,a=0):t.width>t.height?(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,a=0):(n=1,r=t.height/t.width,i=0,a=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:a,yMax:i+n,xMax:a+r,height:n,width:r}}!function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Re(ke.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new J(Ae),this.cropRegionFilterYMin=new Q(.9),this.cropRegionFilterXMin=new Q(.9),this.cropRegionFilterYMax=new Q(.9),this.cropRegionFilterXMax=new Q(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===ve.Keypoint?this.tracker=new $e(t.trackerConfig):t.trackerType===ve.BoundingBox&&(this.tracker=new Se(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}e.prototype.runSinglePersonPoseModel=function(e){return c(this,void 0,void 0,(function(){var t,n,r,i,a;return d(this,(function(o){switch(o.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===(0,s.N_N)()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=o.sent(),o.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},i=0,a=0;a<17;++a)r.keypoints[a]={y:n[3*a],x:n[3*a+1],score:n[3*a+2]},r.keypoints[a].score>.2&&(++i,r.score+=r.keypoints[a].score);return i>0&&(r.score/=i),[2,r]}}))}))},e.prototype.runMultiPersonPoseModel=function(e){return c(this,void 0,void 0,(function(){var t,n,r,i,a,o,u,l;return d(this,(function(c){switch(c.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===(0,s.N_N)()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=c.sent(),c.label=3;case 3:for(t.dispose(),r=[],i=n.length/56,a=0;a<i;++a)for(r[a]={keypoints:[]},o=56*a+51,r[a].box={yMin:n[o],xMin:n[o+1],yMax:n[o+2],xMax:n[o+3],width:n[o+3]-n[o+1],height:n[o+2]-n[o]},u=56*a+55,r[a].score=n[u],r[a].keypoints=[],l=0;l<17;++l)r[a].keypoints[l]={y:n[56*a+3*l],x:n[56*a+3*l+1],score:n[56*a+3*l+2]};return[2,r]}}))}))},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=Te),c(this,void 0,void 0,(function(){var r,i,a,o,u,c;return d(this,(function(d){switch(d.label){case 0:return t=function(e){return null==e?Te:l({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?L(e)&&(n=1e6*e.currentTime):n*=1e3,r=T(e),i=$(r),a=(0,s.dt4)(r,0),e instanceof s.esB||r.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,i,n)]);case 1:return o=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,i,n)];case 3:o=d.sent(),d.label=4;case 4:for(u=0;u<o.length;++u)for(c=0;c<o[u].keypoints.length;++c)o[u].keypoints[c].name=p[c],o[u].keypoints[c].y*=i.height,o[u].keypoints[c].x*=i.width;return[2,o]}}))}))},e.prototype.estimateSinglePose=function(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,o,u=this;return d(this,(function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=Ee(null==this.cropRegion,t)),r=(0,s.lub)((function(){var t=(0,s.odF)([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),n=(0,s.lls)([1],"int32"),r=[u.modelInputResolution.height,u.modelInputResolution.width];return(0,s.pju)(s.BHj.cropAndResize(e,t,n,r,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(i=l.sent(),r.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<i.keypoints.length;++a)i.keypoints[a].y=this.cropRegion.yMin+i.keypoints[a].y*this.cropRegion.height,i.keypoints[a].x=this.cropRegion.xMin+i.keypoints[a].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,n,1)),o=function(e,t,n,r){for(var i={},a=0,s=p;a<s.length;a++){var o=s[a];i[o]=[t[n[o]].y*r.height,t[n[o]].x*r.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var u=(i.left_hip[0]+i.right_hip[0])/2,l=(i.left_hip[1]+i.right_hip[1])/2,c=function(e,t,n,r,i){for(var a=["left_shoulder","right_shoulder","left_hip","right_hip"],s=0,o=0,u=0;u<a.length;u++)(p=Math.abs(r-n[a[u]][0]))>s&&(s=p),(f=Math.abs(i-n[a[u]][1]))>o&&(o=f);for(var l=0,c=0,d=0,h=Object.keys(n);d<h.length;d++){var p,f,m=h[d];e[t[m]].score<.2||((p=Math.abs(r-n[m][0]))>l&&(l=p),(f=Math.abs(i-n[m][1]))>c&&(c=f))}return[s,o,l,c]}(t,n,i,u,l),d=c[0],h=c[1],f=c[2],m=c[3],g=Math.max(1.9*h,1.9*d,1.2*f,1.2*m),x=[u-(g=Math.min(g,Math.max(l,r.width-l,u,r.height-u))),l-g];if(g>Math.max(r.width,r.height)/2)return Ee(null==e,r);var b=2*g;return{yMin:x[0]/r.height,xMin:x[1]/r.width,yMax:(x[0]+b)/r.height,xMax:(x[1]+b)/r.width,height:(x[0]+b)/r.height-x[0]/r.height,width:(x[1]+b)/r.width-x[1]/r.width}}return Ee(null==e,r)}(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(o),[2,[i]]}}))}))},e.prototype.estimateMultiplePoses=function(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,o,u,l,c,h,p,f,m,g=this;return d(this,(function(d){switch(d.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=s.BHj.resizeBilinear(e,[a,i]),u=i,l=32*Math.ceil(a/32),o=(0,s.vku)(r,[[0,0],[0,l-a],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),a=this.multiPoseMaxDimension,r=s.BHj.resizeBilinear(e,[a,i]),u=32*Math.ceil(i/32),l=a,o=(0,s.vku)(r,[[0,0],[0,0],[0,u-i],[0,0]])),r.dispose(),e.dispose(),c=(0,s.pju)(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=d.sent(),c.dispose(),h=h.filter((function(e){return e.score>=g.minPoseScore})),f=0;f<h.length;++f)for(p=0;p<h[f].keypoints.length;++p)h[f].keypoints[p].y*=l/a,h[f].keypoints[p].x*=u/i;if(this.enableTracking&&(this.tracker.apply(h,n),this.enableSmoothing)){for(f=0;f<h.length;++f)this.keypointFilterMap.has(h[f].id)||this.keypointFilterMap.set(h[f].id,new J(Ae)),h[f].keypoints=this.keypointFilterMap.get(h[f].id).apply(h[f].keypoints,n,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(e,t){m.has(t)||g.keypointFilterMap.delete(t)}))}return[2,h]}}))}))},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:i,height:r-t,width:i-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()}}();var Ne=[8,16,32],De={maxPoses:1,flipHorizontal:!1},_e={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Fe=[-123.15,-115.9,-103.06];function Pe(e){return Math.floor(e/2)}var Oe=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(Pe(e),e);)this.exchange(e,Pe(e)),e=Pe(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function Ue(e,t,n,r,i,a){for(var s=a.shape,o=s[0],u=s[1],l=!0,c=Math.max(n-i,0),d=Math.min(n+i+1,o),h=c;h<d;++h){for(var p=Math.max(r-i,0),f=Math.min(r+i+1,u),m=p;m<f;++m)if(a.get(h,m,e)>t){l=!1;break}if(!l)break}return l}function Be(e){return c(this,void 0,void 0,(function(){return d(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function Le(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function ze(e,t,n){var r=Le(e.heatmapY,e.heatmapX,e.id,n),i=r.y,a=r.x;return{x:e.heatmapX*t+a,y:e.heatmapY*t+i}}function Me(e,t,n,r){var i=n.x,a=n.y;return e.some((function(e){var n,s,o,u,l=e.keypoints;return n=a,s=i,(o=l[r].y-n)*o+(u=l[r].x-s)*u<=t}))}var We=p.reduce((function(e,t,n){return e[t]=n,e}),{}),Ve=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(e){var t=e[0],n=e[1];return[We[t],We[n]]})),Ge=Ve.map((function(e){return e[1]})),He=Ve.map((function(e){return e[0]}));function je(e,t,n){return e<t?t:e>n?n:e}function Xe(e,t,n,r){return{y:je(Math.round(e.y/t),0,n-1),x:je(Math.round(e.x/t),0,r-1)}}function Ke(e,t){return{x:e.x+t.x,y:e.y+t.y}}function qe(e,t,n,r,i,a,s,o){void 0===o&&(o=2);for(var u=r.shape,l=u[0],c=u[1],d={y:t.y,x:t.x},h=Ke(d,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,Xe(d,a,l,c),s)),f=0;f<o;f++){var m=Xe(h,a,l,c),g=Le(m.y,m.x,n,i);h=Ke({x:m.x*a,y:m.y*a},{x:g.x,y:g.y})}var x=Xe(h,a,l,c),b=r.get(x.y,x.x,n);return{y:h.y,x:h.x,name:p[n],score:b}}function Ye(e,t,n,r,i,a){var s=t.shape[2],o=Ge.length,u=new Array(s),l=e.part,c=e.score,d=ze(l,r,n);u[l.id]={score:c,name:p[l.id],y:d.y,x:d.x};for(var h=o-1;h>=0;--h){var f=Ge[h],m=He[h];u[f]&&!u[m]&&(u[m]=qe(h,u[f],m,t,n,r,a))}for(h=0;h<o;++h)f=He[h],m=Ge[h],u[f]&&!u[m]&&(u[m]=qe(h,u[f],m,t,n,r,i));return u}function Qe(e,t,n){return n.reduce((function(n,r,i){var a=r.y,s=r.x,o=r.score;return Me(e,t,{y:a,x:s},i)||(n+=o),n}),0)/n.length}function Ze(e,t,n,r,i,a,s,o){return void 0===s&&(s=.5),void 0===o&&(o=20),c(this,void 0,void 0,(function(){var u,l,c,h,p,f,m,g,x,b,y,w;return d(this,(function(d){switch(d.label){case 0:return[4,Be([e,t,n,r])];case 1:for(u=d.sent(),l=u[0],c=u[1],h=u[2],p=u[3],f=[],m=function(e,t,n){for(var r=n.shape,i=r[0],a=r[1],s=r[2],o=new Oe(i*a*s,(function(e){return e.score})),u=0;u<i;++u)for(var l=0;l<a;++l)for(var c=0;c<s;++c){var d=n.get(u,l,c);d<e||Ue(c,d,u,l,1,n)&&o.enqueue({score:d,part:{heatmapY:u,heatmapX:l,id:c}})}return o}(s,0,l),g=o*o;f.length<a&&!m.empty();)x=m.dequeue(),b=ze(x.part,i,c),Me(f,g,b,x.part.id)||(y=Ye(x,l,c,i,h,p),w=Qe(f,g,y),f.push({keypoints:y,score:w}));return[2,f]}}))}))}const Je=(0,s.OBj)();Je.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),Je.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),Je.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),Je.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),Je.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),Je.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),Je.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),Je.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>0)),Je.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1));class et{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class tt{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=nt(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(i),i}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=nt(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const i=this.usedBuffers.get(r),a=i.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(a,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function nt(e,t){return`${e}_${t}`}class rt{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const i=e*t*at(n),a=it(e,t,n,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const e=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(e),e}this.numBytesAllocated+=i;const s=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(a).push(s),s}releaseTexture(e,t,n,r,i){if(0===this.freeTextures.size)return;const a=it(t,n,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const s=this.usedTextures.get(a),o=s.indexOf(e);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");s.splice(o,1);const u=t*n*at(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function it(e,t,n,r){return`${e}_${t}_${n}_${r}`}function at(e){if("rgba8unorm"===e)return 16;throw new Error(e+" is not supported!")}function st(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}const ot=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;function ut(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function lt(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function ct(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function dt(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const ht="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n";function pt(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=s.D5U.computeStrides(e),r=ut(t),i=[];for(let e=0;e<t;e++)i.push("d"+e);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let a;return a="var index2 = index;"+n.map(((e,t)=>`let ${i[t]} = index2 / uniforms.outShapeStrides.${lt(t)}; ${t===n.length-1?`let ${i[t+1]} = index2 - ${i[t]} * uniforms.outShapeStrides.${lt(t)}`:`index2 = index2 - ${i[t]} * uniforms.outShapeStrides.${lt(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${r} {\n      ${a}\n      return ${r}(${i.join(",")});\n    }\n  `}function ft(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:s.D5U.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function mt(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function gt(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function xt(e){return!(e.dispatchLayout.hasOwnProperty("y")&&0!==e.dispatchLayout.y.length||e.dispatchLayout.hasOwnProperty("z")&&0!==e.dispatchLayout.z.length)}const bt=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function yt(e,t,n=[1,1,1],r=[1,1,1]){const[i,a,s]=[Math.ceil(bt(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(bt(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(bt(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[i,a,s]}function wt(e,t,n=!1){if(n)return[8,8,1];const r=bt(e.x.map((e=>t[e]))),i=bt(e.y.map((e=>t[e])));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function vt(e,t,n=!1){if(n)return[4,4,1];const r=bt(e.x.map((e=>t[e]))),i=bt(e.y.map((e=>t[e])));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function kt(e){return{x:e.map(((e,t)=>t))}}function Ct(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype "+e)}function It(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var St;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(St||(St={}));const $t=(0,s.OBj)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class Rt extends s.Zuw{constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!It())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new et(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new tt(this.device),this.textureManager=new rt(this.device),this.tensorMap=new s.JLz(this,(0,s.SRH)()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),(0,s.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return Rt.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),(0,s.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(s.D5U.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return this.convertAndCacheOnCPU(e,n);let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],i=e[1];r=s.backend_util.mergeRealAndImagArrays(n,i)}else{const e=t.resourceInfo,n=await this.getBufferData(e.buffer,e.size);r=s.D5U.convertBackendValuesAndArrayBuffer(n,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e,t,n){const r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let r=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const a=this.tensorMap.get(i),o=Ct(a.dtype)*s.D5U.sizeFromShape(a.shape);if(e.buffer.size<o)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(r=this.copyBuffer(r,o,r.usage)),a.resourceInfo={size:r.size,usage:r.usage,buffer:r},(0,s.SRH)().makeTensorFromDataId(i,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:i,resourceInfo:a}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==a)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a.size,u=this.bufferManager.acquireBuffer(o,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,u,0,o),this.submitQueue();const l=this.makeTensorInfo(i,r),c=(0,s.SRH)().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:c,buffer:u,bufSize:o}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>s.D5U.decodeString(e)));return(0,s.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,s.f3b)(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const i=s.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=s.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(i);return o.kernelMs=s.D5U.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){return"string"===t&&null!=n&&n.length>0&&s.D5U.isString(n[0])&&(n=n.map((e=>s.D5U.encodeString(e)))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=Ct(t.dtype)*s.D5U.sizeFromShape(t.shape),r=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:r},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),i=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,n);const a={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(a)}}makeUniforms(e){let t=0,n=0;const r=[];let i=1;e.forEach((e=>{let a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:s.D5U.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(a=16),a>i&&(i=a),t=Math.ceil(t/a)*a,n=e.data.length,r.push(t),t+=4*e.data.length})),t=Math.ceil(t/i)*i;const a=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=r[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(o,0,a,0,t);const u={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:o};return this.uniformPendingDisposal.push(u),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,t,n,r,i){if(i||(i=this.makeTensorInfo(e.outputShape,n)),0===s.D5U.sizeFromShape(i.shape))return this.tensorMap.get(i.dataId).values=s.D5U.getTypedArrayFromDType(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,r=t.dispatchLayout,i=t.dispatch;if(i.every((e=>e<=n)))return i;s.D5U.assert(i[0]>n&&void 0===r.y&&void 0===r.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(i[0]));return a>n?(a=Math.ceil(Math.cbrt(i[0])),s.D5U.assert(a<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);let a=[],o=[];if(!e.isFromPixels){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=t.concat(i).map((e=>e.shape));const n="int32";o.map((e=>{a.push({type:n,data:e})}));const r=s.D5U.computeStrides(i.shape);if(a.push({type:n,data:r}),e.size){const t=s.D5U.sizeFromShape(e.outputShape);a.push({type:n,data:[e.isVec4?t/4:t]})}}const u=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),l=function(e,t,n,r){let i=e.shaderKey;if(e.isFromPixels)return i;const a=n.map((e=>e.dtype)).concat(r.dtype),o=n.map((e=>s.backend_util.getBroadcastDims(e.shape,r.shape))),u=n.map((e=>s.D5U.arraysEqual(e.shape,r.shape))).join("_"),l=o.map((e=>e.join("_"))).join(";"),c=mt(e)?"flatDispatch":"";return i+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+t.map((e=>e.length)).join(",")+a.join(",")+e.variableNames.join(",")+l+u+c,i}(e,o,u,i);let c;l in this.pipelineCache?c=this.pipelineCache[l]:(c=((e,t,n,r)=>{const i=function(e,t,n){const r=[],i=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(r.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${mt(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +\n                localIndex);\n        `}\n      }\n    `),n.isFromPixels){r.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${gt(t.dtype,n.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const e=xt(n);return[ht,r.join("\n"),pt(t.shape),n.getUserCode(),dt(e,n)].join("\n")}let a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(((t,n)=>{const r=ut(e[n].shape.length);a+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `}));const o=ut(t.shape.length);a+=`outShape : ${o}, `;const u=ut(t.shape.length-1);a+=`\n         outShapeStrides: ${u}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=function(e){return(e=e.replace(/(\w+)\s*:\s*vec(5|6)/g,(e=>"@align(16) "+e))).replace(/vec(5|6)\s*,\s*(\w+)/g,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(a),r.push(a),n.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${gt(t.dtype,n.isVec4)}>;\n    `),n.variableNames.forEach(((t,i)=>{r.push(`\n      @group(0) @binding(${1+i}) var<storage, read> ${t}: array<${n.variableTypes?n.variableTypes[i]:gt(e[i].dtype,n.isVec4)}>;\n        `)})),""!==a&&r.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const l=function(e,t){const{x:n,y:r=[],z:i=[]}=t,a=e.length,s=n.length+r.length+i.length;if(s!==a)return"";if(n.length===a)return`fn getOutputCoords() -> ${ut(a)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;let o="";const u=[n,r,i];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=st(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<s;e++)l.push("d"+e);const c=ut(s);let d=`fn getOutputCoords() -> ${c} {\n  ${o}\n`;return 0===l.length?d+=`return ${c}(0); }`:d+=`return ${c}(${l.join(",")}); }`,d}(t.shape,n.dispatchLayout),c=[ht,r.join("\n")+"\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n",pt(t.shape),l,ft(t.shape.length)];n.atomic||c.push(function(e,t,n){const r=e.length,i=gt(t,n);let a;if(a=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${i}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${i}(value);\n    }`,r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=ut(r);a+=n?`\n      fn setOutputAtCoords(${e.map((e=>e+" : i32")).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>e+" : i32")).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>e+" : i32")).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>e+" : i32")).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return a}(t.shape,t.dtype,n.isVec4));const d=e.map(((e,r)=>function(e,t,n,r){let i=function(e,t){const n=e.name,r=e.shape.length,i=ut(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=s.map((e=>e+" : i32")).join(", ");if(r<1)return t?`\n        fn ${a}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${a}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=r+"D";return 0===r&&(l="1D"),t?`\n      fn ${a}(${o}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${i}(${s.join(",")}),\n          ${u}) / 4]);\n      }\n      `:`\n    fn ${a}(${o}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${i}(${s.join(",")}),\n        ${u})]);\n    }\n   `}(e,n);return e.shape.length<=t.length&&(i+=function(e,t,n,r){const i=e.name,a=i.charAt(0).toUpperCase()+i.slice(1),o="get"+a+"ByOutput",u=e.shape.length,l=t.length,c=ut(l);if(s.D5U.arraysEqual(e.shape,t)&&r)return n?`\n      fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${i}[globalIndex]);\n      }\n\n      fn ${o}Coords(coords : ${c}) -> vec4<f32> {\n        return vec4<f32>(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${o}Index(globalIndex : i32) -> f32 {\n      return f32(${i}[globalIndex]);\n    }\n\n    fn ${o}Coords(coords : ${c}) -> f32 {\n      return f32(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const d=s.backend_util.getBroadcastDims(e.shape,t),h=l-u;let p="";if(0===u)return n?`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      return get${a}();\n    }\n\n    fn ${o}Coords(coords : ${c}) -> vec4<f32> {\n      return get${a}();\n    }\n  `:`\n    fn ${o}Index(globalIndex : i32) -> f32{\n      return get${a}();\n    }\n\n    fn ${o}Coords(coords : ${c}) -> f32{\n      return get${a}();\n    }\n  `;p=l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${lt(e+h)} = 0;`)).join("\n");let f="";if(l<2&&u>0)f="coords";else if(l>1){const t=ut(u),n=e.shape.map(((e,t)=>"coords."+lt(t+h))).join(", ");f=`${t}(${n})`}else f="coords";const m=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,g=u+"D";return n?`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${p}\n      return ${i}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n\n    fn ${o}Coords(coordsIn : ${c}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${p}\n      return ${i}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n  `:`\n  fn ${o}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${p}\n    return f32(${i}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n\n  fn ${o}Coords(coordsIn : ${c}) -> f32 {\n    var coords = coordsIn;\n    ${p}\n    return f32(${i}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n`}(e,t,n,r)),i}(e,t.shape,n.variableTypes?"vec4<f32>"===n.variableTypes[r]:n.isVec4,n.dispatchLayout.x.length===t.shape.length))).join("\n");c.push(d),c.push(n.getUserCode());const h=xt(n);return c.push(dt(h,n)),c.join("\n")}(n,{dtype:r.dtype,shape:r.shape},t),a=e.createShaderModule({code:i,label:t.constructor.name});return e.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})})(this.device,e,u,i),this.pipelineCache[l]=c),r&&(a=[...a,...r]);const d=[this.tensorToBinding(i),...t.map((e=>this.tensorToBinding(e))),this.makeUniforms(a)],h=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:d.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const p=this.getComputePass(),f=null!=this.activeTimers;return f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,0),p.setPipeline(c),p.setBindGroup(0,h),p.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(i.dataId),(0,s.OBj)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),f&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),i}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),i/1e6}shouldExecuteOnCPU(e,t=$t){return(0,s.OBj)().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&s.D5U.sizeFromShape(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var Tt;Rt.nextDataId=0,It()&&(0,s.jqO)("webgpu",(async()=>{(0,s.OBj)().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:(0,s.OBj)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={};t.features.has("timestamp-query-inside-passes")&&(n.requiredFeatures=["timestamp-query-inside-passes"]);const r=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize};const i=await t.requestDevice(n),a=await t.requestAdapterInfo();return new Rt(i,a)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.INT_DIV=8]="INT_DIV",e[e.LESS=9]="LESS",e[e.LESS_EQUAL=10]="LESS_EQUAL",e[e.LOGICAL_AND=11]="LOGICAL_AND",e[e.LOGICAL_OR=12]="LOGICAL_OR",e[e.MAX=13]="MAX",e[e.MIN=14]="MIN",e[e.MOD=15]="MOD",e[e.MUL=16]="MUL",e[e.NOT_EQUAL=17]="NOT_EQUAL",e[e.POW=18]="POW",e[e.PRELU=19]="PRELU",e[e.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",e[e.SUB=21]="SUB"}(Tt||(Tt={}));const At="\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ",Et="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",Nt=`\n  ${At}\n  if (b == 0.) {\n    return uniforms.NAN;\n  }\n  var resultTemp = a % b;\n  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {\n    return resultTemp;\n  } else {\n    return (resultTemp + b) % b;\n  }\n`,Dt=`\n  let isNaN = !vec4<bool>(b);\n  let valueForNaN = uniforms.NAN;\n  var resultTemp = vec4<f32>(a % b);\n  ${Et}\n\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n\n  return resultTemp;\n`,_t=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${Et}\n\n  return resultTemp;\n`,Ft=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${Et}\n  return resultTemp;\n`;function Pt(e,t,n="uniforms.NAN"){const r=t?Et:At;return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function Ot(e,t){switch(e){case Tt.ADD:return"return a + b;";case Tt.ATAN2:return Pt("atan2",t);case Tt.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case Tt.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case Tt.DIV:return"return a / b;";case Tt.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case Tt.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case Tt.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case Tt.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n";case Tt.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case Tt.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case Tt.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case Tt.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case Tt.MAX:return Pt("max",t);case Tt.MIN:return Pt("min",t);case Tt.MOD:return t?Dt:Nt;case Tt.MUL:return"return a * b;";case Tt.NOT_EQUAL:return t?_t:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case Tt.POW:return t?Ft:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n";case Tt.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case Tt.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case Tt.SUB:return"return a - b;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var Ut;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(Ut||(Ut={}));const Bt=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${s.backend_util.ERF_P};\n  let a1 = ${s.backend_util.ERF_A1};\n  let a2 = ${s.backend_util.ERF_A2};\n  let a3 = ${s.backend_util.ERF_A3};\n  let a4 = ${s.backend_util.ERF_A4};\n  let a5 = ${s.backend_util.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,Lt=`\n  if (a >= 0.0) {\n    return ${s.backend_util.SELU_SCALE} * a;\n  } else {\n    return ${s.backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function zt(e,t){switch(e){case Ut.ABS:return"return abs(a);";case Ut.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case Ut.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case Ut.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case Ut.ASINH:return"return asinh(a);";case Ut.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case Ut.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case Ut.COS:return"return cos(a);";case Ut.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case Ut.CEIL:return"return ceil(a);";case Ut.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Ut.ERF:return Bt;case Ut.EXP:return"return exp(a);";case Ut.EXPM1:return"return exp(a) - 1.0;";case Ut.FLOOR:return"return floor(a);";case Ut.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case Ut.IS_INF:return"return f32(isinf(a));";case Ut.IS_NAN:return"return f32(isnan(a));";case Ut.LINEAR:return"return a;";case Ut.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case Ut.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case Ut.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Ut.NEG:return"return -a;";case Ut.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Ut.RECIPROCAL:return"return 1.0 / a;";case Ut.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case Ut.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Ut.ROUND:return"return round(a);";case Ut.RSQRT:return"return inverseSqrt(a);";case Ut.SELU:return Lt;case Ut.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Ut.SIGN:return"return sign(a);";case Ut.SIN:return"return sin(a);";case Ut.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case Ut.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case Ut.SQRT:return"return sqrt(a);";case Ut.SQUARE:return"return a * a;";case Ut.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case Ut.TAN:return"return tan(a);";case Ut.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case Ut.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const Mt=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(e+"-component is not supported.")}};function Wt(e,t=!1,n=!1,r=3){if(null===e)return"";let i="";if("linear"===e)i=zt(Ut.LINEAR);else if("relu"===e)i=zt(Ut.RELU,n);else if("elu"===e)i=zt(Ut.ELU,n);else if("relu6"===e)i=zt(Ut.RELU6,n);else if("prelu"===e)i=Ot(Tt.PRELU,n);else if("sigmoid"===e)i=zt(Ut.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);i=zt(Ut.LEAKYRELU,n)}const a=Mt(n?4:1);let s="";return s=t?`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${i}\n      }`:`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        ${i}\n      }`,s}function Vt(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function Gt(e,t,n=!1,r=!1,i=!1,a=1){s.D5U.assert(e&&1===a||!e,(()=>`transposeA ${e} is not compatible with component size ${a}`));const o=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${Mt(a)} {\n    var value = ${Mt(a)}(0.0);\n    let col = colIn * ${a};\n    ${n&&i?o:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${Mt(a)} {\n    let col = colIn * ${a};\n    var value = ${Mt(a)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function Ht(e,t,n,r,i=!1,a=!1,s=!1,o=1){return`\n  ${Gt(n,r,i,a,s,o)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Mt(o)}) {\n    let col = colIn * ${o};\n    ${i&&a?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${Vt(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function jt(e,t,n=!1,r=32,i=!1,a=32,o=!1,u=!1){const l=t[1]*e[1],c=t[0]*e[0],d=n?l:r,h=n?r:l,p=d/t[0],f=r/t[1],m=e[1];return s.D5U.assert((n&&4===p&&4===e[1]||!n&&(3===p||4===p))&&d%t[0]==0&&r%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${p} must be 3 or 4.\n      tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${d/p}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${c/e[0]}>, ${r}>;\n\n  ${ct()} {\n    let localRow = i32(localId.y);\n    let tileRow = ${o?"0":"localRow * "+m};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${o?"0":"i32(globalId.y) * "+m};\n    let globalCol = i32(globalId.x);\n    let batch = ${i?"0":"i32(globalId.z)"};\n    let batchA = ${i||!u?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${i||!u?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${l};\n\n    let numTiles = ${i?""+Math.ceil(a/r):`(uniforms.dimInner - 1) / ${r} + 1`};\n    var kStart = ${i?"i32(globalId.z) * "+a:"0"};\n\n    var acc: array<vec4<f32>, ${m}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${f};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ${t} + inputCol);\n        `)(n,p)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${r/p}; k++) {\n            let BCached0 = mm_Bsub[k * ${p}][tileCol];\n            let BCached1 = mm_Bsub[k * ${p} + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ${p} + 2][tileCol];\n            ${3===p?"":`let BCached3 = mm_Bsub[k * ${p} + 3][tileCol];`}\n\n            ${((e,t,n)=>e?`\n        let ACached0 = mm_Asub[k * ${t}][localRow];\n        let ACached1 = mm_Asub[k * ${t} + 1][localRow];\n        let ACached2 = mm_Asub[k * ${t} + 2][localRow];\n        ${3===t?"":`let ACached3 = mm_Asub[k * ${t} + 3][localRow];`}\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,p,m)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const Xt=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function Kt(e,t,n=!1,r=32,i=!1,a=32,o=!1,u=!1){const l=e[1]*t[1],c=e[0]*t[0],d=n?l:r,h=n?r:l;s.D5U.assert(h%t[1]==0&&d%t[0]==0&&r%t[1]==0,(()=>`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${r} must be divisible by workgroupSize[1]${t[1]}`));const p=h/t[1],f=d/t[0],m=r/t[1],g=e[1],x=e[0],b=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${c};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n            ${Xt(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${x}>;\n        for (var k = 0; k < ${r}; k++) {\n          for (var inner = 0; inner < ${x}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${x};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${x};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${p};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${Xt(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${r};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${x}>;\n    for (var k = 0; k < ${r}; k++) {\n      for (var inner = 0; inner < ${x}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${h}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;\n\n    ${ct()} {\n      let batch = ${i?"0":"i32(globalId.z)"};\n      let batchA = ${i||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${i||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${i?""+Math.ceil(a/r):`(uniforms.dimInner - 1) / ${r} + 1`};\n      var kStart = ${i?"i32(globalId.z) * "+a:"0"};\n\n      var acc : array<array<f32, ${x}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${b}\n    }\n  `}class qt{constructor(e,t,n=!1,r=!1,i=null,a=null,s=null,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!r,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n,r=!1){const i=[8,8,1],a=[4,4,1];return r||(e<=8&&(a[1]=1),t<=16&&n<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:a}}(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=i,c=null!=s;l&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=i,[e%r==0,t%i==0,n%this.tileInner==0]}getUserCode(){return`\n      ${Wt(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${Ht(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?jt(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,t=!1){s.D5U.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${ct()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):Kt(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `}}class Yt{constructor(e,t=!1,n=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize);const s=null!=r,o=null!=a;s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=s,this.activation=i,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${Wt(this.activation,this.hasPreluActivationWeights)}\n      ${Ht(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${ct()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class Qt{constructor(e,t,n,r=!1,i=!1,a=null,s=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=a;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=s,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`\n      ${Wt(this.activation,this.hasPreluActivationWeights)}\n      ${Ht(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${ct()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class Zt{constructor(e,t,n=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,s.D5U.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=yt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=r,this.shaderKey=`matMulSplitK_${n}_${r}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1;return`\n      ${Gt(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${Mt(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${ot("&result[flatIndex + i]",e>1?"value[i]":"value","float32")}\n          }\n        }\n      }\n      ${this.isVec4?jt(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Kt(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class Jt{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_"+n}getUserCode(){return`\n    ${Wt(this.activation,this.hasPreluActivationWeights)}\n    ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${Vt(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class en{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${ct("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function tn(e){const{backend:t,attrs:n}=e,{shape:r,value:i}=n;let{dtype:a}=n;if(a=a||s.D5U.inferDtype(i),"string"===a){const e=s.D5U.getArrayFromDType(a,s.D5U.sizeFromShape(r));return e.fill(i),t.makeTensorInfo(r,a,e)}{const e=new en(r),n=[{type:"float32",data:[i]}];return t.runWebGPUProgram(e,[],a,n)}}const nn={kernelName:s.deh,backendName:"webgpu",kernelFunc:tn};function rn(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:i}=n,a=s.D5U.sizeFromShape(r.shape),o=s.D5U.inferFromImplicitShape(i,a),u=s.D5U.sizeFromShape(o);return s.D5U.assert(a===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const an={kernelName:s.HZH,backendName:"webgpu",kernelFunc:rn};function sn({a:e,b:t,transposeA:n,transposeB:r,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const c=e.shape.length,d=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],p=r?t.shape[d-1]:t.shape[d-2],f=n?e.shape[c-1]:e.shape[c-2],m=r?t.shape[d-2]:t.shape[d-1],g=e.shape.slice(0,-2),x=t.shape.slice(0,-2),b=s.D5U.sizeFromShape(g),y=s.D5U.sizeFromShape(x),w=s.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);s.D5U.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const v=n?[b,h,f]:[b,f,h],k=r?[y,m,p]:[y,p,m],C=rn({inputs:{x:e},backend:i,attrs:{shape:v}}),I=rn({inputs:{x:t},backend:i,attrs:{shape:k}}),S=[C,I],$=Math.max(b,y),R=[C,I],T=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[h]}];let A,E;const N=[$,f,m];let D=(0,s.OBj)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(D<0){const e=(0,s.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:i.thresholdToIncreaseWorkgroups,n=$*Math.ceil(f/32)*Math.ceil(m/32);D=n<=t||f<=8&&n<=2*t?$*f*m<=128?St.MatMulReduceProgram:1===$&&p>=2e3?St.MatMulSplitKProgram:St.MatMulSmallOutputSizeProgram:St.MatMulPackedProgram}switch(D){case St.MatMulReduceProgram:A=new Yt(N,n,r,a,l,o);break;case St.MatMulSplitKProgram:if(E=tn({backend:i,attrs:{shape:N,value:0,dtype:e.dtype}}),A=new Zt(N,p,n,r),a||l){E=i.runWebGPUProgram(A,R,e.dtype,T,E);const t=new Jt(E.shape,a,l,o);let n=null;const r=[E];a&&r.push(a),o&&r.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],t.uniforms+=" alpha : f32,");const s=i.runWebGPUProgram(t,r,E.dtype,n);S.push(E);const c=rn({inputs:{x:s},backend:i,attrs:{shape:w}});S.push(s);for(const e of S)i.disposeData(e.dataId);return c}break;case St.MatMulSmallOutputSizeProgram:A=new Qt(v,k,N,n,r,a,l,o);break;case St.MatMulPackedProgram:const t=i.adapterInfo.isIntel();A=new qt(v,N,n,r,a,l,o,t);break;default:throw new Error(`Unsupported MatMulProgramType ${D}.`)}a&&R.push(a),o&&R.push(o),"leakyrelu"===l&&(T.push({type:"float32",data:[u]}),A.uniforms+=" alpha : f32,"),E=i.runWebGPUProgram(A,R,e.dtype,T,E);const _=rn({inputs:{x:E},backend:i,attrs:{shape:w}});S.push(E);for(const e of S)i.disposeData(e.dataId);return _}const on={kernelName:s.usg,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a,bias:s,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return sn({a:i,b:a,transposeA:u,transposeB:l,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}};class un{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=s.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${Ot(this.op,!1)}\n      }\n\n      ${ct("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class ln{constructor(e,t,n){this.size=!0,this.variableNames=["A","B"],this.outputShape=s.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=kt(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(s.D5U.arraysEqual(t,n)&&s.D5U.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      let isNaN = false;\n      {\n        ${Ot(this.op,this.isVec4)}\n      }\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${ct("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${ct("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function cn(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const dn={kernelName:s.iJz,backendName:"webgpu",kernelFunc:cn};function hn(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.makeTensorInfo(r.shape,"complex64"),s=n.tensorMap.get(a.dataId),o=cn({inputs:{x:r},backend:n}),u=cn({inputs:{x:i},backend:n});return s.complexTensorInfos={real:o,imag:u},a}const pn={kernelName:s.Zz9,backendName:"webgpu",kernelFunc:hn};class fn{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_"+t}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${zt(this.op,!1)}\n      }\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function mn({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:i})=>{const{x:a}=r,s=i,o=n||a.dtype;if(s.shouldExecuteOnCPU([a])&&null!=t){const e=s.tensorMap.get(a.dataId),n=t(e.values,o);return s.makeTensorInfo(a.shape,o,n)}const u=new fn(a.shape,e);return s.runWebGPUProgram(u,[a],o)}}function gn({opType:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:i,backend:a})=>{const{a:o,b:u}=i,l=a;if(n&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(u.dataId);let r,i;if(e!==Tt.MUL)[r,i]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,i={dataId:n.dataId,dtype:n.dtype,shape:o.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},c=new ln(e,o.shape,u.shape);return l.runWebGPUProgram(c,[i,a],(0,s.x8V)(n.dtype,r.dtype))}));else{const e=new un(Tt.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),a=new un(Tt.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),s=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];r=l.runWebGPUProgram(e,s,"float32"),i=l.runWebGPUProgram(a,s,"float32")}const a=hn({inputs:{real:r,imag:i},backend:l});return l.disposeData(r.dataId),l.disposeData(i.dataId),a}const c=r||(0,s.x8V)(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,n=l.tensorMap.get(u.dataId).values,r="string"===o.dtype?s.backend_util.fromUint8ToStringArray(e):e,i="string"===o.dtype?s.backend_util.fromUint8ToStringArray(n):n,[a,d]=t(o.shape,u.shape,r,i,c);return l.makeTensorInfo(d,c,a)}const d=new ln(e,o.shape,u.shape);return l.runWebGPUProgram(d,[o,u],c)}}function xn(e){return(t,n,r,i,a)=>{const o=s.backend_util.assertAndGetBroadcastShape(t,n),u=o.length,l=s.D5U.computeStrides(o),c=s.D5U.sizeFromShape(o),d=s.D5U.getTypedArrayFromDType(a,c),h=t.length,p=n.length,f=s.D5U.computeStrides(t),m=s.D5U.computeStrides(n),g=s.backend_util.getBroadcastDims(t,o),x=s.backend_util.getBroadcastDims(n,o);if(g.length+x.length===0)for(let t=0;t<d.length;++t)d[t]=e(r[t%r.length],i[t%i.length]);else for(let t=0;t<d.length;++t){const n=s.D5U.indexToLoc(t,u,l),a=n.slice(-h);g.forEach((e=>a[e]=0));const o=s.D5U.locToIndex(a,h,f),c=n.slice(-p);x.forEach((e=>c[e]=0));const b=s.D5U.locToIndex(c,p,m);d[t]=e(r[o],i[b])}return[d,o]}}const bn=xn(((e,t)=>e+t));function yn(e){return(t,n,r)=>{const i=s.D5U.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)i[n]=e(t[n],r);return i}}const wn=yn((e=>Math.ceil(e))),vn=xn(((e,t)=>e===t?1:0)),kn=yn((e=>Math.exp(e))),Cn=yn((e=>Math.expm1(e))),In=yn((e=>Math.floor(e))),Sn=xn(((e,t)=>e>t?1:0)),$n=xn(((e,t)=>e>=t?1:0)),Rn=xn(((e,t)=>e<t?1:0)),Tn=xn(((e,t)=>e<=t?1:0)),An=yn((e=>Math.log(e))),En=xn(((e,t)=>Math.max(e,t))),Nn=xn(((e,t)=>Math.min(e,t))),Dn=xn(((e,t)=>e*t)),_n=xn(((e,t)=>e!==t?1:0));function Fn(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}var Pn=s.backend_util.RowPartitionType;class On{constructor(e,t,n,r,i,a,o,u,l,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=s.backend_util.getRowPartitionTypesHelper(c),this.raggedRank=s.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Pn.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Pn.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Pn.VALUE_ROWIDS:return On.getMaxWidthValueRowID(t);case Pn.ROW_SPLITS:return On.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type "+Pn[this.getRowPartitionTypeByDimension(e-1)])}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],i=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,i=Math.max(a-n,i),n=a)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Bn(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;s.backend_util.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=s.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),i=[];let a=0;for(let e=0;e<r;++e,a+=t)i.push(a);for(let t=r;t<e;++t)i.push(-1);return s.D5U.assert(i.length===e,(()=>"Final length of result must be equal to firstDimension.")),i}calculateOutputIndexRowSplit(e,t,n,r){const i=e.length,a=[];for(let s=0;s<i-1;++s){const i=e[s+1]-e[s];let o=Math.min(r,i),u=t[s];-1===u&&(o=0);for(let e=0;e<o;++e)a.push(u),u+=n;for(let e=0;e<i-o;++e)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const i=e.length,a=[];if(0===i)return[];let s=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];a.push(u);for(let l=1;l<i;++l){const i=e[l];if(i===o)u>=0&&(++s,s<r?u+=n:u=-1);else{if(s=0,o=i,i>=t.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);u=t[i]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Pn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case Pn.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw new Error("Unsupported partition type: "+Pn[a])}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Pn.FIRST_DIM_SIZE:return e[0];case Pn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Pn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+Pn[t])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=Bn(t,!1),i=s.D5U.getArrayFromDType(this.valuesDType,s.D5U.sizeFromShape(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)a=this.calculateOutputIndex(e-1,a,n[e],t[e]);this.setOutput(this.raggedRank,a,i,r)}return[r,i]}setOutput(e,t,n,r){if(0===n.length)return;const i=this.values,a=n;let o=r.slice();o=o.slice(e+1);const u=s.D5U.sizeFromShape(o),l=t.length;let c=this.defaultValue;if(c.length!==u&&1!==c.length){const e=this.defaultValueShape;(0,s.lub)((()=>{const t=(0,s.XLQ)(c,e),n=(0,s.UFq)(t,o);c=n.dataSync()}))}let d=0,h=0,p=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==p){if(h<p){const e=i.subarray(d*u);Un(a.subarray(h*u),e,(p-h)*u)}if(e>=l){const e=n.length;r=Math.floor(e/u)}if(r>p)if(1===this.defaultValue.length)a.subarray(p*u,r*u).fill(this.defaultValue[0]),p=r;else for(;r>p;)Un(a.slice(p*u),c,u),++p;r<0?(d=e+1,h=p):(d=e,h=p,p=h+1)}else++p}}}function Un(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Bn(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const Ln=yn((e=>1/Math.sqrt(e))),zn=yn((e=>1/(1+Math.exp(-e)))),Mn=yn((e=>Math.sqrt(e))),Wn=xn(((e,t)=>{const n=e-t;return n*n}));class Vn{constructor(e,t,n,r,i,a){this.separator=s.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=s.D5U.encodeString(n),this.rightPad=s.D5U.encodeString(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,a){for(let s=0;s<i;++s){const o=this.getPadWidth(a),u=Math.max(0,o-s),l=Math.max(0,o-(i-(s+1))),c=a-(u+l),d=t+(u>0?0:s-o);let h=0;h+=u*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=l*this.rightPad.length,h+=(u+l+c-1)*this.separator.length,n[r+s]=new Uint8Array(h);const p=n[r+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got "+e);for(let i=1;i<r;++i){let r=t[i]>=e;if(r=r&&t[i]<=n,!r)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const i=r-1,a=s.D5U.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=i;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=i;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const o=new Array(a[i]);for(let n=0;n<i;++n){const r=t[n];let i=a[n];if(this.nGramWidths.forEach((a=>{const s=t[n+1]-t[n],u=this.getNumNGrams(s,a);this.createNGrams(e,r,o,i,u,a),i+=u})),this.preserveShort&&i===a[n]){const a=t[n+1]-t[n];if(0===a)continue;const s=a+2*this.padWidth,u=1;this.createNGrams(e,r,o,i,u,s)}}return[o,a]}}function Gn(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let a=e.indexOf(i);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(i,a);n&&0===t.length||r.push(t),i=a+1}}const Hn=xn(((e,t)=>e-t)),jn=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Xn(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,a=t-n+1,s=Math.log(i),o=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*o*(i-o)/i)*Math.sign(a-i/2);Xn(e,t,Math.max(n,Math.floor(t-a*o/i+u)),Math.min(r,Math.floor(t+(i-a)*o/i+u)))}const i=e[t];let a=n,o=r;for(s.D5U.swap(e,n,t),jn(e[r],i)>0&&s.D5U.swap(e,n,r);a<o;){for(s.D5U.swap(e,a,o),a++,o--;jn(e[a],i)<0;)a+=1;for(;jn(e[o],i)>0;)o-=1}0===jn(e[n],i)?s.D5U.swap(e,n,o):(o+=1,s.D5U.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}var Kn=Object.freeze({__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:bn,bincountImpl:function(e,t,n,r,i){const a=s.D5U.sizeFromShape(r),o=s.D5U.makeZerosTypedArray(i,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=i||(o[r]+=a>0?t[n]:1)}return o},bincountReduceImpl:function(e,t,n,r=!1){const i=e.shape[0],a=e.shape[1],o=(0,s.f3b)([i,n],t.dtype);for(let s=0;s<i;s++)for(let i=0;i<a;i++){const a=e.get(s,i);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?o.set(1,s,a):t.size>0?o.set(o.get(s,a)+t.get(s,i),s,a):o.set(o.get(s,a)+1,s,a))}return o},castImpl:function(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=s.D5U.toTypedArray([0],n),[i,a]=xn(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)},ceilImpl:wn,concatImpl:function(e,t,n,r){const i=s.D5U.getArrayFromDType(n,s.D5U.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=s.D5U.sizeFromShape(e.shape);i.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?s.backend_util.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)i[s+t]=a[o++]}r+=e.shape[1]}))}return i},equalImpl:vn,expImpl:kn,expm1Impl:Cn,floorImpl:In,gatherNdImpl:function(e,t,n,r,i,a,o,u,l){const c=(0,s.f3b)([r,a],n);for(let n=0;n<r;n++){const r=[];let s=0;for(let t=0;t<i;t++){const a=e[n*i+t];s+=a*o[t],r.push(a)}if(s<0||s>=l/a)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<a;e++)c.values[n*a+e]=t.get(...t.indexToLoc(s*a+e))}return c},gatherV2Impl:function(e,t,n){const r=(0,s.f3b)(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),a=i[0],s=i[2],o=t.locToIndex([a,s]);i[2]=t.values[o];const u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r},greaterImpl:Sn,greaterEqualImpl:$n,lessImpl:Rn,lessEqualImpl:Tn,linSpaceImpl:function(e,t,n){const r=(t-e)/(n-1),i=s.D5U.makeZerosTypedArray(n,"float32");i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+r;return i},logImpl:An,maxImpl:function(e,t,n,r){const i=s.D5U.getTypedArrayFromDType(r,s.D5U.sizeFromShape(n));for(let n=0;n<i.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}i[n]=a}return i},maximumImpl:En,minimumImpl:Nn,multiplyImpl:Dn,negImpl:function(e,t,n){const r=s.D5U.createScalarValue(-1,n);return Dn([],t,r,e,n)},notEqualImpl:_n,prodImpl:function(e,t,n,r){const[i,a]=s.backend_util.computeOutAndReduceShapes(e,r),o=(0,s.x8V)(t,"int32"),u=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(i),o),l=s.D5U.sizeFromShape(a);for(let e=0;e<u.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];u[e]=r}return{outVals:u,outShape:i,outDtype:o}},raggedGatherImpl:function(e,t,n,r,i,a,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const i=s.D5U.indexToLoc(r,t.length,s.D5U.computeStrides(t)).join(",");throw new Error(`indices[${i}] = ${e} is not in [0, ${n})`)}}))}(a,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:d,numValues:h}=function(e,t,n,r){const i=[];let a=0;const s=t.length-1+n.length,o=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let s=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=o[i],t=e[e.length-1]-r[s];for(let e=s;e<u;++e)o[i].push(r[e+1]+t)}s=r[s],u=r[u]}u!==s&&(i.push([s,u]),a+=u-s)}return{outSplits:o,valueSlices:i,numValues:a}}(a,o,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,i=s.D5U.getArrayFromDType("int32",r);t.push(i),e[n].forEach(((e,t)=>i[t]=e))}return t}(c),f=function(e,t,n,r,i){const a=t.slice();a[0]=i;const o=s.D5U.getArrayFromDType(n,s.D5U.sizeFromShape(a)),u=e.length;return function(e,t,n,r,i,a){const s=Fn(t,2)[1],o=Fn(a,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[u*o+t]=e[n*s+t];++u}}(e,t,r,0===u?0:u/t[0],o,a),[o,a]}(n,r,i,d,h);return[p,f[0],f[1]]},raggedRangeImpl:function(e,t,n,r,i,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,l=0===i.length,c=0===o.length,d=[];u||d.push(t[0]),l||d.push(i[0]),c||d.push(o[0]);for(let e=1;e<d.length;++e)if(d[e]!==d[e-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===d.length?1:d[0],p=s.D5U.getArrayFromDType("int32",h+1);p[0]=0;for(let t=0;t<h;++t){const n=u?e[0]:e[t],i=l?r[0]:r[t],s=c?a[0]:a[t];if(0===s)throw new Error("Requires delta != 0");let o;if(s>0&&i<n||s<0&&i>n)o=0;else if(o=Math.ceil(Math.abs((i-n)/s)),o>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");p[t+1]=p[t]+o}const f=p[h],m=s.D5U.getArrayFromDType(n,f);let g=0;for(let t=0;t<h;++t){const n=p[t+1]-p[t];let r=u?e[0]:e[t];const i=c?a[0]:a[t];for(let e=0;e<n;++e)m[g++]=r,r+=i}return[p,m]},raggedTensorToTensorImpl:function(e,t,n,r,i,a,s,o,u,l){return new On(e,t,n,r,i,a,s,o,u,l).compute()},rangeImpl:function(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return s.D5U.makeZerosTypedArray(0,r);const i=Math.abs(Math.ceil((t-e)/n)),a=s.D5U.makeZerosTypedArray(i,r);t<e&&1===n&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a},rsqrtImpl:Ln,scatterImpl:function(e,t,n,r,i,a,o,u,l,c){const d=[r/i,i],h=e.values,p=t.values;if(0===r)return(0,s.f3b)(n,t.dtype);const f=(0,s.f3b)(d,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<a;e++){const a=[];let s=0;for(let t=0;t<o;t++){const n=h[e*o+t];a.push(n),s+=n*u[t]}if(s<0||s>=r/i)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<i;n++)c?f.values[s*i+n]+=p[e*i+n]:f.values[s*i+n]=0===t.rank?p[0]:p[e*i+n]}return f},sigmoidImpl:zn,sliceImpl:function(e,t,n,r,i){const a=s.kuN.isSliceContinous(r,t,n),o=s.D5U.sizeFromShape(n),u=s.D5U.computeStrides(r);if(a){const n=s.kuN.computeFlatOffset(t,u);return"string"===i?e.slice(n,n+o):e.subarray(n,n+o)}const l="string"===i?s.backend_util.fromUint8ToStringArray(e):e,c=(0,s.f3b)(r,i,l),d=(0,s.f3b)(n,i);for(let e=0;e<d.size;++e){const n=d.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));d.set(c.get(...r),...n)}return"string"===i?s.backend_util.fromStringArrayToUint8(d.values):d.values},sparseFillEmptyRowsImpl:function(e,t,n,r,i,a,o){const u=t[0],l=a[0],c=new Array(l),d=new Array(u),h=t[1];if(0===l){if(0!==u)throw new Error(s.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[s.D5U.getArrayFromDType(n,0),[0,h],s.D5U.getArrayFromDType(i,0),c,d]}let p=!0,f=0;const m=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*h];if(n<0)throw new Error(s.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(s.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++m[n],p=p&&n>=f,f=n}let g=!0;for(let e=0;e<l;++e){const t=0===m[e];c[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=r;for(let e=0;e<u;++e)d[e]=e;return[t,[u,h],n,c,d]}{const t=m[l-1],a=s.D5U.getArrayFromDType(n,t*h),p=s.D5U.getArrayFromDType(i,t),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*h],i=f[n],s=(0===n?0:m[n-1])+i;f[n]++;for(let n=0;n<h;++n)a[s*h+n]=e[t*h+n];p[s]=r[t],d[t]=s}for(let e=0;e<l;++e)if(0===f[e]){const t=0===e?0:m[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;p[t]=o}return[a,[t,h],p,c,d]}},sparseReshapeImpl:function(e,t,n,r,i){const a=s.D5U.sizeFromShape(r),o=t[0],u=i.length,l=[];let c=1,d=-1;for(let e=0;e<u;++e){const t=i[e];if(-1===t){if(-1!==d)throw new Error(s.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,e));d=e,l.push(1)}else{if(t<0)throw new Error(s.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,t));c*=t,l.push(t)}}if(-1!==d){if(c<=0)throw new Error(s.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(a/c);if(c*e!==a)throw new Error(s.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[d]=e}if(s.D5U.sizeFromShape(l)!==a)throw new Error(s.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let e=h-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=s.D5U.getArrayFromDType(n,o*u);for(let t=0;t<o;++t){let n=0;for(let r=0;r<h;++r)n+=e[t*h+r]*p[r];for(let e=0;e<u;++e)m[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[o,u],l]},sparseSegmentReductionImpl:function(e,t,n,r,i,a=!1,o=0){const u=r.length,l=[t[0],e.length/t[0]],c=l[1],d=u>0?i[u-1]+1:0;if(d<0)throw new Error(s.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=d;const p=h.reduce(((e,t)=>e*t),1),f=s.D5U.getArrayFromDType(n,p);if(0===u)return d>0&&f.fill(o),[f,h];if(d<=0)throw new Error(s.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,x=0,b=i[m];for(;;){let t=0;if(g<u){if(t=i[g],b===t){++g;continue}if(b>=t)throw new Error(s.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=d)throw new Error(s.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,d));b>x&&f.fill(o,x*c,b*c);for(let t=m;t<g;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(s.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<c;t++)f[b*c+t]+=e[n*c+t]}if(a)for(let e=0;e<c;e++)f[b*c+e]/=g-m;if(m=g,++g,x=b+1,b=t,g>u)break}return x<d&&f.fill(o,x*c,d*c),[f,h]},sqrtImpl:Mn,squaredDifferenceImpl:Wn,stridedSliceImpl:function(e,t,n,r){const i=(0,s.f3b)(e,t.dtype);for(let e=0;e<i.size;e++){const a=i.indexToLoc(e),s=new Array(a.length);for(let e=0;e<s.length;e++)s[e]=a[e]*n[e]+r[e];i.set(t.get(...s),...a)}return i},stringNGramsImpl:function(e,t,n,r,i,a,s,o){return new Vn(n,r,i,a,s,o).compute(e,t)},stringSplitImpl:function(e,t,n){const r=e.length,i=[];let a=0,o=0;const u=new Array(r);for(let s=0;s<r;++s){const r=i.length;Gn(e[s],t,n,i);const l=i.length-r;u[s]=l,a+=l,o=Math.max(o,l)}const l=s.D5U.getArrayFromDType("int32",2*a),c=new Array(a),d=[r,o];let h=0;for(let e=0;e<r;++e)for(let t=0;t<u[e];++t)l[2*h]=e,l[2*h+1]=t,c[h]=i[h],++h;return[l,c,d]},stringToHashBucketFastImpl:function(e,t){const n=s.D5U.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=s.D5U.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n},subImpl:Hn,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=(0,s.f3b)(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const a=e.locToIndex(i);r.values[t]=e.values[a]}return r},topKImpl:function(e,t,n,r,i){const a=t[t.length-1],[o,u]=[e.length/a,a],l=s.D5U.getTypedArrayFromDType(n,o*r),c=s.D5U.getTypedArrayFromDType("int32",o*r);for(let t=0;t<o;t++){const n=t*u,a=e.subarray(n,n+u);let s=new Array(a.length);a.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(Xn(s,r),s=s.slice(0,r)),i&&s.sort(jn);const o=t*r,d=l.subarray(o,o+r),h=c.subarray(o,o+r);for(let e=0;e<r;e++)d[e]=s[e].value,h[e]=s[e].index}const d=t.slice();return d[d.length-1]=r,[(0,s.f3b)(d,n,l),(0,s.f3b)(d,"int32",c)]},transposeImpl:function(e,t,n,r,i){const a=t.length,o=s.D5U.sizeFromShape(t),u=s.D5U.computeStrides(t),l=s.D5U.computeStrides(i),c=s.D5U.getTypedArrayFromDType(n,s.D5U.sizeFromShape(i));for(let t=0;t<o;++t){const n=s.D5U.indexToLoc(t,a,u),i=new Array(n.length);for(let e=0;e<i.length;e++)i[e]=n[r[e]];c[s.D5U.locToIndex(i,a,l)]=e[t]}return c},uniqueImpl:function(e,t,n,r){const i=s.D5U.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let e=0;e<i;e++)a[0]*=n[e];a[1]=n[i];for(let e=i+1;e<n.length;e++)a[2]*=n[e];const o={},u=new Int32Array(n[i]),l=new s.YDk(a,r,e),c=[],d=1===a[0]&&1===a[2];for(let t=0;t<n[i];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==o[n])u[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,u[t]=e,c.push(t)}}const h=a.slice();h[1]=Object.keys(o).length;const p=new s.YDk(h,r);c.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[i]=h[1],{outputValues:p.values,outputShape:f,indices:u}}});const{addImpl:qn,castImpl:Yn,ceilImpl:Qn,concatImpl:Zn,equalImpl:Jn,expImpl:er,expm1Impl:tr,floorImpl:nr,gatherNdImpl:rr,gatherV2Impl:ir,greaterEqualImpl:ar,greaterImpl:sr,lessEqualImpl:or,lessImpl:ur,logImpl:lr,maxImpl:cr,maximumImpl:dr,minimumImpl:hr,multiplyImpl:pr,negImpl:fr,notEqualImpl:mr,prodImpl:gr,rangeImpl:xr,rsqrtImpl:br,scatterImpl:yr,simpleAbsImpl:wr,sliceImpl:vr,stridedSliceImpl:kr,stringNGramsImpl:Cr,subImpl:Ir,tileImpl:Sr,topKImpl:$r,transposeImpl:Rr,uniqueImpl:Tr}=Kn,Ar={kernelName:s.SYM,backendName:"webgpu",kernelFunc:mn({opType:Ut.ABS,cpuKernelImpl:wr})},Er={kernelName:s.VGw,backendName:"webgpu",kernelFunc:mn({opType:Ut.ACOS})},Nr={kernelName:s.SpW,backendName:"webgpu",kernelFunc:mn({opType:Ut.ACOSH})},Dr={kernelName:s.mm_,backendName:"webgpu",kernelFunc:gn({opType:Tt.ADD,cpuKernelImpl:qn,supportsComplex:!0})};class _r{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>"T"+t)),this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>"v"+e)).join(" + ");return`\n      ${ct("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const Fr={kernelName:s.Xze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return cn({inputs:{x:r[0]},backend:n});const i=r.map((e=>e.dtype)).reduce(((e,t)=>(0,s.x8V)(e,t))),a=r.map((e=>e.shape)),o=new _r(a);return n.runWebGPUProgram(o,r,i)}};class Pr{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){s.D5U.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${ct()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Or{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_"+t}getUserCode(){const e=ut(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]="resRC."+lt(t);return n.join()}(this.newDim);return`\n      ${ct("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Ur(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{perm:a}=r,o=n,u=i.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=i.shape[a[e]];if(n.shouldExecuteOnCPU([i])){const e=o.tensorMap.get(i.dataId).values,t=Rr(e,i.shape,i.dtype,a,l);return n.makeTensorInfo(l,i.dtype,t)}if(2===i.shape.length&&s.D5U.arraysEqual(a,[1,0])){const e=new Pr(i.shape,a);return o.runWebGPUProgram(e,[i],i.dtype)}const c=new Or(i.shape,a);return o.runWebGPUProgram(c,[i],i.dtype)}const Br={kernelName:s.G3Y,backendName:"webgpu",kernelFunc:Ur};class Lr{constructor(e,t){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[n]=s.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===n.length?[1]:n,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_"+t}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       \n         var<workgroup> xBestValues : array<f32, ${n}>;\n       \n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${ct("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}function zr(e,t,n,r,i){const a=e.shape.length,o=[],u=s.D5U.parseAxisParam(t,e.shape);let l=u;const c=s.backend_util.getAxesPermutation(l,a);let d=e;null!=c&&(d=Ur({inputs:{x:e},attrs:{perm:c},backend:i}),l=s.backend_util.getInnerMostAxes(l.length,a),o.push(d)),s.backend_util.assertAxesAreInnerMostDims(r,l,a);const[h,p]=s.backend_util.computeOutAndReduceShapes(d.shape,l);let f,m=h;if(n&&(m=s.backend_util.expandShapeToKeepDim(h,u)),"max"!==r&&"prod"!==r||!i.shouldExecuteOnCPU([d])){const t=s.D5U.sizeFromShape(p),n={windowSize:t,inSize:t,batchSize:s.D5U.sizeFromShape(d.shape)/t,outSize:1},a="mean"===r?"float32":(0,s.z4k)(e.dtype),u=[{type:"int32",data:[t]}],l=new Lr(n,r),c=i.runWebGPUProgram(l,[d],a,u);o.push(c),f=rn({inputs:{x:c},attrs:{shape:m},backend:i})}else{const t=i.tensorMap.get(d.dataId).values;switch(r){case"max":const n=cr(t,s.D5U.sizeFromShape(p),m,e.dtype);f=i.makeTensorInfo(m,e.dtype,n);break;case"prod":const{outVals:a,outShape:o,outDtype:u}=gr(d.shape,d.dtype,t,l);f=i.makeTensorInfo(o,u,a);break;default:throw new Error(r+" CPU implementation is not yet supported.")}}return o.forEach((e=>i.disposeData(e.dataId))),f}const Mr={kernelName:s.oT6,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return zr(i,s,a,"all",n)}},Wr={kernelName:s.IKK,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return zr(i,s,a,"any",n)}};class Vr{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op="min"===n?"<":">";const[i,a]=s.backend_util.computeOutAndReduceShapes(e,r);this.outputShape=0===i.length?[1]:i,this.dispatchLayout=kt(this.outputShape),s.D5U.sizeFromShape(a)<32||s.D5U.sizeFromShape(i)>1e3?(this.type="plain",this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=yt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":"uniforms.xShape."+lt(this.inputShape.length-1),n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${lt(t)},`;return e};return"shared"===this.type?`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      \n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    \n\n      ${ct("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `:`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const Gr={kernelName:s.sJF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r;let o=s.D5U.parseAxisParam(a,i.shape);const u=s.backend_util.getAxesPermutation(o,i.shape.length);let l=i;const c=[];null!=u&&(l=Ur({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=s.backend_util.getInnerMostAxes(o.length,l.shape.length)),s.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const d=new Vr(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",h);return c.forEach((e=>n.disposeData(e.dataId))),p}},Hr={kernelName:s.aJk,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r;let o=s.D5U.parseAxisParam(a,i.shape);const u=s.backend_util.getAxesPermutation(o,i.shape.length);let l=i;const c=[];null!=u&&(l=Ur({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=s.backend_util.getInnerMostAxes(o.length,l.shape.length)),s.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const d=new Vr(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",h);return c.forEach((e=>n.disposeData(e.dataId))),p}},jr={kernelName:s.M2y,backendName:"webgpu",kernelFunc:mn({opType:Ut.ASIN})},Xr={kernelName:s.qw7,backendName:"webgpu",kernelFunc:mn({opType:Ut.ASINH})},Kr={kernelName:s.jMg,backendName:"webgpu",kernelFunc:mn({opType:Ut.ATAN})},qr={kernelName:s.QCc,backendName:"webgpu",kernelFunc:gn({opType:Tt.ATAN2})},Yr={kernelName:s.Oyi,backendName:"webgpu",kernelFunc:mn({opType:Ut.ATANH})};class Qr{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="pool2D_"+t,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return"avg"===this.poolType&&(t="resultValue / max(count, 1.0)"),`\n      ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class Zr{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}function Jr(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:a,keepDims:s}=r;return zr(i,a,s,"max",n)}const ei={kernelName:s.YoZ,backendName:"webgpu",kernelFunc:Jr};function ti(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return zr(i,s,a,"mean",n)}const ni={kernelName:s.q2K,backendName:"webgpu",kernelFunc:ti};function ri(e,t,n,r){if(1===t.filterWidth&&1===t.filterHeight&&s.D5U.arraysEqual(t.inShape,t.outShape))return cn({inputs:{x:e},backend:r});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const i=e.shape.length,a=rn({inputs:{x:e},backend:r,attrs:{shape:[e.shape[i-3]*e.shape[i-2],e.shape[i-1]]}});let o;"avg"===n?o=ti({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(s.D5U.assert("max"===n,(()=>"Invalid pool type "+n)),o=Jr({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const u=rn({inputs:{x:o},backend:r,attrs:{shape:t.outShape}});return r.disposeData(a.dataId),r.disposeData(o.dataId),u}let i;const a=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?i=new Zr(t):("avg"===n?i=new Qr(t,"avg"):(s.D5U.assert("max"===n,(()=>"Invalid pool type "+n)),i=new Qr(t,"max")),a.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),r.runWebGPUProgram(i,[e],e.dtype,a)}const ii={kernelName:s.JhU,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=r;return ri(i,s.backend_util.computePool2DInfo(i.shape,a,o,1,u,l),"avg",n)}};class ai{constructor(e){this.variableNames=["dy"],this.uniforms="stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}getUserCode(){return`\n      ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const si={kernelName:s.ROF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,o=a;var u;u=[i,a],Array.isArray(u)||(u=[u]),u.forEach((e=>{null!=e&&s.D5U.assert("complex64"!==e.dtype,(()=>"avgPoolGrad does not support complex64 tensors in the WebGPU backend."))}));const{filterSize:l,strides:c,pad:d}=r,h=s.backend_util.computePool2DInfo(o.shape,l,c,1,d),p=new ai(h),f=1/(h.filterHeight*h.filterWidth),m=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return n.runWebGPUProgram(p,[i],o.dtype,m)}},oi={kernelName:s.XLW,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a}=t,{transposeA:s,transposeB:o}=r;return sn({a:i,b:a,transposeA:s,transposeB:o,backend:n})}};class ui{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${ut(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=ut(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return li.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;return n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${li[t]} = uniforms.start.${lt(t)} + coords.${li[t]};`)),`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const li=["x","y","z","w","u","v"];function ci(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,size:o}=r,[u,l]=s.kuN.parseSliceParams(i,a,o);if(s.kuN.assertParamsValid(i,u,l),n.shouldExecuteOnCPU([i])||"string"===i.dtype){const e=n.tensorMap.get(i.dataId),t=vr(e.values,u,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,t)}if(0===s.D5U.sizeFromShape(l))return n.makeTensorInfo(l,i.dtype,[]);const c=new ui(u,l),d=[{type:"int32",data:u}];return n.runWebGPUProgram(c,[i],i.dtype,d)}const di={kernelName:s.p2w,backendName:"webgpu",kernelFunc:ci},hi={kernelName:s.zws,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,crops:o}=r;s.D5U.assert(i.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const u=a.reduce(((e,t)=>e*t)),l=s.backend_util.getReshaped(i.shape,a,u),c=s.backend_util.getPermuted(l.length,a.length),d=s.backend_util.getReshapedPermuted(i.shape,a,u),h=s.backend_util.getSliceBeginCoords(o,a.length),p=s.backend_util.getSliceSize(d,o,a.length),f=[],m=rn({inputs:{x:i},backend:n,attrs:{shape:l}}),g=Ur({inputs:{x:m},backend:n,attrs:{perm:c}}),x=rn({inputs:{x:g},backend:n,attrs:{shape:d}}),b=ci({inputs:{x},backend:n,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(x),f.forEach((e=>n.disposeData(e.dataId))),b}},pi=`\n  fn bincount_write(index: i32, value: f32) {\n    ${ot("&result[index]","value","float32")}\n  }\n`;class fi{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":pi}\n  ${ct("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const mi={kernelName:s.zvY,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o}=r,u=s.D5U.sizeFromShape(i.shape),l=s.D5U.sizeFromShape(a.shape)>0,c=[o],d=a.dtype,h=tn({backend:n,attrs:{shape:c,value:0,dtype:d}}),p=new fi([u],l),f=[{type:"int32",data:[o]}],m=l?[i,a]:[i];return n.runWebGPUProgram(p,m,d,f,h)}},gi=gn({opType:Tt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:mr}),xi={kernelName:s.yQU,backendName:"webgpu",kernelFunc:gi};function bi(e){const{inputs:t,backend:n}=e,{input:r}=t;return cn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const yi={kernelName:s.xJR,backendName:"webgpu",kernelFunc:bi},wi={kernelName:s.RFZ,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:i}=t,{x:a}=n,{dtype:o}=i;if("complex64"===o){if("complex64"===a.dtype)return cn({inputs:{x:a},backend:r});const t=(0,s.lls)(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),i=hn({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeData(n.dataId),i}if("complex64"===a.dtype){const t=bi({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeData(t.dataId),n}if(!s.D5U.hasEncodingLoss(a.dtype,o)){const e=cn({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([a])){const e=r.tensorMap.get(a.dataId).values,[t,n,i]=Yn(e,a.shape,a.dtype,o);return r.makeTensorInfo(t,n,i)}if("int32"===o)return function(e,t){const n=new fn(e.shape,Ut.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",s.D5U.getTypedArrayFromDType("bool",1)),t=gi({inputs:{a,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${o}`)}},vi={kernelName:s.gJX,backendName:"webgpu",kernelFunc:mn({opType:Ut.CEIL,cpuKernelImpl:Qn})};class ki{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${ct("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class Ci{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${ct("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const Ii={kernelName:s.xnO,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{clipValueMin:a,clipValueMax:o}=r;let u;const l=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return u=s.D5U.sizeFromShape(i.shape)%4==0?new ki(i.shape):new Ci(i.shape),n.runWebGPUProgram(u,[i],i.dtype,l)}};class Si{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>"T"+t)),this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${ct("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function $i(e){const{inputs:t,backend:n}=e,{input:r}=t;return cn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const Ri={kernelName:s.J_u,backendName:"webgpu",kernelFunc:$i};function Ti(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>bi({inputs:{input:e},backend:n}))),i=e.map((e=>$i({inputs:{input:e},backend:n}))),a=Ti(r,t,n),s=Ti(i,t,n),o=hn({inputs:{real:a,imag:s},backend:n});return r.forEach((e=>n.disposeData(e.dataId))),i.forEach((e=>n.disposeData(e.dataId))),n.disposeData(a.dataId),n.disposeData(s.dataId),o}let i=n.shouldExecuteOnCPU(e);if("string"===r&&(i=!0),i){const i=e.map((e=>{const r=s.D5U.sizeFromShape(e.shape.slice(t));return rn({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=i.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=s.backend_util.computeOutShape(i.map((e=>e.shape)),1),u=1===i[0].shape[0],l=Zn(a,o,r,u),c=s.backend_util.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(c,r,l);return i.forEach((e=>n.disposeData(e.dataId))),d}const a=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>a){const r=[];for(let i=0;i<e.length;i+=a){const s=e.slice(i,i+a);r.push(Ti(s,t,n))}const i=Ti(r,t,n);for(const e of r)n.disposeData(e.dataId);return i}const{tensors2D:o,outShape:u}=function(e,t,n){const r=s.backend_util.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>rn({inputs:{x:e},backend:n,attrs:{shape:[s.D5U.sizeFromShape(e.shape.slice(0,t)),s.D5U.sizeFromShape(e.shape.slice(t))]}}))),outShape:r}}(e,t,n),l=o.map((e=>e.shape)),c=new Si(l),d=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],d.push({type:"int32",data:[h[0]]});for(let e=1;e<h.length;e++)h[e]=h[e-1]+l[e][1],d.push({type:"int32",data:[h[e]]})}const p=n.runWebGPUProgram(c,o,o[0].dtype,d);o.forEach((e=>n.disposeData(e.dataId)));const f=rn({inputs:{x:p},backend:n,attrs:{shape:u}});return n.disposeData(p.dataId),f}function Ai(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r,a=s.D5U.parseAxisParam(i,t[0].shape)[0],o=t.map((e=>e.shape));s.backend_util.assertParamsConsistent(o,a);const u=s.backend_util.computeOutShape(t.map((e=>e.shape)),a);if(0===s.D5U.sizeFromShape(u))return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter((e=>s.D5U.sizeFromShape(e.shape)>0));return 1===l.length?cn({inputs:{x:l[0]},backend:n}):Ti(l,a,n)}const Ei={kernelName:s.Eh3,backendName:"webgpu",kernelFunc:Ai};class Ni{constructor(e,t,n,r,i=!1,a=null,s=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=wt(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vt(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),i&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),s&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=s,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?jt(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Kt(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,i=!1,a=null,s=!1,o=4,u=4,l=4){const c=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",d=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",h=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${Mt(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${h} && xCol >= 0 && xCol < ${p}) {\n        ${c}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,x=e?t&&r?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${Mt(o)}(0.0);`:r&&n?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${Mt(o)}(0.0);`,b=""+(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u),y=Mt(l),w=Mt(e?o:u),v=Mt(e?u:o);return`\n      ${Wt(a,s,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {\n        ${e?x:b}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n        ${e?b:x}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${y}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${d}\n        ${Vt(i,a)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class Di{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${Wt(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${Vt(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${ct("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class _i{constructor(e,t){this.variableNames=["x"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${ct("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];\n        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -\n              uniforms.pad[1];\n          let xCol = offsetX + uniforms.dilation[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${i};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function Fi(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Pi({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const l=null!=i,c=null!=a,d="channelsLast"===n.dataFormat,h=d&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type,p=(0,s.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(h||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:s=0,activation:o=null}){const u="channelsLast"===n.dataFormat,l=!u,c=[];let d,h;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const i=n.inHeight*n.inWidth*n.inChannels;d=rn({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,i]}}),h=rn({inputs:{x:t},backend:r,attrs:{shape:[1,i,n.outChannels]}})}else d=rn({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),h=rn({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(c.push(d),c.push(h),null!=a){const e=Fi(a.shape,u);null!=e&&(a=rn({inputs:{x:a},backend:r,attrs:{shape:e}}),c.push(a))}if(null!=i){const e=Fi(i.shape,u);null!=e&&(i=rn({inputs:{x:i},backend:r,attrs:{shape:e}}),c.push(i))}const p=sn({a:u?d:h,b:u?h:d,transposeA:l,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:s}),f=rn({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});c.push(p);for(const e of c)r.disposeData(e.dataId);return f}({x:e,filter:t,convInfo:n,backend:r,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o});const f=(0,s.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>0?f:r.thresholdToIncreaseWorkgroups,g=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if((0,s.OBj)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:s=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:d,strideHeight:h,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:x,dataFormat:b}=n,y="channelsLast"===b,w=u*l*c,v=m*f,k=y?[n.batchSize,v,w]:[n.batchSize,w,v],C=new _i(k,y),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[h,d]},{type:"int32",data:[x,g]},{type:"int32",data:[f]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],S=r.runWebGPUProgram(C,[e],e.dtype,I),$=[];$.push(S);const R=rn({inputs:{x:t},backend:r,attrs:{shape:[1,w,-1]}});if($.push(R),null!=a){const e=Fi(a.shape,y);null!=e&&(a=rn({inputs:{x:a},backend:r,attrs:{shape:e}}),$.push(a))}if(null!=i){const e=Fi(i.shape,y);null!=e&&(i=rn({inputs:{x:i},backend:r,attrs:{shape:e}}),$.push(i))}const T=sn({a:y?S:R,b:y?R:S,transposeA:!y,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:s}),A=rn({inputs:{x:T},backend:r,attrs:{shape:n.outShape}});$.push(T);for(const e of $)r.disposeData(e.dataId);return A}({x:e,filter:t,convInfo:n,backend:r,bias:i,preluActivationWeights:a,leakyreluAlpha:o,activation:u});let x;const b=[n.padInfo.top,n.padInfo.left],y=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(p)x=new Di(n,l,u,c);else{const e=d?n.outHeight*n.outWidth:n.outChannels,t=d?n.outChannels:n.outHeight*n.outWidth,i=n.filterHeight*n.filterWidth*n.inChannels;y.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[i]});const a=r.adapterInfo.isIntel();x=new Ni(n,e,t,i,l,u,c,a)}const w=[],v=[e,t];l&&(d||1!==i.shape.length||(i=rn({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),w.push(i)),v.push(i)),c&&(d||1!==a.shape.length||(a=rn({inputs:{x:a},backend:r,attrs:{shape:[a.shape[0],1,1]}}),w.push(a)),v.push(a)),"leakyrelu"===u&&(y.push({type:"float32",data:[o]}),x.uniforms+=" alpha : f32,");const k=r.runWebGPUProgram(x,v,e.dtype,y);for(const e of w)r.disposeData(e.dataId);return k}const Oi={kernelName:s.mhS,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=n,h=s.backend_util.convertConv2DDataFormat(l);return Pi({x:i,filter:a,convInfo:s.backend_util.computeConv2DInfo(i.shape,a.shape,o,c,u,d,!1,h),backend:r})}};class Ui{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${ct("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Bi{constructor(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_"+this.isChannelsLast}getUserCode(){return`\n    ${ct("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Li={kernelName:s.wUP,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,h=s.backend_util.convertConv2DDataFormat(l),p=s.backend_util.computeConv2DInfo(i.shape,d,o,1,u,c,!1,h),f=new Bi(p),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return n.runWebGPUProgram(f,[i,a],i.dtype,m)}};class zi{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,s.D5U.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=wt(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vt(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?jt(this.elementsPerThread,this.workgroupSize):Kt(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${Mt(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${Mt(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${Mt(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Mt(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Mt(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${Mt(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${Mt(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const Mi={kernelName:s.wm,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:d}=r,h=s.backend_util.convertConv2DDataFormat(c),p=s.backend_util.computeConv2DInfo(o,a.shape,u,1,l,d,!1,h),f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if((0,s.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.filterHeight<=2&&p.filterWidth<=2&&p.outChannels<=16&&1===p.inChannels)m=new Ui(p);else{m=new zi(p);const e=p.inHeight*p.inWidth,t=p.inChannels,n=p.filterHeight*p.filterWidth*p.outChannels;f.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(m,[i,a],"float32",f)}},Wi={kernelName:s.mc4,backendName:"webgpu",kernelFunc:mn({opType:Ut.COS})},Vi={kernelName:s.TR1,backendName:"webgpu",kernelFunc:mn({opType:Ut.COSH})};class Gi{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+e],[a,s,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+t];return`\n    ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${a});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${s};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Hi={kernelName:s.VcC,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:a,boxInd:s}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new Gi(i.shape[3],a.shape,o,u),d=[{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[i,a,s],"float32",d)}};var ji;!function(e){e.Prod="*",e.Sum="+"}(ji||(ji={}));class Xi{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===ji.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Ki(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?"end + pow2 < "+r:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`\n      ${ct("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${qi(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${a};\n           ${qi(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Ki(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Ki(e,t,n){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function qi(e,t,n){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Yi(e,t,n,r,i,a){const o=t.shape.length,u=s.backend_util.getAxesPermutation([r],o);let l=t;null!=u&&(l=Ur({inputs:{x:t},backend:n,attrs:{perm:u}}));const c=s.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=`+r);const d=l.shape[c];let h=cn({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const r=new Xi(e,l.shape,!1,a),i=h,s=[{type:"float32",data:[t]}];h=n.runWebGPUProgram(r,[h],h.dtype,s),n.disposeData(i.dataId)}if(i){const t=new Xi(e,l.shape,i,a),r=h,s=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(t,[h],h.dtype,s),n.disposeData(r.dataId)}if(null!=u){const e=Ur({inputs:{x:h},backend:n,attrs:{perm:s.backend_util.getUndoAxesPermutation(u)}});return n.disposeData(h.dataId),n.disposeData(l.dataId),e}return h}const Qi={kernelName:s.Byc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return Yi(ji.Prod,i,n,a,s,o)}},Zi={kernelName:s.iHb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return Yi(ji.Sum,i,n,a,s,o)}},Ji={kernelName:s.QRR,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o,binaryOutput:u}=r,l=1===i.shape.length,c=s.D5U.sizeFromShape(a.shape)>0,d=a.dtype,h=l?[i.shape[0]]:[i.shape[0],i.shape[1]],p=tn({backend:n,attrs:{shape:l?[o]:[i.shape[0],o],value:0,dtype:d}}),f=new fi(h,c,u),m=[{type:"int32",data:[o]}],g=c?[i,a]:[i];return n.runWebGPUProgram(f,g,d,m,p)}};class ea{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_"+t,this.dataFormat=t}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ta={kernelName:s.T0n,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:a,dataFormat:s}=r,o=i.shape[0],u=("NHWC"===s?i.shape[1]:i.shape[2])*a,l=("NHWC"===s?i.shape[2]:i.shape[3])*a,c=("NHWC"===s?i.shape[3]:i.shape[1])/(a*a),d=[{type:"int32",data:[a]}],h=new ea("NHWC"===s?[o,u,l,c]:[o,c,u,l],s);return n.runWebGPUProgram(h,[i],i.dtype,d)}};class na{constructor(e,t,n,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${Wt(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${ct()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${Vt(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class ra{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),s.D5U.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${Wt(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${ct()} {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${Vt(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class ia{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${Wt(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilation[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilation[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${Vt(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const aa={kernelName:s.cie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=r,h=s.backend_util.convertConv2DDataFormat(l);let p=c;null==p&&(p=[1,1]);const f=s.backend_util.computeConv2DInfo(i.shape,a.shape,o,p,u,d,!0,h),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let x;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?x=new na(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?x=new ra(f):(x=new ia(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),n.runWebGPUProgram(x,[i,a],i.dtype,m)}};class sa{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const oa={kernelName:s.$w,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=[...r.shape,...r.shape],a=s.D5U.sizeFromShape(r.shape),o=rn({inputs:{x:r},backend:n,attrs:{shape:[a]}}),u=new sa(a),l=n.runWebGPUProgram(u,[o],o.dtype),c=rn({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeData(o.dataId),n.disposeData(l.dataId),c}};class ua{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${ct("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilation[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilation[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const la={kernelName:s.p4S,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=r,c=s.backend_util.computeDilation2DInfo(i.shape,a.shape,o,u,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new ua(c);return n.runWebGPUProgram(p,[i,a],i.dtype,h)}},ca=gn({opType:Tt.MUL,cpuKernelImpl:pr,supportsComplex:!0}),da={kernelName:s.wYn,backendName:"webgpu",kernelFunc:ca};function ha(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return zr(i,a,s,"sum",n)}const pa={kernelName:s.GBy,backendName:"webgpu",kernelFunc:ha},fa={kernelName:s.$g6,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:i}=r,a=t,{allDims:o,summedDims:u,idDims:l}=s.backend_util.decodeEinsumEquation(i,a.length);s.backend_util.checkEinsumDimSizes(o.length,l,a);const{path:c,steps:d}=s.backend_util.getEinsumComputePath(u,l),h=d.length;let p=null,f=o.length;const m=[];for(let e=0;e<h;++e){for(const t of d[e]){const{permutationIndices:e,expandDims:r}=s.backend_util.getEinsumPermutation(f,l[t]);let i;s.backend_util.isIdentityPermutation(e)?i=a[t]:(i=Ur({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),m.push(i));const o=i.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);s.D5U.arraysEqual(i.shape,o)||(i=rn({inputs:{x:i},backend:n,attrs:{shape:o}}),m.push(i)),null===p?p=i:(p=ca({inputs:{a:i,b:p},backend:n}),m.push(p))}e<h-1&&(c[e]>=0&&(p=ha({inputs:{x:p},backend:n,attrs:{axis:c[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeData(e.dataId);return p}},ma={kernelName:s.SX0,backendName:"webgpu",kernelFunc:mn({opType:Ut.ELU})},ga={kernelName:s.hdR,backendName:"webgpu",kernelFunc:gn({opType:Tt.EQUAL,dtype:"bool",cpuKernelImpl:Jn})},xa={kernelName:s.Omj,backendName:"webgpu",kernelFunc:mn({opType:Ut.ERF})},ba=mn({opType:Ut.EXP,cpuKernelImpl:er,dtype:"float32"}),ya={kernelName:s.NEP,backendName:"webgpu",kernelFunc:ba};function wa(e){const{inputs:t,attrs:n,backend:r}=e,{dim:i}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice();let l=i;return i<0&&(s.D5U.assert(-(o+1)<=i,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+i+1),u.splice(l,0,1),rn({inputs:{x:a},backend:r,attrs:{shape:u}})}const va={kernelName:s.YFo,backendName:"webgpu",kernelFunc:wa},ka={kernelName:s.Y0y,backendName:"webgpu",kernelFunc:mn({opType:Ut.EXPM1,cpuKernelImpl:tr})};class Ca{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_"+e}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function Ia(e,t,n){const r=n.tensorMap.get(e.dataId),i=s.D5U.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],o=[],u=rn({inputs:{x:e},backend:n,attrs:{shape:[i/a,a]}});o.push(u);const l=u.shape,c=new Ca("real",l),d=new Ca("imag",l),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?l[1]:1]}],f=n.runWebGPUProgram(c,h,"float32",p);o.push(f);const m=n.runWebGPUProgram(d,h,"float32",p);o.push(m);const g=hn({inputs:{real:f,imag:m},backend:n});o.push(g);const x=rn({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach((e=>n.disposeData(e.dataId))),x}const Sa={kernelName:s.vwp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Ia(r,!1,n)}};class $a{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Ra={kernelName:s.Uyb,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new $a(n.shape);return r.runWebGPUProgram(i,[n],n.dtype)}},Ta={kernelName:s.OR,backendName:"webgpu",kernelFunc:mn({opType:Ut.FLOOR,cpuKernelImpl:nr})},Aa={kernelName:s.jeX,backendName:"webgpu",kernelFunc:gn({opType:Tt.INT_DIV,dtype:"int32"})};class Ea{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_"+this.importVideo}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${ct("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const Na={kernelName:s.eBW,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:i}=t;const{numChannels:a}=r;if(null==i)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&i instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&i instanceof OffscreenCanvas,c="undefined"!=typeof ImageBitmap&&i instanceof ImageBitmap,[d,h]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],p=[h,d,a],f=o||u;if(c||l||f){let e;{if(f){const e=(0,s.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Da&&e===_a||(_a=e,Da=document.createElement("canvas").getContext("2d",{willReadFrequently:_a})),Da.canvas.width=d,Da.canvas.height=h,Da.drawImage(i,0,0,d,h),i=Da.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",a=n.textureManager.acquireTexture(p[1],p[0],r,t);n.queue.copyExternalImageToTexture({source:i},{texture:a},[p[1],p[0]]),e={width:d,height:h,format:r,usage:t,texture:a}}const t=s.D5U.sizeFromShape(p),r=s.D5U.computeStrides(p),o=new Ea(p,a,!1),u=[{type:"uint32",data:[t]},{type:"uint32",data:[a]},{type:"uint32",data:[...r]}],l=n.makeTensorInfo([h,d],"int32");n.tensorMap.get(l.dataId).resourceInfo=e;const c=n.runWebGPUProgram(o,[l],"int32",u);return n.disposeData(l.dataId),c}const m=i.data;let g=m;if(null!=a&&4!==a){g=new Uint8Array(i.width*i.height*a);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<a&&(g[t++]=m[n])}const x=n.makeTensorInfo(p,"int32",new Int32Array(g));return n.uploadToGPU(x.dataId),x}};let Da,_a=(0,s.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Fa{constructor(e,t,n,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],s.backend_util.assertAndGetBroadcastShape(e,t),s.backend_util.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(s.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=i&&(s.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),`\n      ${ct("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Pa={kernelName:s.sHE,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:i,offset:a,mean:s,variance:o}=e,{varianceEpsilon:u}=t,l=n,c=[r,s,o];let d=null;null!=a&&(d=a.shape,c.push(a));let h=null;null!=i&&(h=i.shape,c.push(i));const p=new Fa(r.shape,s.shape,o.shape,d,h),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,c,r.dtype,f)}},Oa={kernelName:s._V0,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=s.backend_util.convertConv2DDataFormat(d);return Pi({x:i,filter:a,convInfo:s.backend_util.computeConv2DInfo(i.shape,a.shape,l,h,c,p,!1,g),backend:n,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}},Ua={kernelName:s.luS,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=d;null==m&&(m=[1,1]),s.D5U.assert(s.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=s.backend_util.computeConv2DInfo(i.shape,a.shape,l,m,c,h,!0),x=[i,a],b=null!=o,y=null!=u;b&&x.push(o),y&&x.push(u);const w=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let v;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?v=new ra(g,b,p,y):(v=new ia(g,b,p,y),w.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(w.push({type:"float32",data:[f]}),v.uniforms+=" alpha : f32,"),n.runWebGPUProgram(v,x,"float32",w)}};class Ba{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${ut(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const La={kernelName:s.q1x,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:i}=t,a=i.shape,o=a[a.length-1],u=s.D5U.sizeFromShape(r.shape),[l,c,d,h]=s.backend_util.prepareAndValidate(r,i),p=rn({inputs:{x:i},backend:n,attrs:{shape:[c,o]}}),f=rn({inputs:{x:r},backend:n,attrs:{shape:[s.D5U.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const e=n.readSync(i.dataId),t=n.bufferSync(r),a=rr(e,t,r.dtype,c,o,d,h,r.shape,u);return n.makeTensorInfo(l,r.dtype,a.values)}const m=new Ba(o,[c,d]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],x=n.runWebGPUProgram(m,[f,p],f.dtype,g),b=rn({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),b}};class za{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(""+t[r]);return n.join()}(this.aShape);return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Ma(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,indices:a}=t,{axis:o,batchDims:u}=r,l=s.D5U.parseAxisParam(o,i.shape)[0],c=s.backend_util.segment_util.collectGatherOpShapeInfo(i,a,l,u),d=s.D5U.sizeFromShape(a.shape),h=[],p=rn({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=rn({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});h.push(p),h.push(f);const m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,a])){const e=n.tensorMap.get(f.dataId).values,t=(0,s.f3b)(f.shape,f.dtype,e),r=n.tensorMap.get(p.dataId).values,i=(0,s.f3b)(p.shape,p.dtype,r),a=ir(i,t,m);return h.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(c.outputShape,a.dtype,a.values)}const g=new za(p.shape,m),x=n.runWebGPUProgram(g,[p,f],p.dtype);h.push(x);const b=rn({inputs:{x},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeData(e.dataId))),b}const Wa={kernelName:s.qi_,backendName:"webgpu",kernelFunc:Ma},Va={kernelName:s.iZT,backendName:"webgpu",kernelFunc:gn({opType:Tt.GREATER,cpuKernelImpl:sr,dtype:"bool"})},Ga={kernelName:s.Acj,backendName:"webgpu",kernelFunc:gn({opType:Tt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:ar})},Ha={kernelName:s.Qg5,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Ia(r,!0,n)}},ja={kernelName:s.avt,backendName:"webgpu",kernelFunc:mn({opType:Ut.IS_FINITE,dtype:"bool"})},Xa={kernelName:s.iWB,backendName:"webgpu",kernelFunc:mn({opType:Ut.IS_INF,dtype:"bool"})},Ka={kernelName:s.r7n,backendName:"webgpu",kernelFunc:mn({opType:Ut.IS_NAN,dtype:"bool"})},qa={kernelName:s.J$2,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:a}=r,s=[{type:"float32",data:[a]}],o=new fn(i.shape,Ut.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[i],"float32",s)}},Ya={kernelName:s.vtC,backendName:"webgpu",kernelFunc:gn({opType:Tt.LESS,dtype:"bool",cpuKernelImpl:ur})},Qa={kernelName:s.CAk,backendName:"webgpu",kernelFunc:gn({opType:Tt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:or})};class Za{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Ja={kernelName:s.e7N,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:a}=n,s=(i-r)/(a-1),o=new Za(a),u=[{type:"float32",data:[r]},{type:"float32",data:[s]}];return t.runWebGPUProgram(o,[],"float32",u)}},es={kernelName:s.ZbH,backendName:"webgpu",kernelFunc:mn({opType:Ut.LOG,cpuKernelImpl:lr})},ts={kernelName:s.kU,backendName:"webgpu",kernelFunc:mn({opType:Ut.LOG1P})},ns={kernelName:s.PYm,backendName:"webgpu",kernelFunc:gn({opType:Tt.LOGICAL_AND,dtype:"bool"})},rs={kernelName:s.VfG,backendName:"webgpu",kernelFunc:mn({opType:Ut.LOGICAL_NOT})},is={kernelName:s.MZg,backendName:"webgpu",kernelFunc:gn({opType:Tt.LOGICAL_OR})},as="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class ss{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${ct("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${as}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class os{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,s.D5U.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=yt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${ct()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${as}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const us={kernelName:s.eZ0,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:a,bias:s,alpha:o,beta:u}=r;let l;l=a>16?new ss(i.shape):new os(i.shape,a);const c=[{type:"int32",data:[a]},{type:"float32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[i],i.dtype,c)}},ls={kernelName:s.BMI,backendName:"webgpu",kernelFunc:gn({opType:Tt.MAX,cpuKernelImpl:dr})},cs={kernelName:s.mTV,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=r;return ri(i,s.backend_util.computePool2DInfo(i.shape,a,o,1,u,l),"max",n)}},ds={kernelName:s.c17,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return zr(i,a,s,"min",n)}},hs={kernelName:s.q8u,backendName:"webgpu",kernelFunc:gn({opType:Tt.MIN,cpuKernelImpl:hr})};class ps{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_"+n}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",s=ut(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let start = ${s}(${t});\n          let end = ${s}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${a} < ${r}) {\n              ${a} = ${r} * 2 - ${a} - ${this.offset};\n            } else if(${a} >= ${i}) {\n              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const fs={kernelName:s.jQs,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:i,mode:a}=t,s=n,o=i.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new ps(r.shape,i,a);return s.runWebGPUProgram(u,[r],r.dtype,o)}},ms={kernelName:s.Vbg,backendName:"webgpu",kernelFunc:gn({opType:Tt.MOD})},gs={kernelName:s.kuV,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,i]=fr(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}const i=new fn(r.shape,Ut.NEG);return n.runWebGPUProgram(i,[r],r.dtype)}},xs={kernelName:s.uv1,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=r,c=n.readSync(i.dataId),d=n.readSync(a.dataId),{selectedIndices:h}=s.GDt.nonMaxSuppressionV3Impl(c,d,o,u,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},bs={kernelName:s.W0H,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(i.dataId),h=n.readSync(a.dataId),p=o,f=u,m=l,g=c,{selectedIndices:x,selectedScores:b}=s.GDt.nonMaxSuppressionV5Impl(d,h,p,f,m,g);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class ys{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${ct("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const ws={kernelName:s.we_,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:i}=t,{dtype:a,depth:o,onValue:u,offValue:l}=r,c=s.D5U.sizeFromShape(i.shape),d=new ys(c,o),h=rn({inputs:{x:i},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[u]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(d,[h],a,p);n.disposeData(h.dataId);const m=rn({inputs:{x:f},backend:n,attrs:{shape:[...i.shape,o]}});return n.disposeData(f.dataId),m}};function vs(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=bi({inputs:{input:r},backend:n}),t=vs({inputs:{x:e},backend:n}),i=$i({inputs:{input:r},backend:n}),a=vs({inputs:{x:i},backend:n}),s=hn({inputs:{real:t,imag:a},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),s}return tn({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const ks={kernelName:s.RuY,backendName:"webgpu",kernelFunc:vs},Cs={kernelName:s.qWM,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=bi({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),a=$i({inputs:{input:i},backend:r}),s=vs({inputs:{x:a},backend:r}),o=hn({inputs:{real:n,imag:s},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(a.dataId),r.disposeData(s.dataId),o}return tn({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},Is={kernelName:s.QiL,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r;if(1===t.length)return wa({inputs:{input:t[0]},backend:n,attrs:{dim:i}});const a=t[0].shape,o=t[0].dtype;t.forEach((e=>{s.D5U.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),s.D5U.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Ai({inputs:t.map((e=>{const t=wa({inputs:{input:e},backend:n,attrs:{dim:i}});return u.push(t),t})),backend:n,attrs:{axis:i}});return u.forEach((e=>n.disposeData(e.dataId))),l}};class Ss{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=ut(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=e>1?`${t}(${n})`:""+n,a=e>1?`${t}(${r})`:""+r,s=e>1?"any(outC < start)":"outC < start",o=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let start = ${i};\n          let end = ${a};\n          let outC = getCoordsFromIndex(index);\n\n          if (${s} || ${o}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const $s=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:a,constantValue:o}=r;if(a.every((e=>s.D5U.arraysEqual(e,[0,0]))))return cn({inputs:{x:i},backend:n});if(0===s.D5U.sizeFromShape(i.shape))return tn({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+i.shape[t]+e[1])),value:o,dtype:i.dtype}});const u=[{type:"float32",data:[o]}];a.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new Ss(i.shape,a);return n.runWebGPUProgram(l,[i],i.dtype,u)},Rs={kernelName:s.lyA,backendName:"webgpu",kernelFunc:$s},Ts={kernelName:s.pe_,backendName:"webgpu",kernelFunc:gn({opType:Tt.POW})},As={kernelName:s.o0g,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,a=new ln(Tt.PRELU,r.shape,i.shape);return n.runWebGPUProgram(a,[r,i],"float32")}},Es={kernelName:s.DlI,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return zr(i,a,s,"prod",n)}},Ns={kernelName:s.e6w,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:a,dtype:s}=n,o=xr(r,i,a,s);return t.makeTensorInfo([o.length],s,o)}},Ds=gn({opType:Tt.DIV}),_s={kernelName:s.oHH,backendName:"webgpu",kernelFunc:Ds},Fs={kernelName:s.$HU,backendName:"webgpu",kernelFunc:mn({opType:Ut.RECIPROCAL})},Ps={kernelName:s.qkr,backendName:"webgpu",kernelFunc:mn({opType:Ut.RELU})},Os={kernelName:s.SbG,backendName:"webgpu",kernelFunc:mn({opType:Ut.RELU6})};class Us{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Bs={kernelName:s._Yw,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,size:s,halfPixelCenters:o}=r,[u,l]=s,c=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],d=new Us(i.shape,u,l);return n.runWebGPUProgram(d,[i],"float32",c)}};class Ls{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey="resizeNearest_"+r}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const zs={kernelName:s.dpD,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:s,size:o}=r,[u,l]=o,c=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],d=new Ls(i.shape,u,l,s);return n.runWebGPUProgram(d,[i],i.dtype,c)}};class Ms{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const Ws={kernelName:s.mKl,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dims:a}=r,o=i.shape.length;if(0===o)return cn({inputs:{x:i},backend:n});const u=i.shape,l=[1,1,1,1];u.forEach(((e,t)=>{l[t+4-o]=e}));const c=s.D5U.parseAxisParam(a,i.shape),d=[0,0,0,0];c.forEach((e=>{d[e+4-o]=1}));const h=[{type:"int32",data:d}],p=rn({inputs:{x:i},backend:n,attrs:{shape:l}}),f=new Ms(l),m=n.runWebGPUProgram(f,[p],p.dtype,h);n.disposeData(p.dataId);const g=rn({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class Vs{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${ct("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const Gs={kernelName:s.b9H,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:i,fillValue:a,center:o}=t,u=n,l=new Vs(r.shape,a),[c,d]=s.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return"number"==typeof a?h.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):h.push({type:"float32",data:a}),u.runWebGPUProgram(l,[r],r.dtype,h)}},Hs={kernelName:s.e07,backendName:"webgpu",kernelFunc:mn({opType:Ut.ROUND})},js={kernelName:s.bV0,backendName:"webgpu",kernelFunc:mn({opType:Ut.RSQRT,cpuKernelImpl:br})};class Xs{constructor(e,t,n,r,i,a,s,o=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=s,this.sumDupeIndices=o,this.dispatchLayout=kt(e),this.dispatch=yt(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${s}_${o}`;const u=ut(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const a=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${i}\n      ${ct("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${gt(this.type,!1)}(${a});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?ot("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const Ks={kernelName:s.xQA,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:i,updates:a}=t,{shape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=s.backend_util.calculateShapes(a,i,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,i.dtype);const f=rn({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=rn({inputs:{x:a},backend:n,attrs:{shape:[l,c]}}),g=m.dtype,x=tn({backend:n,attrs:{shape:p,value:0,dtype:g}}),b=[{type:"int32",data:[u]},{type:"int32",data:d},{type:"int32",data:[s.D5U.sizeFromShape(m.shape)]}],y=new Xs(m.shape,u,f.shape.length,m.shape.length,d,p,g),w=n.runWebGPUProgram(y,[m,f],g,b,x),v=rn({inputs:{x:w},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(w.dataId),v}};class qs{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_"+t}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const Ys={kernelName:s.nr8,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:a}=t,{side:s}=r,o=new qs([a.shape[0],a.shape[1]],s),u=[{type:"int32",data:[i.shape[1]]}];return n.runWebGPUProgram(o,[i,a],"int32",u)}};class Qs{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let e=0;e<this.outputShape.length;e++)i.push(""+n[e]),e<this.cRank&&r.push(""+n[e]);e=r.join(),t=i.join()}return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const Zs={kernelName:s.PhF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:i,e:a}=t,o=new Qs(r.shape.length,i.shape,i.shape.length);return n.runWebGPUProgram(o,[r,i,a],(0,s.x8V)(i.dtype,a.dtype))}},Js={kernelName:s.oFR,backendName:"webgpu",kernelFunc:mn({opType:Ut.SELU})},eo={kernelName:s.a5O,backendName:"webgpu",kernelFunc:mn({opType:Ut.SIGMOID})},to={kernelName:s.i5y,backendName:"webgpu",kernelFunc:mn({opType:Ut.SIGN})},no={kernelName:s.RQH,backendName:"webgpu",kernelFunc:mn({opType:Ut.SIN})},ro={kernelName:s.wYB,backendName:"webgpu",kernelFunc:mn({opType:Ut.SINH})},io=gn({opType:Tt.SUB,cpuKernelImpl:Ir,supportsComplex:!0}),ao={kernelName:s.Tr8,backendName:"webgpu",kernelFunc:io},so={kernelName:s.Gcp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{dim:a}=r,o=s.D5U.parseAxisParam([a],i.shape),u=Jr({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=s.backend_util.expandShapeToKeepDim(u.shape,o),c=rn({inputs:{x:u},backend:n,attrs:{shape:l}}),d=io({inputs:{a:i,b:c},backend:n}),h=ba({inputs:{x:d},backend:n}),p=ha({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),f=rn({inputs:{x:p},backend:n,attrs:{shape:l}}),m=Ds({inputs:{a:h,b:f},backend:n});return n.disposeData(u.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(h.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}},oo={kernelName:s.MRv,backendName:"webgpu",kernelFunc:mn({opType:Ut.SOFTPLUS})},uo={kernelName:s.TQc,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,paddings:o}=r;s.D5U.assert(i.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const u=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+a.length;e<i.shape.length;++e)l.push([0,0]);const c=[],d=$s({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),h=s.backend_util.getReshaped(d.shape,a,u,!1),p=s.backend_util.getPermuted(h.length,a.length,!1),f=s.backend_util.getReshapedPermuted(d.shape,a,u,!1),m=rn({inputs:{x:d},backend:n,attrs:{shape:h}}),g=Ur({inputs:{x:m},backend:n,attrs:{perm:p}}),x=rn({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(d),c.push(m),c.push(g),c.forEach((e=>n.disposeData(e.dataId))),x}};class lo{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e;i++)r.push(`(${n[i]} % ${t}aShape[${i}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${ct("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function co(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reps:a}=r;if(n.shouldExecuteOnCPU([i])||"string"===i.dtype||i.shape.length>=5){const e=n.readSync(i.dataId),t="string"===i.dtype?e.map((e=>s.D5U.decodeString(e))):e,r=(0,s.f3b)(i.shape,i.dtype,t),o=Sr(r,a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new lo(i.shape,a);return n.runWebGPUProgram(o,[i],i.dtype)}const ho={kernelName:s.n9L,backendName:"webgpu",kernelFunc:co},po={kernelName:s.D2d,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:u}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=s.backend_util.calculateShapes(a,i,u);if("string"===a.dtype){const e=n.bufferSync(i),t=n.bufferSync(a),r=s.D5U.decodeString(n.readSync(o.dataId)[0]),f=yr(e,t,u,p,d,c,l,h,r,!1);return n.makeTensorInfo(u,f.dtype,f.values)}const f=[p/d,d],m=rn({inputs:{x:i},backend:n,attrs:{shape:[c,l]}}),g=a.shape.length?rn({inputs:{x:a},backend:n,attrs:{shape:[c,d]}}):cn({inputs:{x:a},backend:n}),x=g.dtype,b=n.makeTensorInfo([],x,s.D5U.makeZerosTypedArray(1,x)),y=rn({inputs:{x:o},backend:n,attrs:{shape:Array(f.length).fill(1)}}),w=co({inputs:{x:y},backend:n,attrs:{reps:f}}),v=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[s.D5U.sizeFromShape([c,d])]}];switch(c){case 0:break;case 1:{const e=new Xs([c,d],l,m.shape.length,g.shape.length,h,f,x,!1);n.runWebGPUProgram(e,[g,m],x,v,w)}break;default:{const e=new Xs([c,d],l,m.shape.length,b.shape.length,h,f,x,!1);n.runWebGPUProgram(e,[b,m],x,v,w)}{const e=new Xs([c,d],l,m.shape.length,g.shape.length,h,f,x);n.runWebGPUProgram(e,[g,m],x,v,w)}}const k=rn({inputs:{x:w},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(b.dataId),n.disposeData(w.dataId),k}},fo={kernelName:s.L8s,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{numOrSizeSplits:a,axis:o}=r,u=s.D5U.parseAxisParam(o,i.shape)[0],l=s.backend_util.prepareSplitSize(i,a,u),c=i.shape.length,d=new Array(c).fill(0),h=i.shape.slice();return l.map((e=>{const t=[...h];t[u]=e;const r=ci({inputs:{x:i},backend:n,attrs:{begin:d,size:t}});return d[u]+=e,r}))}},mo={kernelName:s.FKq,backendName:"webgpu",kernelFunc:mn({opType:Ut.SQRT})},go={kernelName:s.bK0,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new fn(n.shape,Ut.SQUARE);return r.runWebGPUProgram(i,[n],n.dtype)}},xo={kernelName:s._tC,backendName:"webgpu",kernelFunc:gn({opType:Tt.SQUARED_DIFFERENCE})},bo={kernelName:s.h8e,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=new fn(r.shape,Ut.STEP,"stepAlpha : f32,"),a=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(i,[r],r.dtype,a)}};class yo{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=ut(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${ct("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const wo={kernelName:s.jQk,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:v}=s.kuN.sliceInfo(i.shape,a,o,u,l,c,d,h,p);let k;if(g)k=rn({inputs:{x:i},backend:n,attrs:{shape:m}});else if(x||b){s.D5U.assert(i.shape.length>=1,(()=>"Input must have rank at least 1, got: "+i.shape.length));const e=s.kuN.computeOutShape(y,w,v),t=ci({inputs:{x:i},backend:n,attrs:{begin:y,size:e}});k=rn({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeData(t.dataId)}else if(n.shouldExecuteOnCPU([i])){const e=n.readSync(i.dataId),t=(0,s.f3b)(i.shape,i.dtype,e),r=kr(f,t,v,y);k=n.makeTensorInfo(m,i.dtype,r.values)}else{const e=new yo(f),t=[{type:"int32",data:y},{type:"int32",data:v}],r=n.runWebGPUProgram(e,[i],i.dtype,t);k=rn({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}return k}},vo={kernelName:s._JP,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:a,leftPad:s,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=Cr(h,p,i,a,s,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},ko={kernelName:s.sEM,backendName:"webgpu",kernelFunc:mn({opType:Ut.TAN})},Co={kernelName:s.MIZ,backendName:"webgpu",kernelFunc:mn({opType:Ut.TANH})};class Io{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${ct("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class So{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${ct("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function $o(e,t){null!==t&&e.disposeData(t.dataId)}function Ro(e){let t=1;for(;t<e;)t*=2;return t}const To={kernelName:s.cWu,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{k:a,sorted:o}=r,u=i.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([i])){const e=n.readSync(i.dataId),[t,r]=$r(e,u,i.dtype,a,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,i.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[i,tn({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const c=s.D5U.sizeFromShape(u)/l,d=rn({inputs:{x:i},attrs:{shape:[c,l]},backend:n}),h=Ro(a),p=Ro(l);let f=null;const m=()=>null===f?[d,d]:[d,f],g=(e,t,r)=>{const i=m(),a=new Io(r),s=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(a,i,"int32",s),$o(n,o)};for(let e=1;e<h;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[c,p])}for(let e=p;e>h;e/=2){const t=m(),r=new So([c,e/2]),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[h]}],a=f;f=n.runWebGPUProgram(r,t,"int32",i),$o(n,a);const s=h/2,o=2*s;for(let e=s;e>=1;e/=2)g(o,e,f.shape)}let x=f;f=ci({inputs:{x:f},backend:n,attrs:{begin:0,size:[c,a]}}),$o(n,x);let b=Ma({inputs:{x:d,indices:f},backend:n,attrs:{axis:1,batchDims:1}});$o(n,d);const y=u.slice(0,-1);y.push(a),x=f,f=rn({inputs:{x:f},attrs:{shape:y},backend:n}),$o(n,x);const w=b;return b=rn({inputs:{x:b},attrs:{shape:y},backend:n}),$o(n,w),[b,f]}};class Ao{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${ct("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const Eo=[on,Ar,Er,Nr,Dr,Fr,Mr,Wr,Gr,Hr,jr,Xr,Kr,qr,Yr,ii,si,oi,hi,mi,wi,vi,Ii,pn,Ei,Oi,Li,Mi,Wi,Vi,Hi,Qi,Zi,Ji,ta,aa,oa,la,fa,ma,ga,xa,ya,va,ka,Sa,nn,Ra,Na,Ta,Aa,Pa,Oa,Ua,La,Wa,Va,Ga,dn,Ha,Ri,ja,Xa,Ka,qa,Ya,Qa,Ja,ts,es,ns,rs,is,us,ei,ls,cs,ni,ds,hs,fs,ms,da,gs,xs,bs,xi,ws,Cs,Is,Rs,Ts,As,Es,Ns,yi,_s,Fs,Ps,Os,an,Bs,zs,Ws,Gs,Hs,js,Ks,Ys,Zs,Js,eo,to,no,ro,di,bo,wo,vo,so,oo,uo,po,fo,mo,go,xo,ao,pa,ko,Co,ho,To,{kernelName:s.wx7,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:a}=t,{interpolation:s,fillMode:o,fillValue:u,outputShape:l}=r,[c,d,h,p]=i.shape,[f,m]=null!=l?l:[d,h],g=new Ao([c,f,m,p]),x="nearest"===s?1:2;let b;switch(o){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const y=[{type:"int32",data:[x]},{type:"int32",data:[b]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[i,a],"float32",y)}},Br,{kernelName:s.ToN,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:a}=r;a<0&&(a+=i.shape.length);const s=i,o=s.shape.length,u=i.shape[a],l=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(l[c++]=s.shape[e]);const d=[],h=new Array(o).fill(0),p=s.shape.slice();p[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){h[a]=e;const t=ci({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),r=rn({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),f}},ks];for(const e of Eo)(0,s.wCN)(e);function No(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var Do=function(){function e(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=kt(this.outputShape),this.dispatch=yt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(No("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}(),_o=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=kt(t),this.dispatch=yt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(No("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function Fo(e){var t=e.shape,n=t[0],r=t[1],i=t[2];return(0,s.lub)((function(){var t,a,o=(0,s.XLQ)(e,[n*r,i]),u=(0,s.NqF)(o,0),l=(0,s.dt4)((0,s.hiC)(u,(0,s.iD$)(r,"int32")),1),c=(0,s.dt4)((t=u,a=r,(0,s.lub)((function(){var e=(0,s.hiC)(t,(0,s.iD$)(a,"int32"));return(0,s.luU)(t,(0,s.dC7)(e,(0,s.iD$)(a,"int32")))}))),1);return(0,s.zoF)([l,c],1)}))}function Po(e,t,n){return(0,s.lub)((function(){var r=function(e,t){for(var n=[],r=0;r<p.length;r++){var i=Oo(e.get(r,0).valueOf(),e.get(r,1).valueOf(),r,t),a=i.x,o=i.y;n.push(o),n.push(a)}return(0,s.odF)(n,[p.length,2])}(e,n);return(0,s.IHx)((0,s.pju)((0,s.dC7)(e.toTensor(),(0,s.iD$)(t,"int32")),"float32"),r)}))}function Oo(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+p.length)}}function Uo(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h,f;return d(this,(function(d){switch(d.label){case 0:return r=0,i=Fo(e),[4,Promise.all([e.buffer(),t.buffer(),i.buffer()])];case 1:return a=d.sent(),s=a[0],o=a[1],u=a[2],[4,(l=Po(u,n,o)).buffer()];case 2:return c=d.sent(),h=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),i=0;i<n;i++){var a=t.get(i,0),s=t.get(i,1);r[i]=e.get(a,s,i)}return r}(s,u)),f=h.map((function(e,t){return r+=e,{y:c.get(t,0),x:c.get(t,1),score:e,name:p[t]}})),i.dispose(),l.dispose(),[2,{keypoints:f,score:r/f.length}]}}))}))}function Bo(e,t,n){return c(this,void 0,void 0,(function(){var r,i,a;return d(this,(function(o){return r=Fo(e),i=function(e,t,n){return(0,s.lub)((function(){var r=function(e,t){if((0,s.y3$)()instanceof Rt)return function(e,t){var n=(0,s.y3$)(),r=new _o(e.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return(0,s.SRH)().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(e,n);return(0,s.IHx)((0,s.pju)((0,s.dC7)(e,(0,s.iD$)(t,"int32")),"float32"),r)}))}(r,n,t),a=function(e,t){if((0,s.y3$)()instanceof Rt)return function(e,t){var n=(0,s.y3$)(),r=new Do(t.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return(0,s.SRH)().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(e,r),[2,[i,a]]}))}))}function Lo(e,t){return(e-1)%t==0}function zo(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}!function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;s.D5U.assert(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}));var r,i,a=(r=t.inputResolution,i=t.outputStride,{height:zo(r.height,i),width:zo(r.width,i)});!function(e){s.D5U.assert(Ne.indexOf(e)>=0,(function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."}))}(t.outputStride),function(e,t){s.D5U.assert(Lo(e.height,t),(function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")})),s.D5U.assert(Lo(e.width,t),(function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")}))}(a,t.outputStride),this.inputResolution=a,this.outputStride=t.outputStride,this.architecture=t.architecture}e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=De),c(this,void 0,void 0,(function(){return d(this,(function(n){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=De),void 0===n&&(n=!1),c(this,void 0,void 0,(function(){var r,i,a,o,u,c,h,p,f,m,g,x,b,y,w,v,k,C;return d(this,(function(d){switch(d.label){case 0:return r=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=l(l({},_e),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=U(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=i.imageTensor,o=i.padding,u="ResNet50"===this.architecture?(0,s.IHx)(a,Fe):O(a,[-1,1]),c=this.posenetModel.predict(u),"ResNet50"===this.architecture?(h=(0,s.L9e)(c[2],[0]),p=(0,s.L9e)(c[3],[0]),f=(0,s.L9e)(c[0],[0]),m=(0,s.L9e)(c[1],[0])):(h=(0,s.L9e)(c[0],[0]),p=(0,s.L9e)(c[1],[0]),f=(0,s.L9e)(c[2],[0]),m=(0,s.L9e)(c[3],[0])),g=(0,s.XD2)(p),1!==this.maxPoses?[3,5]:n?[4,Bo(g,h,this.outputStride)]:[3,2]);case 1:return b=d.sent(),w=b[0],y=b[1],x=[w,y],[3,4];case 2:return[4,Uo(g,h,this.outputStride)];case 3:w=d.sent(),x=[w],d.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,Ze(g,h,f,m,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:x=d.sent(),d.label=7;case 7:if(n){if(!0===r.flipHorizontal)throw new Error("flipHorizontal is not supported!");v=this.getCanvasInfo($(e),this.inputResolution,o)}else C=$(e),k=function(e,t,n,r){var i=t.height,a=t.width,s=i/(n.height*(1-r.top-r.bottom)),o=a/(n.width*(1-r.left-r.right)),u=-r.top*n.height,l=-r.left*n.width;if(1===o&&1===s&&0===u&&0===l)return e;for(var c=0,d=e;c<d.length;c++)for(var h=0,p=d[c].keypoints;h<p.length;h++){var f=p[h];f.x=(f.x+l)*o,f.y=(f.y+u)*s}return e}(x,C,this.inputResolution,o),r.flipHorizontal&&(k=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var i=0,a=r[n].keypoints;i<a.length;i++){var s=a[i];s.x=t.width-1-s.x}return e}(k,C));return a.dispose(),u.dispose(),(0,s.B90)(c),h.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),[2,n?[x,v]:k]}}))}))},e.prototype.getCanvasInfo=function(e,t,n){var r=e.height,i=e.width,a=r/(t.height*(1-n.top-n.bottom)),s=i/(t.width*(1-n.left-n.right)),o=-n.top*t.height;return[-n.left*t.width,o,s,a,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){}}()},664:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{addImpl:()=>Ne,bincountImpl:()=>_e,bincountReduceImpl:()=>Fe,bitwiseAndImpl:()=>Pe,castImpl:()=>Re,ceilImpl:()=>Le,concatImpl:()=>ze,equalImpl:()=>Me,expImpl:()=>We,expm1Impl:()=>Ve,floorImpl:()=>Ge,gatherNdImpl:()=>He,gatherV2Impl:()=>je,greaterEqualImpl:()=>Ke,greaterImpl:()=>Xe,lessEqualImpl:()=>Ye,lessImpl:()=>qe,linSpaceImpl:()=>Qe,logImpl:()=>Ze,maxImpl:()=>Je,maximumImpl:()=>et,minimumImpl:()=>tt,multiplyImpl:()=>nt,negImpl:()=>it,notEqualImpl:()=>at,prodImpl:()=>ot,raggedGatherImpl:()=>lt,raggedRangeImpl:()=>dt,raggedTensorToTensorImpl:()=>gt,rangeImpl:()=>xt,rsqrtImpl:()=>bt,scatterImpl:()=>yt,sigmoidImpl:()=>wt,simpleAbsImpl:()=>ke,sliceImpl:()=>vt,sparseFillEmptyRowsImpl:()=>kt,sparseReshapeImpl:()=>Ct,sparseSegmentReductionImpl:()=>It,sqrtImpl:()=>St,staticRegexReplaceImpl:()=>$t,stridedSliceImpl:()=>Rt,stringNGramsImpl:()=>At,stringSplitImpl:()=>Nt,stringToHashBucketFastImpl:()=>Dt,subImpl:()=>_t,tileImpl:()=>Pt,topKImpl:()=>Bt,transposeImpl:()=>st,uniqueImpl:()=>Lt});var i=n(320);const a={},s={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function o(e,t){if(!(e in a)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if((0,i.OBj)().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete a[e]}),!1),(0,i.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(s.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",s)||n.getContext("experimental-webgl",s):n.getContext("webgl2",s)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;a[e]=n}const n=a[e];return null==n||n.isContextLost()?(delete a[e],o(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),a[e])}var u,l,c;function d(e,t){return[t,e]}function h(e){const t=i.D5U.sizeFromShape(e),n=Math.ceil(t/4);return i.D5U.sizeToSquarishShape(n)}function p(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function f(e,t){const n=e;let r,a,s,o,u,l,c,d,h,p;return 2===(0,i.OBj)().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,u=n.RED,c=4,d=1,h=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,o=n.RGBA,u=e.RGBA,c=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}function m(e,t){const n=t();return(0,i.OBj)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function g(e){return!!((0,i.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function x(e,t){return $(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(u||(u={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(l||(l={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(c||(c={}));const b=/ERROR: [0-9]+:([0-9]+):/g;function y(e,t){const n=b.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,o=a.map(((e,t)=>i.D5U.rightPad((t+1).toString(),s)+e));let u=0;for(let e=0;e<o.length;e++)u=Math.max(o[e].length,u);const l=o.slice(0,r-1),c=o.slice(r-1,r),d=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${i.D5U.rightPad(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function w(e,t){if(m(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function v(e,t,n,r,i,a,s){const o=e.getAttribLocation(t,n);return-1!==o&&(m(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),m(e,(()=>e.vertexAttribPointer(o,i,e.FLOAT,!1,a,s))),m(e,(()=>e.enableVertexAttribArray(o))),!0)}function k(e,t,n,r){m(e,(()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),m(e,(()=>e.activeTexture(e.TEXTURE0+n))),m(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),m(e,(()=>e.uniform1i(n,r)))}function C(e,t,n){m(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),m(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function I(e,t){m(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),m(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function S(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function $(e,t,n){const r=m(e,(()=>t()));if(null==r)throw new Error(n);return r}function R(e,t=2){return i.D5U.sizeFromShape(e.slice(0,e.length-t))}function T(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function A(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[R(e),...T(e)]),t}function E(e){return e%2==0}function N(e,t){if(e=e.slice(-2),t=t.slice(-2),i.D5U.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(E(n)&&E(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&E(e[0])&&E(t[0])}let D,_;function F(e,t){return null!=e.getExtension(t)}function P(e){try{if(null!=o(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function O(e){const t=f(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),i}function U(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const B=(0,i.OBj)();function L(){let e,t,n,r,a,s,o,u,l,c;return 2===(0,i.OBj)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",u=(0,i.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function z(e,t,n="index"){const r=i.D5U.computeStrides(t);return r.map(((t,i)=>`int ${e[i]} = ${n} / ${t}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${t}`:`index -= ${e[i]} * ${t}`};`)).join("")}function M(e,t,n="index"){const r=i.D5U.computeStrides(t);return r.map(((t,i)=>`int ${e[i]} = ${n} / outShapeStrides[${i}]; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`};`)).join("")}function W(e){const t=i.D5U.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}B.registerFlag("HAS_WEBGL",(()=>B.getNumber("WEBGL_VERSION")>0)),B.registerFlag("WEBGL_VERSION",(()=>P(2)?2:P(1)?1:0)),B.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),B.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===B.get("WEBGL_VERSION"))),B.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),B.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),B.registerFlag("WEBGL_PACK",(()=>B.getBool("HAS_WEBGL"))),B.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_CLIP",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_PACK_REDUCE",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_LAZILY_UNPACK",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_CONV_IM2COL",(()=>B.getBool("WEBGL_PACK"))),B.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==D){const t=o(e);D=t.getParameter(t.MAX_TEXTURE_SIZE)}return D}(B.getNumber("WEBGL_VERSION")))),B.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==_){const t=o(e);_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,_)}(B.getNumber("WEBGL_VERSION")))),B.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=B.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=o(e);return t=F(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:F(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),B.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>B.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.C2$.isMobile())),B.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=o(e);if(1===e){if(!F(t,"OES_texture_float"))return!1}else if(!F(t,"EXT_color_buffer_float"))return!1;return O(t)}(B.getNumber("WEBGL_VERSION")))),B.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!B.getBool("WEBGL_FORCE_F16_TEXTURES")&&B.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),B.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=o(e);if(1!==e){if(F(t,"EXT_color_buffer_float"))return O(t);const e="EXT_color_buffer_half_float";if(F(t,e)){const n=t.getExtension(e);return function(e,t){const n=f(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),a}(t,n)}return!1}return!!F(t,"OES_texture_float")&&!!F(t,"WEBGL_color_buffer_float")&&O(t)}(B.getNumber("WEBGL_VERSION")))),B.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=B.getNumber("WEBGL_VERSION"))&&null!=o(e).fenceSync;var e})),B.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>B.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),B.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),B.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>i.C2$.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),B.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),B.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),B.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),B.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),B.registerFlag("WEBGL_EXP_CONV",(()=>!1)),B.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>B.getBool("IS_TEST"))),B.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),B.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),B.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),B.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const V="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:G}=i.backend_util;function H(e,t,n){const r=[];if(e.forEach((e=>{const t=i.D5U.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=te(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t,n=!1,r){let a="";a+=n?X(e,r):j(e,r);const s=e.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,u=G(e.shapeInfo.logicalShape,t.logicalShape),l=ee(o),c=o-s;let d;const h=["x","y","z","w","u","v"];d=0===s?"":o<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+c]}`)).join(", ");let f="return outputValue;";const m=1===i.D5U.sizeFromShape(e.shapeInfo.logicalShape),g=1===i.D5U.sizeFromShape(t.logicalShape);if(1!==s||m||g){if(m&&!g)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const e=s-2,t=s-1;u.indexOf(e)>-1&&u.indexOf(t)>-1?f="return vec4(outputValue.x);":u.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,u=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&u===l&&null==e.shapeInfo.flatOffset&&i.D5U.arraysEqual(o,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const c=ee(l),d=G(e.shapeInfo.logicalShape,t.logicalShape),h=l-u;let p;const f=["x","y","z","w","u","v"];p=0===u?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+h]} = 0;`)).join("\n");let m="";return m=l<2&&u>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${f[t+h]}`)).join(", "),`\n    float ${a}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      return get${r}(${m});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,u=L(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${K}\n    ${q}\n    ${Y}\n  `}(u);return t.isPacked?(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(i.D5U.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[2]/2),a=i*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[e.length-1]/2),a=i*Math.ceil(e[e.length-2]/2);let s=a,o="",u="b, r, c";for(let t=2;t<e.length-1;t++)s*=e[e.length-t-1],o=`\n      int b${t} = index / ${s};\n      index -= b${t} * ${s};\n    `+o,u=`b${t}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return i.D5U.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${M(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=z(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${M(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=z(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=z(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=z(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(h+=Q),[h,l,d,a,c,s,n.userCode].join("\n")}function j(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[i,a]=e.shapeInfo.texShape;if(1===i&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const s=Z(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${u}, ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${J(e)}\n      }\n    `;const i=e.shapeInfo.texShape,a=i[0],s=i[1];if(1===s&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=Z(n);return 1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${s}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&i.D5U.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:u}=i.D5U.squeezeShape(n),l=o;if(l.length<n.length){const n=["row","col"];return`\n      ${j(ne(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${re(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${J(e)}\n      }\n    `;const c=s[0],d=s[1],h=Z(r);return 1===d?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:u,keptDims:l}=i.D5U.squeezeShape(n),c=u;if(c.length<n.length){const n=["row","col","depth"];return`\n        ${j(ne(e,c),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${re(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${J(e)}\n      }\n    `;const d=e.shapeInfo.texShape,h=d[0],p=d[1],f=e.shapeInfo.flatOffset;if(p===s&&null==f)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===o&&null==f)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const m=Z(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${m};\n        vec2 uv = uvFromFlat(${h}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,u=n[1]*o,{newShape:l,keptDims:c}=i.D5U.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${j(ne(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${re(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${u}, ${o}, ${s}, 1)));\n        ${J(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,x=`int stride0 = ${r}Shape[1] * stride1;`;if(f===u&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===s&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=Z(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${g}\n      ${x}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${f}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,o=t[2]*s,u=t[1]*o,{newShape:l,keptDims:c}=i.D5U.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${j(ne(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${re(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${o}, ${s}, ${a})) +\n          depth3;\n        ${J(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${o} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${Z(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=i.D5U.squeezeShape(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${j(ne(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${re(t,s)});\n      }\n    `}const o=t[5],u=t[4]*o,l=t[3]*u,c=t[2]*l,d=t[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${J(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];if(m===d&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===o&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${u} + depth3 * ${o} + depth4 + ${Z(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function X(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${L().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e.shapeInfo.texShape,a=L();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=s[0],u=s[1],l=L();if(null!=s&&i.D5U.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${X(ne(e,n.slice(1)),t)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${re(a,r)});\n        }\n      `}const o=L();if(t)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const u=s[0],l=s[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=L();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,s=a.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=u[0],c=u[1],d=Math.ceil(a[s-1]/2);let h=d*Math.ceil(a[s-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<s-1;e++)p=`int b${e}, `+p,h*=a[s-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const K="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",q="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Y="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Q="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Z(e){return`offset${e}`}function J(e){const t=e.name,n=i.D5U.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function ee(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function te(e,t,n){const{newShape:r,keptDims:a}=i.D5U.squeezeShape(t),s=t.length,o=e&&3===s&&1===t[0],u=o?t.slice(1):r,l=!e&&s>1&&!i.D5U.arraysEqual(t,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?u:t,keptDims:a}}function ne(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function re(e,t){return t.map((t=>e[t])).join(", ")}function ie(e,t,n){const r=[],a=[];let s,o,u,l=null,c=null;c=e.getUniformLocation(n,"NAN",!1),1===(0,i.OBj)().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const d=!1;for(const i of t.variableNames){const a={name:i,uniform:e.getUniformLocation(n,i,d),offset:e.getUniformLocation(n,`offset${i}`,d)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${i}Shape`,d),a.texShape=e.getUniformLocation(n,`${i}TexShape`,d)),r.push(a)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",d),u=e.getUniformLocation(n,"outShapeStrides",d),o=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms)for(const r of t.customUniforms)a.push(e.getUniformLocation(n,r.name,d));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:u,outTexShapeLocation:o}}function ae(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!i.D5U.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const o=e.texShape,u=a.isUniform?null:a.texData.texShape;if(!i.D5U.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)}))}function se(e){return(0,i.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class oe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=u.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=L();this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?M(["r","c","d"],e):z(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class ue{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=u.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=L();this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?M(["r","c","d"],e):z(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class le{constructor(e){this.variableNames=["A"],this.outTexUsage=l.DOWNLOAD;const t=L();this.outputShape=e,this.userCode=`\n      ${V}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class ce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=l.DOWNLOAD;const t=L();this.outputShape=e,this.userCode=`\n      ${V}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const de={R:0,G:1,B:2,A:3};class he{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=L();this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${de[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":W(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class pe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=L();this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let i=0;i<=1;i++){const a=2*t+i;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":W(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${i};\n        }\n    `}}function fe(e,t,n,r,a,s){!function(e,t){const n=(0,i.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const o=function(e){return $(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),u=e.TEXTURE_2D;return m(e,(()=>e.bindTexture(u,o))),m(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),m(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),m(e,(()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST))),m(e,(()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,i.OBj)().getNumber("WEBGL_VERSION")?m(e,(()=>e.texImage2D(u,0,r,t,n,0,a,s,null))):m(e,(()=>e.texStorage2D(u,1,r,t,n))),m(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function me(e){return e.internalFormatFloat}function ge(e){return e.internalFormatHalfFloat}function xe(e){return e.downloadTextureFormat}function be(e){return e.internalFormatPackedFloat}function ye(e){return e.internalFormatPackedHalfFloat}class we{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,i.OBj)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){a[e]=t}(t,e)):this.gl=o(t),e=this.gl,2===(0,i.OBj)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>m(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>m(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>m(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>m(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>m(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>m(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>m(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>m(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,i.OBj)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=x(this.gl,e),F(this.gl,t))this.textureHalfFloatExtension=x(this.gl,t);else if((0,i.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),F(this.gl,r))this.colorBufferHalfFloatExtension=x(this.gl,r);else if((0,i.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",F(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!F(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=$(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return m(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),m(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=$(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return m(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),m(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return $(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=f(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,i.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;m(e,(()=>e.finish())),m(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),m(e,(()=>e.deleteFramebuffer(this.framebuffer))),m(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),m(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),m(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,a]=d(t,n);return fe(e,i,a,me(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,a]=d(t,n);return fe(e,i,a,ge(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,a]=d(t,n);return fe(e,i,a,xe(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){m(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,i.OBj)().getNumber("WEBGL_VERSION")?m(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):m(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,i.OBj)().getNumber("WEBGL_VERSION")?m(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):m(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),m(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let o,u,l;m(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),u=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*r*4),u=e.FLOAT,l=s.internalFormatPackedFloat),o.set(a),2===(0,i.OBj)().getNumber("WEBGL_VERSION")?m(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,u,o))):m(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,u,o))),m(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,a]=p(t,n);return fe(e,i,a,ye(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,a]=p(t,n);return fe(e,i,a,be(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(I(this.gl,this.framebuffer),this.outputTexture=null),m(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[i,a]=d(t,n),s=new Uint8Array(t*n*4);return m(e,(()=>e.readPixels(0,0,i,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,i,a){return function(e,t,n,r,i,a,s,o){const u=e,l=new Float32Array(function(e,t){const[n,r]=p(e,t);return n*r*4}(a,s));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const i=e.createBuffer();m(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i)));const a=16*t*n;return m(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),m(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),m(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),i}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,i.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return m(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function(e){const t=L();return function(e,t){const n=$(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(m(e,(()=>e.shaderSource(n,t))),m(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const n=function(e){return $(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);m(t,(()=>t.attachShader(n,this.vertexShader))),m(t,(()=>t.attachShader(n,e))),function(e,t){if(m(e,(()=>e.linkProgram(t))),!(0,i.OBj)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&w(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;m(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){m(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),v(e,t,"clipSpacePos",n,3,20,0)&&v(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(m(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&w(this.gl,this.program),m(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return $(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),m(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),k(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=p(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&w(this.gl,this.program),S(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}m(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),m(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=x(this.gl,2===(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await i.D5U.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in(0,i.OBj)().platform&&(n=(0,i.OBj)().platform.setTimeoutCustom.bind((0,i.OBj)().platform)),i.D5U.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),C(this.gl,e,this.framebuffer),this.debug&&S(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(C(this.gl,this.outputTexture,this.framebuffer),this.debug&&S(this.gl)):I(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;C(r,e,this.framebuffer),this.debug&&S(r),this.outputTexture=e,m(r,(()=>r.viewport(0,0,t,n))),m(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),m(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function ve(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function ke(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function Ce(e){return(t,n,r,a,s)=>{const o=i.backend_util.assertAndGetBroadcastShape(t,n),u=o.length,l=i.D5U.computeStrides(o),c=i.D5U.sizeFromShape(o),d=i.D5U.getTypedArrayFromDType(s,c),h=t.length,p=n.length,f=i.D5U.computeStrides(t),m=i.D5U.computeStrides(n),g=i.backend_util.getBroadcastDims(t,o),x=i.backend_util.getBroadcastDims(n,o);if(g.length+x.length===0)for(let t=0;t<d.length;++t)d[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<d.length;++t){const n=i.D5U.indexToLoc(t,u,l),s=n.slice(-h);g.forEach((e=>s[e]=0));const o=i.D5U.locToIndex(s,h,f),c=n.slice(-p);x.forEach((e=>c[e]=0));const b=i.D5U.locToIndex(c,p,m);d[t]=e(r[o],a[b])}return[d,o]}}function Ie(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(i.shape,"float32",s)},o}function Se(e,t,n="float32"){if("complex64"===n)return Ie({inputs:{real:Se(e,t,"float32"),imag:Se(e,t,"float32")},backend:e});const r=i.D5U.makeZerosTypedArray(i.D5U.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function $e(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Re(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=i.D5U.toTypedArray([0],n),[a,s]=Ce(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Te(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return $e({inputs:{x:a},backend:n});const e=Se(n,a.shape,a.dtype),t=Te({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Ie({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=function(e){const{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}({inputs:{input:a},backend:n}),t=Te({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!i.D5U.hasEncodingLoss(a.dtype,s)){const e=$e({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const o=n.data.get(a.dataId).values,[u,l,c]=Re(o,a.shape,a.dtype,s);return n.makeTensorInfo(u,l,c)}function Ae(e,t,n,r){return null==n?({inputs:n,backend:a})=>{const{a:s,b:o}=n,u=a;ve([s,o],e);const l=u.data.get(s.dataId).values,c=u.data.get(o.dataId).values,d="string"===s.dtype?i.backend_util.fromUint8ToStringArray(l):l,h="string"===s.dtype?i.backend_util.fromUint8ToStringArray(c):c,p=r||s.dtype,[f,m]=t(s.shape,o.shape,d,h,p);return u.makeTensorInfo(m,p,f)}:({inputs:e,backend:i})=>{const{a,b:s}=e,o=i;if("complex64"===a.dtype||"complex64"===s.dtype){const e=Te({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,i=t.complexTensorInfos.imag,u=o.data.get(r.dataId).values,l=o.data.get(i.dataId).values,c=Te({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=o.data.get(h.dataId).values,m=o.data.get(p.dataId).values,[g,x,b]=n(a.shape,s.shape,u,l,f,m),y=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",x),v=Ie({inputs:{real:y,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(w),v}{const e=o.data.get(a.dataId).values,n=o.data.get(s.dataId).values,i=r||a.dtype,[u,l]=t(a.shape,s.shape,e,n,i);return o.makeTensorInfo(l,i,u)}}}function Ee(e){return(t,n,r,a,s,o)=>{const u=i.backend_util.assertAndGetBroadcastShape(t,n),l=i.D5U.sizeFromShape(u),c=u.length,d=i.D5U.computeStrides(u),h=i.D5U.getTypedArrayFromDType("float32",l),p=i.D5U.getTypedArrayFromDType("float32",l),f=i.backend_util.getBroadcastDims(t,u),m=i.backend_util.getBroadcastDims(n,u),g=i.backend_util.mergeRealAndImagArrays(r,a),x=i.backend_util.mergeRealAndImagArrays(s,o),b=t.length,y=i.D5U.computeStrides(t),w=n.length,v=i.D5U.computeStrides(n);if(f.length+m.length===0)for(let t=0;t<h.length;t++){const n=t%g.length,r=t%x.length,i=e(g[2*n],g[2*n+1],x[2*r],x[2*r+1]);h[t]=i.real,p[t]=i.imag}else for(let t=0;t<h.length;t++){const n=i.D5U.indexToLoc(t,c,d),r=n.slice(-b);f.forEach((e=>r[e]=0));const a=i.D5U.locToIndex(r,b,y),s=n.slice(-w);m.forEach((e=>s[e]=0));const o=i.D5U.locToIndex(s,w,v),u=e(g[2*a],g[2*a+1],x[2*o],x[2*o+1]);h[t]=u.real,p[t]=u.imag}return[h,p,u]}}i.SYM,i.Zz9,i.iJz,i.xJR,i.RFZ;const Ne=Ce(((e,t)=>e+t)),De=Ee(((e,t,n,r)=>({real:e+n,imag:t+r})));function _e(e,t,n,r,a){const s=i.D5U.sizeFromShape(r),o=i.D5U.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(o[r]+=s>0?t[n]:1)}return o}function Fe(e,t,n,r=!1){const a=e.shape[0],s=e.shape[1],o=(0,i.f3b)([a,n],t.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=e.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}Ae(i.mm_,Ne,De),i.mm_;const Pe=Ce(((e,t)=>e&t));function Oe(e){return(t,n,r)=>{const a=i.D5U.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}function Ue(e,t,n){return Be(e,Oe(t),n)}function Be(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;ve(o,e);const u=s,l=u.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=i.backend_util.fromUint8ToStringArray(l)}else c=l;const d=n||o.dtype,h=t(c,d,a);return u.makeTensorInfo(o.shape,d,h)}}Ae(i.hCO,Pe),i.hCO;const Le=Oe((e=>Math.ceil(e)));function ze(e,t,n,r){const a=i.D5U.getArrayFromDType(n,i.D5U.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=i.D5U.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?i.backend_util.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[i+t]=s[o++]}r+=e.shape[1]}))}return a}Be(i.gJX,Le),i.gJX;const Me=Ce(((e,t)=>e===t?1:0)),We=(Ae(i.hdR,Me,null,"bool"),i.hdR,Oe((e=>Math.exp(e)))),Ve=(Be(i.NEP,We,"float32"),i.NEP,Oe((e=>Math.expm1(e)))),Ge=(Be(i.Y0y,Ve),i.Y0y,Oe((e=>Math.floor(e))));function He(e,t,n,r,a,s,o,u,l){const c=(0,i.f3b)([r,s],n);for(let n=0;n<r;n++){const r=[];let i=0;for(let t=0;t<a;t++){const s=e[n*a+t];i+=s*o[t],r.push(s)}if(i<0||i>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<s;e++)c.values[n*s+e]=t.get(...t.indexToLoc(i*s+e))}return c}function je(e,t,n){const r=(0,i.f3b)(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),a=i[0],s=i[2],o=t.locToIndex([a,s]);i[2]=t.values[o];const u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r}Be(i.OR,Ge),i.OR;const Xe=Ce(((e,t)=>e>t?1:0)),Ke=(Ae(i.iZT,Xe,null,"bool"),i.iZT,Ce(((e,t)=>e>=t?1:0))),qe=(Ae(i.Acj,Ke,null,"bool"),i.Acj,Ce(((e,t)=>e<t?1:0))),Ye=(Ae(i.vtC,qe,null,"bool"),i.vtC,Ce(((e,t)=>e<=t?1:0)));function Qe(e,t,n){const r=(t-e)/(n-1),a=i.D5U.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a}Ae(i.CAk,Ye,null,"bool"),i.CAk;const Ze=Oe((e=>Math.log(e)));function Je(e,t,n,r){const a=i.D5U.getTypedArrayFromDType(r,i.D5U.sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let i=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>i)&&(i=t)}a[n]=i}return a}Be(i.ZbH,Ze),i.ZbH;const et=Ce(((e,t)=>Math.max(e,t))),tt=(Ae(i.BMI,et),i.BMI,Ce(((e,t)=>Math.min(e,t)))),nt=(Ae(i.q8u,tt),i.q8u,Ce(((e,t)=>e*t))),rt=Ee(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));function it(e,t,n){const r=i.D5U.createScalarValue(-1,n);return nt([],t,r,e,n)}Ae(i.wYn,nt,rt),i.wYn,i.kuV;const at=Ce(((e,t)=>e!==t?1:0));function st(e,t,n,r,a){const s=t.length,o=i.D5U.sizeFromShape(t),u=i.D5U.computeStrides(t),l=i.D5U.computeStrides(a),c=i.D5U.getTypedArrayFromDType(n,i.D5U.sizeFromShape(a));for(let t=0;t<o;++t){const n=i.D5U.indexToLoc(t,s,u),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];c[i.D5U.locToIndex(a,s,l)]=e[t]}return c}function ot(e,t,n,r){const[a,s]=i.backend_util.computeOutAndReduceShapes(e,r),o=(0,i.x8V)(t,"int32"),u=i.D5U.makeZerosTypedArray(i.D5U.sizeFromShape(a),o),l=i.D5U.sizeFromShape(s);for(let e=0;e<u.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];u[e]=r}return{outVals:u,outShape:a,outDtype:o}}function ut(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function lt(e,t,n,r,a,s,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=i.D5U.indexToLoc(r,t.length,i.D5U.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:d,numValues:h}=function(e,t,n,r){const i=[];let a=0;const s=t.length-1+n.length,o=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let s=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=o[i],t=e[e.length-1]-r[s];for(let e=s;e<u;++e)o[i].push(r[e+1]+t)}s=r[s],u=r[u]}u!==s&&(i.push([s,u]),a+=u-s)}return{outSplits:o,valueSlices:i,numValues:a}}(s,o,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,a=i.D5U.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(c),f=function(e,t,n,r,a){const s=t.slice();s[0]=a;const o=i.D5U.getArrayFromDType(n,i.D5U.sizeFromShape(s)),u=e.length;return function(e,t,n,r,i,a){const s=ut(t,2)[1],o=ut(a,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[u*o+t]=e[n*s+t];++u}}(e,t,r,0===u?0:u/t[0],o,s),[o,s]}(n,r,a,d,h);return[p,f[0],f[1]]}Ae(i.yQU,at,null,"bool"),i.yQU,i.G3Y,i.DlI;const ct=2147483647;function dt(e,t,n,r,a,s,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,l=0===a.length,c=0===o.length,d=[];u||d.push(t[0]),l||d.push(a[0]),c||d.push(o[0]);for(let e=1;e<d.length;++e)if(d[e]!==d[e-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===d.length?1:d[0],p=i.D5U.getArrayFromDType("int32",h+1);p[0]=0;for(let t=0;t<h;++t){const n=u?e[0]:e[t],i=l?r[0]:r[t],a=c?s[0]:s[t];if(0===a)throw new Error("Requires delta != 0");let o;if(a>0&&i<n||a<0&&i>n)o=0;else if(o=Math.ceil(Math.abs((i-n)/a)),o>ct)throw new Error(`Requires ((limit - start) / delta) <= ${ct}`);p[t+1]=p[t]+o}const f=p[h],m=i.D5U.getArrayFromDType(n,f);let g=0;for(let t=0;t<h;++t){const n=p[t+1]-p[t];let r=u?e[0]:e[t];const i=c?s[0]:s[t];for(let e=0;e<n;++e)m[g++]=r,r+=i}return[p,m]}var ht=i.backend_util.RowPartitionType;class pt{constructor(e,t,n,r,a,s,o,u,l,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=i.backend_util.getRowPartitionTypesHelper(c),this.raggedRank=i.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ht.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ht.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ht.VALUE_ROWIDS:return pt.getMaxWidthValueRowID(t);case ht.ROW_SPLITS:return pt.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ht[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],i=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,i=Math.max(a-n,i),n=a)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return mt(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;i.backend_util.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=i.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let e=0;e<r;++e,s+=t)a.push(s);for(let t=r;t<e;++t)a.push(-1);return i.D5U.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const i=e.length,a=[];for(let s=0;s<i-1;++s){const i=e[s+1]-e[s];let o=Math.min(r,i),u=t[s];-1===u&&(o=0);for(let e=0;e<o;++e)a.push(u),u+=n;for(let e=0;e<i-o;++e)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const i=e.length,a=[];if(0===i)return[];let s=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];a.push(u);for(let l=1;l<i;++l){const i=e[l];if(i===o)u>=0&&(++s,s<r?u+=n:u=-1);else{if(s=0,o=i,i>=t.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);u=t[i]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case ht.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case ht.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw new Error(`Unsupported partition type: ${ht[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ht.FIRST_DIM_SIZE:return e[0];case ht.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ht.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ht[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=mt(t,!1),a=i.D5U.getArrayFromDType(this.valuesDType,i.D5U.sizeFromShape(r));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)i=this.calculateOutputIndex(e-1,i,n[e],t[e]);this.setOutput(this.raggedRank,i,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let o=r.slice();o=o.slice(e+1);const u=i.D5U.sizeFromShape(o),l=t.length;let c=this.defaultValue;if(c.length!==u&&1!==c.length){const e=this.defaultValueShape;(0,i.lub)((()=>{const t=(0,i.XLQ)(c,e),n=(0,i.UFq)(t,o);c=n.dataSync()}))}let d=0,h=0,p=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==p){if(h<p){const e=a.subarray(d*u);ft(s.subarray(h*u),e,(p-h)*u)}if(e>=l){const e=n.length;r=Math.floor(e/u)}if(r>p)if(1===this.defaultValue.length)s.subarray(p*u,r*u).fill(this.defaultValue[0]),p=r;else for(;r>p;)ft(s.slice(p*u),c,u),++p;r<0?(d=e+1,h=p):(d=e,h=p,p=h+1)}else++p}}}function ft(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function mt(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function gt(e,t,n,r,i,a,s,o,u,l){return new pt(e,t,n,r,i,a,s,o,u,l).compute()}function xt(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return i.D5U.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((t-e)/n)),s=i.D5U.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const bt=Oe((e=>1/Math.sqrt(e)));function yt(e,t,n,r,a,s,o,u,l,c){const d=[r/a,a],h=e.values,p=t.values;if(0===r)return(0,i.f3b)(n,t.dtype);const f=l instanceof i.YDk?l:(0,i.f3b)(d,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<s;e++){const i=[];let s=0;for(let t=0;t<o;t++){const n=h[e*o+t];i.push(n),s+=n*u[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${i} does not index into ${n}`);for(let n=0;n<a;n++)c?f.values[s*a+n]+=p[e*a+n]:f.values[s*a+n]=0===t.rank?p[0]:p[e*a+n]}return f}Be(i.bV0,bt),i.bV0;const wt=Oe((e=>1/(1+Math.exp(-e))));function vt(e,t,n,r,a){const s=i.kuN.isSliceContinous(r,t,n),o=i.D5U.sizeFromShape(n),u=i.D5U.computeStrides(r);if(s){const n=i.kuN.computeFlatOffset(t,u);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const l="string"===a?i.backend_util.fromUint8ToStringArray(e):e,c=(0,i.f3b)(r,a,l),d=(0,i.f3b)(n,a);for(let e=0;e<d.size;++e){const n=d.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));d.set(c.get(...r),...n)}return"string"===a?i.backend_util.fromStringArrayToUint8(d.values):d.values}function kt(e,t,n,r,a,s,o){const u=t[0],l=s[0],c=new Array(l),d=new Array(u),h=t[1];if(0===l){if(0!==u)throw new Error(i.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[i.D5U.getArrayFromDType(n,0),[0,h],i.D5U.getArrayFromDType(a,0),c,d]}let p=!0,f=0;const m=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*h];if(n<0)throw new Error(i.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(i.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++m[n],p=p&&n>=f,f=n}let g=!0;for(let e=0;e<l;++e){const t=0===m[e];c[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=r;for(let e=0;e<u;++e)d[e]=e;return[t,[u,h],n,c,d]}{const t=m[l-1],s=i.D5U.getArrayFromDType(n,t*h),p=i.D5U.getArrayFromDType(a,t),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*h],i=f[n],a=(0===n?0:m[n-1])+i;f[n]++;for(let n=0;n<h;++n)s[a*h+n]=e[t*h+n];p[a]=r[t],d[t]=a}for(let e=0;e<l;++e)if(0===f[e]){const t=0===e?0:m[e-1];s[t*h+0]=e;for(let e=1;e<h;++e)s[t*h+e]=0;p[t]=o}return[s,[t,h],p,c,d]}}function Ct(e,t,n,r,a){const s=i.D5U.sizeFromShape(r),o=t[0],u=a.length,l=[];let c=1,d=-1;for(let e=0;e<u;++e){const t=a[e];if(-1===t){if(-1!==d)throw new Error(i.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,e));d=e,l.push(1)}else{if(t<0)throw new Error(i.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,t));c*=t,l.push(t)}}if(-1!==d){if(c<=0)throw new Error(i.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(s/c);if(c*e!==s)throw new Error(i.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[d]=e}if(i.D5U.sizeFromShape(l)!==s)throw new Error(i.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let e=h-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=i.D5U.getArrayFromDType(n,o*u);for(let t=0;t<o;++t){let n=0;for(let r=0;r<h;++r)n+=e[t*h+r]*p[r];for(let e=0;e<u;++e)m[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[o,u],l]}function It(e,t,n,r,a,s=!1,o=0){const u=r.length,l=[t[0],e.length/t[0]],c=l[1],d=u>0?a[u-1]+1:0;if(d<0)throw new Error(i.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=d;const p=h.reduce(((e,t)=>e*t),1),f=i.D5U.getArrayFromDType(n,p);if(0===u)return d>0&&f.fill(o),[f,h];if(d<=0)throw new Error(i.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,x=0,b=a[m];for(;;){let t=0;if(g<u){if(t=a[g],b===t){++g;continue}if(b>=t)throw new Error(i.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=d)throw new Error(i.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,d));b>x&&f.fill(o,x*c,b*c);for(let t=m;t<g;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(i.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<c;t++)f[b*c+t]+=e[n*c+t]}if(s)for(let e=0;e<c;e++)f[b*c+e]/=g-m;if(m=g,++g,x=b+1,b=t,g>u)break}return x<d&&f.fill(o,x*c,d*c),[f,h]}Ue(i.a5O,(e=>1/(1+Math.exp(-e)))),i.a5O,i.p2w;const St=Oe((e=>Math.sqrt(e))),$t=(Ue(i.FKq,(e=>Math.sqrt(e))),i.FKq,Oe(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:i}=t;return e.replace(new RegExp(n,r?"g":""),i)})));function Rt(e,t,n,r){const a=(0,i.f3b)(e,t.dtype);for(let e=0;e<a.size;e++){const i=a.indexToLoc(e),s=new Array(i.length);for(let e=0;e<s.length;e++)s[e]=i[e]*n[e]+r[e];a.set(t.get(...s),...i)}return a}Be(i.e0R,$t),i.e0R;class Tt{constructor(e,t,n,r,a,s){this.separator=i.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=i.D5U.encodeString(n),this.rightPad=i.D5U.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,a){for(let s=0;s<i;++s){const o=this.getPadWidth(a),u=Math.max(0,o-s),l=Math.max(0,o-(i-(s+1))),c=a-(u+l),d=t+(u>0?0:s-o);let h=0;h+=u*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=l*this.rightPad.length,h+=(u+l+c-1)*this.separator.length,n[r+s]=new Uint8Array(h);const p=n[r+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let i=1;i<r;++i){let r=t[i]>=e;if(r=r&&t[i]<=n,!r)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=i.D5U.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}const o=new Array(s[a]);for(let n=0;n<a;++n){const r=t[n];let i=s[n];if(this.nGramWidths.forEach((a=>{const s=t[n+1]-t[n],u=this.getNumNGrams(s,a);this.createNGrams(e,r,o,i,u,a),i+=u})),this.preserveShort&&i===s[n]){const a=t[n+1]-t[n];if(0===a)continue;const s=a+2*this.padWidth,u=1;this.createNGrams(e,r,o,i,u,s)}}return[o,s]}}function At(e,t,n,r,i,a,s,o){return new Tt(n,r,i,a,s,o).compute(e,t)}function Et(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let a=e.indexOf(i);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(i,a);n&&0===t.length||r.push(t),i=a+1}}function Nt(e,t,n){const r=e.length,a=[];let s=0,o=0;const u=new Array(r);for(let i=0;i<r;++i){const r=a.length;Et(e[i],t,n,a);const l=a.length-r;u[i]=l,s+=l,o=Math.max(o,l)}const l=i.D5U.getArrayFromDType("int32",2*s),c=new Array(s),d=[r,o];let h=0;for(let e=0;e<r;++e)for(let t=0;t<u[e];++t)l[2*h]=e,l[2*h+1]=t,c[h]=a[h],++h;return[l,c,d]}function Dt(e,t){const n=i.D5U.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=i.D5U.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}const _t=Ce(((e,t)=>e-t)),Ft=Ee(((e,t,n,r)=>({real:e-n,imag:t-r})));function Pt(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=(0,i.f3b)(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const a=e.locToIndex(i);r.values[t]=e.values[a]}return r}Ae(i.Tr8,_t,Ft),i.Tr8;const Ot=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Ut(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,a=t-n+1,s=Math.log(i),o=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*o*(i-o)/i)*Math.sign(a-i/2);Ut(e,t,Math.max(n,Math.floor(t-a*o/i+u)),Math.min(r,Math.floor(t+(i-a)*o/i+u)))}const a=e[t];let s=n,o=r;for(i.D5U.swap(e,n,t),Ot(e[r],a)>0&&i.D5U.swap(e,n,r);s<o;){for(i.D5U.swap(e,s,o),s++,o--;Ot(e[s],a)<0;)s+=1;for(;Ot(e[o],a)>0;)o-=1}0===Ot(e[n],a)?i.D5U.swap(e,n,o):(o+=1,i.D5U.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function Bt(e,t,n,r,a){const s=t[t.length-1],[o,u]=[e.length/s,s],l=i.D5U.getTypedArrayFromDType(n,o*r),c=i.D5U.getTypedArrayFromDType("int32",o*r);for(let t=0;t<o;t++){const n=t*u,i=e.subarray(n,n+u);let s=new Array(i.length);i.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(Ut(s,r),s=s.slice(0,r)),a&&s.sort(Ot);const o=t*r,d=l.subarray(o,o+r),h=c.subarray(o,o+r);for(let e=0;e<r;e++)d[e]=s[e].value,h[e]=s[e].index}const d=t.slice();return d[d.length-1]=r,[(0,i.f3b)(d,n,l),(0,i.f3b)(d,"int32",c)]}function Lt(e,t,n,r){const a=i.D5U.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];const o=new Map,u=new Int32Array(n[a]),l=new i.YDk(s,r,e),c=[],d=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}const r=o.get(n);if(null!=r)u[t]=r;else{const e=o.size;o.set(n,e),u[t]=e,c.push(t)}}const h=s.slice();h[1]=o.size;const p=new i.YDk(h,r);c.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[a]=h[1],{outputValues:p.values,outputShape:f,indices:u}}const{addImpl:zt,bincountImpl:Mt,bincountReduceImpl:Wt,bitwiseAndImpl:Vt,castImpl:Gt,ceilImpl:Ht,concatImpl:jt,equalImpl:Xt,expImpl:Kt,expm1Impl:qt,floorImpl:Yt,gatherNdImpl:Qt,gatherV2Impl:Zt,greaterImpl:Jt,greaterEqualImpl:en,lessImpl:tn,lessEqualImpl:nn,linSpaceImpl:rn,logImpl:an,maxImpl:sn,maximumImpl:on,minimumImpl:un,multiplyImpl:ln,negImpl:cn,notEqualImpl:dn,prodImpl:hn,raggedGatherImpl:pn,raggedRangeImpl:fn,raggedTensorToTensorImpl:mn,rangeImpl:gn,rsqrtImpl:xn,scatterImpl:bn,sigmoidImpl:yn,simpleAbsImpl:wn,sliceImpl:vn,sparseFillEmptyRowsImpl:kn,sparseReshapeImpl:Cn,sparseSegmentReductionImpl:In,sqrtImpl:Sn,staticRegexReplaceImpl:$n,stridedSliceImpl:Rn,stringNGramsImpl:Tn,stringSplitImpl:An,stringToHashBucketFastImpl:En,subImpl:Nn,tileImpl:Dn,topKImpl:_n,transposeImpl:Fn,uniqueImpl:Pn}=r;function On(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Un(e,t){return 1===t?[e]:On(e,t)}class Bn{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=se(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Un("rc",this.rank),t=ee(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)i=`${e[e.length-1-t]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class Ln{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,i;this.userCode=`\n      ${r=t,i=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${i?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}(e.map(((e,t)=>t)),t);return r.map(((t,i)=>`int ${e[i]} = ${n} / ${r[i]}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`};`)).join("")}(["r","c","d"],"inputShape"):z(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":W(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class zn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=Wn(t,n),i=Vn(e,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=Mn(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[i].pop();return this.usedTextures[i].push(e),e}let s;return r===c.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===c.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===c.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===c.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===c.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(s),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=Wn(n,r),s=Vn(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=Mn(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=(0,i.OBj)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l&&l.indexOf(e);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Mn(e,t,n,r,i){const a=function(e,t){switch(e){case c.PACKED_2X2_FLOAT32:return be(t);case c.PACKED_2X2_FLOAT16:return ye(t);case c.UNPACKED_FLOAT32:return me(t);case c.UNPACKED_FLOAT16:return ge(t);case c.PACKED_4X1_UNSIGNED_BYTE:return xe(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let s;if(i){const[t,n]=p(e[0],e[1]);s=t*n}else{const[t,n]=d(e[0],e[1]);s=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return s*o}function Wn(e,t){if(e===l.UPLOAD)return c.PACKED_2X2_FLOAT32;if(e===l.RENDER||null==e)return function(e){return(0,i.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?c.PACKED_2X2_FLOAT32:c.UNPACKED_FLOAT32:e?c.PACKED_2X2_FLOAT16:c.UNPACKED_FLOAT16}(t);if(e===l.DOWNLOAD||e===l.PIXELS)return c.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Vn(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Gn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Hn="if (isnan(x)) return x;",jn="return x;",Xn="return abs(x);",Kn="return (x >= 0.0) ? x : (exp(x) - 1.0);",qn=Hn+"\n  return (x < 0.0) ? 0.0 : x;\n",Yn=Hn+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Qn="return x;",Zn="return 1.0 / (1.0 + exp(-1.0 * x));",Jn="return x;",er="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",tr="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",nr="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",rr="return 1.0 / (1.0 + exp(-1.0 * x));";class ir{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class ar{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length);const t=e.length,n=Un("rc",t),r=ee(t),i=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),s=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}}const sr=i.GDt.whereImpl,or={},ur=(0,i.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class lr extends i.Zuw{nextDataId(){return lr.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,i.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof we)t=e;else{const n=o((0,i.OBj)().getNumber("WEBGL_VERSION"),e);t=new we(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=o((0,i.OBj)().getNumber("WEBGL_VERSION"));t=new we(e),this.binaryCache=((n=(0,i.OBj)().getNumber("WEBGL_VERSION"))in or||(or[n]={}),or[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zn(this.gpgpu),this.numMBBeforeWarning=null==(0,i.OBj)().global.screen?1024:(0,i.OBj)().global.screen.height*(0,i.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new i.JLz(this,(0,i.SRH)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,i,a){const s=this.makeTensorInfo(t,n),o=this.texData.get(s.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,i]},o.texShape=[r,i];const u=A(t),l=new he(u,!1,a),c=this.runWebGLProgram(l,[s],n,[[r,i]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(s),c.dataId}write(e,t,n){if(((0,i.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,i.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:l.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,a){if((0,i.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:l.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:u}=t;if(null!=s){let t;t=u?new ir(o,Qn):new Gn(o,Qn);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),i=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let c,d;if(l&&(c=i.D5U.now()),"complex64"===r){const e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);d=i.backend_util.mergeRealAndImagArrays(e,t)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=i.D5U.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:u}=t;if(null!=a){let t;t=u?new ir(r,Qn):new Gn(r,Qn);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),i=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,i.OBj)().getBool("DEBUG")&&!(0,i.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,i.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if("complex64"!==s&&(0,i.OBj)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...h(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];c=i.backend_util.mergeRealAndImagArrays(t,n)}else if(null==d)c=this.getValuesFromTexture(e);else{const e=i.D5U.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=d){const e=this.gpgpu.gl;m(e,(()=>e.deleteBuffer(d)))}const p=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach((e=>e(p))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,i.SRH)().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:o,isPacked:u,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=u?new ir(a,Qn):new Gn(a,Qn);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:o}],o),i=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),i}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),d=(0,i.SRH)().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>i.D5U.decodeString(e)));return(0,i.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,i.f3b)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!g(n)){if((0,i.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=i.D5U.sizeFromShape(t);if((0,i.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...h(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),i}const s=(0,i.OBj)().getBool("WEBGL_PACK")&&!0===r,o=s?A(t):t,u=s?new ce(o):new le(o),l=this.runWebGLProgram(u,[{shape:o,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=i.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=i.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);o.kernelMs=i.D5U.sum(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:i.D5U.now(),endMs:null}}endTimer(e){return(0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=i.D5U.now(),e)}async getQueryTime(e){if((0,i.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:i,isPacked:a,slice:s}=this.texData.get(e),o=s&&s.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,i,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=ur){return(0,i.OBj)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&i.D5U.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){i.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return sr(e.shape,t)}packedUnaryOp(e,t,n){const r=new ir(e.shape,t),a=this.compileAndRun(r,[e],n);return(0,i.SRH)().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=wn(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,i.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Xn,e.dtype);const t=new Gn(e.shape,Xn),n=this.compileAndRun(t,[e]);return(0,i.SRH)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&i.D5U.isString(n[0])){const a=n.map((e=>i.D5U.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return(0,i.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new ar(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Bn(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[R(e.shape),...T(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},i=[R(t),...T(t)],a=new Ln(i,n),s=[n],o=this.runWebGLProgram(a,[r],e.dtype,s,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){const e=i.D5U.sizeFromShape(a),n=t[0]*t[1]*4;i.D5U.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=A(a);let u;u=r?new ue(o):new oe(o);const l=[null!=t?t:h(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,a=!1,s){const o=this.makeTensorInfo(e.outputShape,n),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===u.DENSE){const t=null!=s?s:h(e.outputShape);l.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===i.D5U.sizeFromShape(o.shape))return l.values=i.D5U.getTypedArrayFromDType(o.dtype,0),o;const c=[],d=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&i.D5U.sizeFromShape(t.shape)<=(0,i.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!N(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),c.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const p={shape:o.shape,texData:l,isUniform:!1},f=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:u,keptDims:l}=te(e.packedInputs,t.shape,s);let c="",d="",h="";if(1===u.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==u.length||e.packedInputs){if(u.length>2&&!e.packedInputs){const e=i.D5U.computeStrides(u);h=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else d=`${u[0]>1}_${u[1]>1}`;const p=t.shape.length,f=2===u.length&&i.D5U.arraysEqual(t.shape,s),m=1===i.D5U.sizeFromShape(t.shape),g=i.backend_util.getBroadcastDims(t.shape,n.shape),x=!e.packedInputs&&p===n.shape.length&&i.D5U.arraysEqual(s,n.texData.texShape),b=e.packedInputs||u.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${p}_${x}_${o?l:""}_${u.length}_${m}_${g}_${f}_${c}_${d}_${h}_${b}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${(0,i.OBj)().getNumber("WEBGL_VERSION")}`,s}(e,d,p),g=this.getAndSaveBinary(f,(()=>function(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=H(a,o,t),l=function(e,t){const n=$(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(m(e,(()=>e.shaderSource(n,t))),m(e,(()=>e.compileShader(n))),(0,i.OBj)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw y(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,u),c=e.createProgram(l);return(0,i.OBj)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},ie(e,t,c)))}(this.gpgpu,e,d,p))),x=null!=this.activeTimers;let b;x&&(b=this.startTimer()),(0,i.OBj)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(ae(t.inShapeInfos,n),ae([t.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):e.setOutputMatrixTexture(s.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,i.OBj)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const a=n[r],{uniform:s,offset:o,shape:u,texShape:l}=t.variablesLocations[r];if(u){const{uniformShape:n}=te(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(u,new Int32Array(n));break;case 2:e.gl.uniform2iv(u,new Int32Array(n));break;case 3:e.gl.uniform3iv(u,new Int32Array(n));break;case 4:e.gl.uniform4iv(u,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,a.texData.texShape[0],a.texData.texShape[1]),null!=s)if(a.isUniform)if(i.D5U.sizeFromShape(a.shape)<2)e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,r)}const u=t.outShapeLocation;if(u)switch(r.shape.length){case 1:e.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(u,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=i.D5U.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],i=t.customUniformLocations[n],s=a[n];if("float"===r.type)e.gl.uniform1fv(i,s);else if("vec2"===r.type)e.gl.uniform2fv(i,s);else if("vec3"===r.type)e.gl.uniform3fv(i,s);else if("vec4"===r.type)e.gl.uniform4fv(i,s);else if("int"===r.type)e.gl.uniform1iv(i,s);else if("ivec2"===r.type)e.gl.uniform2iv(i,s);else if("ivec3"===r.type)e.gl.uniform3iv(i,s);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(i,s)}}e.executeProgram()}(this.gpgpu,g,d,p,r),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),x&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const w=(0,i.OBj)().get("WEBGL_FLUSH_THRESHOLD");if(w>0){const e=i.D5U.now();e-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,i.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===a){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,i=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,i.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,i.lub)((()=>{if(!(0,i.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,i.OBj)().getBool("DEBUG");(0,i.OBj)().set("DEBUG",!1);const t=this.abs((0,i.iD$)(1e-8)).dataSync()[0];if((0,i.OBj)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:u}=t;if(null!=s)return;const c=null!=this.activeTimers;let d;c&&(d=i.D5U.now());let h=t.texShape;if(null==h&&(h=function(e,t=!1){let n=(0,i.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,i.OBj)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&(0,i.OBj)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?i.D5U.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=i.D5U.squeezeShape(e);e=t.newShape}let a=i.D5U.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||o)if(t){const t=R(e);let n=2,r=2;e.length&&([n,r]=T(e)),a=t*(n/2)*(r/2),s=i.D5U.sizeToSquarishShape(a).map((e=>2*e))}else s=i.D5U.sizeToSquarishShape(a);return s}(n,u),t.texShape=h),null!=a){const e=A(n);let s,o=h[1],f=h[0];const m=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!u&&m||([o,f]=p(h[0],h[1])),s=u?new pe(e,m):new he(e,m);const g=m?[f,o]:h,x=this.makeTensorInfo(g,r),b=this.texData.get(x.dataId);b.usage=m?l.PIXELS:l.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),o,f,a);const y=[[f,o]],w=!0,v=this.runWebGLProgram(s,[x],r,y,w),k=this.texData.get(v.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,(0,i.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(x),c&&(this.uploadWaitMs+=i.D5U.now()-d)}else{const e=this.acquireTexture(h,o,r,u);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*i.D5U.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,i.glt)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw y(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:s,outTexShapeLocation:o}=ie(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=s,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:s,channels:o}=e,u=(0,i.SRH)().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(r,t,n,a,s,o);return(0,i.SRH)().makeTensorFromDataId(l,t,n,u)}}lr.nextDataId=0,i.C2$.isBrowser()&&(0,i.jqO)("webgl",(()=>new lr),2);const cr="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class dr{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=se(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const hr="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class pr{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=se(a);let s="";if(r)if(0===a||1===i.D5U.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${ee(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Un("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function fr(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const mr={kernelName:i.iJz,backendName:"webgl",kernelFunc:fr};function gr(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.makeTensorInfo(r.shape,"complex64"),s=n.texData.get(a.dataId),o=fr({inputs:{x:r},backend:n}),u=fr({inputs:{x:i},backend:n});return s.complexTensorInfos={real:o,imag:u},a}const xr={kernelName:i.Zz9,backendName:"webgl",kernelFunc:gr},br="return (a < 0.) ? b * a : a;",yr="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",wr={kernelName:i.J$2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,o=n.makeTensorInfo([],"float32",i.D5U.createScalarValue(s,"float32")),u=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pr(yr,a.shape,o.shape):new dr(br,a.shape,o.shape),l=n.runWebGLProgram(u,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},vr="return (a < 0.) ? b * a : a;",kr="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Cr={kernelName:i.o0g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pr(kr,r.shape,a.shape):new dr(vr,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},Ir="if (isnan(x)) return x;";function Sr({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a,u=s,l=r||o.dtype;if(u.shouldExecuteOnCPU([o])&&null!=n){const e=u.texData.get(o.dataId),t=n(e.values,l);return u.makeTensorInfo(o.shape,l,t)}let c;return c=(0,i.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new ir(o.shape,t):new Gn(o.shape,e),u.runWebGLProgram(c,[o],l)}}function $r({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:u})=>{const{a:l,b:c}=o,d=u;if(r&&"complex64"===l.dtype){const t=d.texData.get(l.dataId),n=d.texData.get(c.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},o=new dr(e,l.shape,c.shape);return d.runWebGLProgram(o,[a,s],(0,i.x8V)(n.dtype,r.dtype))})),s=gr({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const h=s||(0,i.x8V)(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([l,c]))&&null!=a){const e=d.texData.get(l.dataId).values,t=d.texData.get(c.dataId).values,n="string"===l.dtype?i.backend_util.fromUint8ToStringArray(e):e,r="string"===l.dtype?i.backend_util.fromUint8ToStringArray(t):t,[s,o]=a(l.shape,c.shape,n,r,h),u=d.makeTensorInfo(o,h);return d.texData.get(u.dataId).values=s,u}let p;return p=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new pr(t,l.shape,c.shape,n):new dr(e,l.shape,c.shape),d.runWebGLProgram(p,[l,c],h)}}function Rr(e,t=!1){if("linear"===e)return t?Jn:jn;if("relu"===e)return t?tr:qn;if("elu"===e)return t?er:Kn;if("relu6"===e)return t?nr:Yn;if("prelu"===e)return t?kr:vr;if("leakyrelu"===e)return t?yr:br;if("sigmoid"===e)return t?rr:Zn;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Tr{constructor(e,t,n,r=!1,i=!1,a=!1,s=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=se(this.outputShape.length);const l=r?e[1]:e[2],c=Math.ceil(l/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";s&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");const x=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(y=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${y};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const Ar={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Er{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Nr="return a * b;";function Dr(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=i.backend_util.upcastType(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),i=new Er(Ar.REAL,r.shape,a.shape),s=new Er(Ar.IMAG,r.shape,a.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],u=n.runWebGLProgram(i,o,"float32"),l=n.runWebGLProgram(s,o,"float32"),c=gr({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,o]=ln(r.shape,a.shape,e.values,t.values,s),u=n.makeTensorInfo(o,s);return n.texData.get(u.dataId).values=i,u}let o;return o=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pr(Nr,r.shape,a.shape):new dr(Nr,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const _r={kernelName:i.wYn,backendName:"webgl",kernelFunc:Dr};function Fr(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,o=n,u=i.D5U.sizeFromShape(a.shape),l=i.D5U.inferFromImplicitShape(s,u),c=i.D5U.sizeFromShape(l);i.D5U.assert(u===c,(()=>`The new shape (${l}) has ${c} elements and the old shape (${a.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`));const d=o.texData.get(a.dataId);return!d.isPacked||N(a.shape,l)||null!==d.texture&&N(d.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[R(e.shape),...T(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},a=[R(t),...T(t)],s=new Ln(a,r),o=[r],u=n.runWebGLProgram(s,[i],e.dtype,o,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(a,l,o)}const Pr={kernelName:i.HZH,backendName:"webgl",kernelFunc:Fr};class Or{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const o=4*Math.floor(n/4),u=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${i.D5U.isInt(e)?e.toPrecision(2):e}, ones);`}let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Ur{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let s="0.0",o="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",o="min"):"max"===t&&(s="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";i%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function Br(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=i.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let i=0;i<a.length;i++){const{inSize:o,windowSize:u,outSize:l}=a[i];let c,d;c="mean"===n?0===i?new Or({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new Or({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new Ur({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class Lr{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=ee(this.rank),i=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class zr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ee(this.rank),i=On("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=i[e];const s=`vec2(${a.slice(-2).join()})`,o=`++${i[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Mr(e,t,n){const r=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zr(e.shape,t):new Lr(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Wr(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return function(e,t,n,r){const a=t,s=e.shape.length,o=i.D5U.parseAxisParam(a,e.shape);let u=o;const l=i.backend_util.getAxesPermutation(u,s),c=null!=l;let d=e;c&&(d=Mr(e,l,r),u=i.backend_util.getInnerMostAxes(u.length,s)),i.backend_util.assertAxesAreInnerMostDims("sum",u,s);const[h,p]=i.backend_util.computeOutAndReduceShapes(d.shape,u);let f=h;n&&(f=i.backend_util.expandShapeToKeepDim(h,o));const m=i.D5U.sizeFromShape(p),g=Fr({inputs:{x:d},attrs:{shape:[i.D5U.sizeFromShape(e.shape)/m,m]},backend:r}),x=Br(g,(0,i.z4k)(e.dtype),"sum",r),b=Fr({inputs:{x},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(d),b}(a,s,o,n)}const Vr={kernelName:i.GBy,backendName:"webgl",kernelFunc:Wr};function Gr(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{perm:a}=r,s=n,o=i.shape.length,u=new Array(o);for(let e=0;e<u.length;e++)u[e]=i.shape[a[e]];let l;if(s.shouldExecuteOnCPU([i])){const e=s.texData.get(i.dataId).values,t=Fn(e,i.shape,i.dtype,a,u);l=s.makeTensorInfo(u,i.dtype),s.texData.get(l.dataId).values=t}else l=Mr(i,a,s);return l}const Hr={kernelName:i.G3Y,backendName:"webgl",kernelFunc:Gr},jr=1e3;function Xr({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const c=e.shape.length,d=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],p=r?t.shape[d-1]:t.shape[d-2],f=n?e.shape[c-1]:e.shape[c-2],m=r?t.shape[d-2]:t.shape[d-1],g=e.shape.slice(0,-2),x=t.shape.slice(0,-2),b=i.D5U.sizeFromShape(g),y=i.D5U.sizeFromShape(x),w=i.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);i.D5U.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const v=n?[b,h,f]:[b,f,h],k=r?[y,m,p]:[y,p,m],C=Fr({inputs:{x:e},backend:a,attrs:{shape:v}}),I=Fr({inputs:{x:t},backend:a,attrs:{shape:k}}),S=[C,I],$=Math.max(b,y),R=n?C.shape[1]:C.shape[2],T=null!=s,A=null!=o,E="leakyrelu"===l,N=null!=l?Rr(l,!0):null;let D;if((1===f||1===m)&&R>jr&&!1===(T||A||E||null!=N)){let e=C,t=I;n&&(e=Gr({inputs:{x:C},backend:a,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=Gr({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),S.push(t));const i=1===m;let s=e;1!==m&&(s=Fr({inputs:{x:e},backend:a,attrs:{shape:[$,R,1]}}),S.push(s));const o=1===m?2:1;let u=t;i&&(u=Fr({inputs:{x:t},backend:a,attrs:{shape:[$,1,R]}}),S.push(u));const l=Dr({inputs:{a:s,b:u},backend:a});D=Wr({inputs:{x:l},backend:a,attrs:{axis:o,keepDims:!0}}),S.push(l)}else{const l=(0,i.x8V)(e.dtype,t.dtype),c=new Tr(v,k,[$,f,m],n,r,T,N,A,E),d=[C,I];if(null!=s&&d.push(s),A&&d.push(o),E){const e=a.makeTensorInfo([],"float32",i.D5U.createScalarValue(u,"float32"));d.push(e),S.push(e)}D=a.runWebGLProgram(c,d,l)}const _=Fr({inputs:{x:D},backend:a,attrs:{shape:w}});S.push(D);for(const e of S)a.disposeIntermediateTensorInfo(e);return _}const Kr={kernelName:i.usg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a,bias:s,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return Xr({a:i,b:a,transposeA:u,transposeB:l,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},qr="return abs(x);",Yr={kernelName:i.SYM,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=wn(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=(0,i.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ir(r.shape,qr):new Gn(r.shape,qr),n.runWebGLProgram(a,[r],r.dtype)}},Qr=Sr({opSnippet:Hn+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Zr={kernelName:i.VGw,backendName:"webgl",kernelFunc:Qr},Jr=Sr({opSnippet:Hn+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),ei={kernelName:i.SpW,backendName:"webgl",kernelFunc:Jr},ti="return a + b;",ni=$r({opSnippet:ti,packedOpSnippet:ti,supportsComplex:!0,cpuKernelImpl:zt}),ri={kernelName:i.mm_,backendName:"webgl",kernelFunc:ni};class ii{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class ai{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const si={kernelName:i.Xze,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return fr({inputs:{x:a[0]},backend:r});if(a.length>(0,i.OBj)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),i=e({inputs:a.slice(t),backend:r});return e({inputs:[n,i],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>(0,i.x8V)(e,t))),o=a.map((e=>e.shape)),u=(0,i.OBj)().getBool("WEBGL_PACK")?new ai(a[0].shape,o):new ii(a[0].shape,o);return r.runWebGLProgram(u,a,s)}},oi={kernelName:i.oT6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,u=a.shape.length,l=i.D5U.parseAxisParam(s,a.shape);let c=l;const d=i.backend_util.getAxesPermutation(c,u);let h=a;null!=d&&(h=Gr({inputs:{x:a},backend:n,attrs:{perm:d}}),c=i.backend_util.getInnerMostAxes(c.length,u)),i.backend_util.assertAxesAreInnerMostDims("all",c,u);const[p,f]=i.backend_util.computeOutAndReduceShapes(h.shape,c),m=Fr({inputs:{x:h},backend:n,attrs:{shape:[-1,i.D5U.sizeFromShape(f)]}}),g=Br(m,m.dtype,"all",n);let x;return x=Fr(o?{inputs:{x:g},backend:n,attrs:{shape:i.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),x}},ui={kernelName:i.IKK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,u=a.shape.length,l=i.D5U.parseAxisParam(s,a.shape);let c=l;const d=i.backend_util.getAxesPermutation(c,u);let h=a;null!=d&&(h=Gr({inputs:{x:a},backend:n,attrs:{perm:d}}),c=i.backend_util.getInnerMostAxes(c.length,u)),i.backend_util.assertAxesAreInnerMostDims("any",c,u);const[p,f]=i.backend_util.computeOutAndReduceShapes(h.shape,c),m=Fr({inputs:{x:h},backend:n,attrs:{shape:[-1,i.D5U.sizeFromShape(f)]}}),g=Br(m,m.dtype,"any",n);let x;return x=Fr(o?{inputs:{x:g},backend:n,attrs:{shape:i.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),x}};class li{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const s="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ci{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,i.D5U.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,l=ee(u),c=Un("coords",u);let d,h;if(1===s){h=u+1;const e=ee(h);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else h=u,d=`\n        ${l} sourceLocR = coords;\n        ++${c[u-1]};\n        ${l} sourceLocG = coords;\n        ++${c[u-2]};\n        ${l} sourceLocA = coords;\n        --${c[u-1]};\n        ${l} sourceLocB = coords;\n        --${c[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map((e=>"int "+e)),g=Un("sourceLocR",h-1).concat("inIdx.r"),x=Un("sourceLocG",h-1).concat("inIdx.g"),b=Un("sourceLocB",h-1).concat("inIdx.b"),y=Un("sourceLocA",h-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,k=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${x.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,C=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${C}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${o[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${o[u-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${k};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${k};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function di(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=i.backend_util.computeOptimalWindowSize(s),u={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},l=new li(u,n,null==r),c=[t];null!=r&&c.push(r);const d=e.runWebGLProgram(l,c,"int32");if(1===d.shape[1])return d;const h=di(e,t,n,d);return e.disposeIntermediateTensorInfo(d),h}function hi(e,t,n,r=null){const a=null!=r?r.shape:t.shape,s=a[a.length-1],o=i.backend_util.computeOptimalWindowSize(s),u=new ci(a,o,n,null==r),l=null==r?[t]:[t,r],c=e.runWebGLProgram(u,l,"int32");if(c.shape.length===t.shape.length){const r=hi(e,t,n,c);return e.disposeIntermediateTensorInfo(c),r}return c}function pi(e,t,n,r){const a=[n];if(i.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!(0,i.OBj)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[u,l]=i.backend_util.computeOutAndReduceShapes(o.shape,a),c=i.D5U.sizeFromShape(l),d=Fr({inputs:{x:o},backend:e,attrs:{shape:[-1,c]}});n.push(d);const h=di(e,d,r);n.push(h);const p=Fr({inputs:{x:h},backend:e,attrs:{shape:u}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return hi(e,t,r)}const fi={kernelName:i.sJF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=i.D5U.parseAxisParam(s,a.shape);const u=i.backend_util.getAxesPermutation(o,a.shape.length);let l=a;const c=[];null!=u&&(l=Gr({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(l),o=i.backend_util.getInnerMostAxes(o.length,l.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const d=pi(n,l,o[0],"max");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},mi={kernelName:i.aJk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=i.D5U.parseAxisParam(s,a.shape);const u=i.backend_util.getAxesPermutation(o,a.shape.length);let l=a;const c=[];null!=u&&(l=Gr({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(l),o=i.backend_util.getInnerMostAxes(o.length,l.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const d=pi(n,l,o[0],"min");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},gi=Sr({opSnippet:Hn+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),xi={kernelName:i.M2y,backendName:"webgl",kernelFunc:gi},bi=Sr({opSnippet:Hn+"return log(x + sqrt(x * x + 1.0));"}),yi={kernelName:i.qw7,backendName:"webgl",kernelFunc:bi},wi=Sr({opSnippet:Hn+"\n  return atan(x);\n"}),vi={kernelName:i.jMg,backendName:"webgl",kernelFunc:wi},ki=$r({opSnippet:cr+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+hr+"\n  return result;\n"}),Ci={kernelName:i.QCc,backendName:"webgl",kernelFunc:ki},Ii=Sr({opSnippet:Hn+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Si={kernelName:i.Oyi,backendName:"webgl",kernelFunc:Ii};class $i{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,s=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const y=4*Math.floor(a/4),w=a%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class Ri{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,s=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let y="0.0";if(b||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),k=a%4,C=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const Ti={kernelName:i.JhU,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;U(a,"avgPool");const{filterSize:s,strides:o,pad:u,dimRoundingMode:l}=r;i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const c=i.backend_util.computePool2DInfo(a.shape,s,o,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&i.D5U.arraysEqual(c.inShape,c.outShape))return fr({inputs:{x:a},backend:n});const d=new $i(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},Ai={kernelName:i._k9,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=r,d=i.backend_util.computePool3DInfo(a.shape,s,o,[1,1,1],u,l,c),h=new Ri(d,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}};class Ei{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=o-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ni{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${i}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Di={kernelName:i.IMb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,h=i.backend_util.computePool3DInfo(o.shape,u,l,[1,1,1],c,d),p=new Ni(h);return n.runWebGLProgram(p,[a],o.dtype)}},_i={kernelName:i.ROF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;U([a,s],"avgPoolGrad");const{filterSize:u,strides:l,pad:c}=r,d=i.backend_util.computePool2DInfo(o.shape,u,l,1,c),h=new Ei(d);return n.runWebGLProgram(h,[a],o.dtype)}},Fi={kernelName:i.XLW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a}=t,{transposeA:s,transposeB:o}=r;return Xr({a:i,b:a,transposeA:s,transposeB:o,backend:n})}};class Pi{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(e,t),i.backend_util.assertAndGetBroadcastShape(e,n);let o="0.0";null!=r&&(i.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";null!=a&&(i.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Oi{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(e,t),i.backend_util.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=r&&(i.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=a&&(i.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Ui={kernelName:i.sHE,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:a,variance:s,offset:o,scale:u}=e;i.D5U.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),i.D5U.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),i.D5U.assert(null==u||a.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const c=[r,a,s];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=u&&(h=u.shape,c.push(u));const p=(0,i.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new Oi(r.shape,a.shape,s.shape,d,h,l):new Pi(r.shape,a.shape,s.shape,d,h,l);return t.runWebGLProgram(p,c,c[0].dtype)}};class Bi{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=ee(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Li.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Li[t]} = start[${t}] + coords.${Li[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const Li=["x","y","z","w","u","v"];class zi{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=ee(this.rank),n=Un("coords",this.rank),r=Un("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,s=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${s}\n        ${o}\n        setOutput(result);\n      }\n    `}}function Mi(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[u,l]=i.kuN.parseSliceParams(a,s,o);if(i.kuN.assertParamsValid(a,u,l),0===i.D5U.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=vn(e.values,u,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:c}=n.texData.get(a.dataId),d=i.kuN.isSliceContinous(a.shape,u,l);if(c||!d){const e=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zi(l):new Bi(l),t=[u];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=e.dtype;let u=i.kuN.computeFlatOffset(t,i.D5U.computeStrides(e.shape));a.slice&&(u+=a.slice.flatOffset),o.slice={flatOffset:u,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}(a,u,l,n)}const Wi={kernelName:i.p2w,backendName:"webgl",kernelFunc:Mi},Vi={kernelName:i.zws,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;i.D5U.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const u=s.reduce(((e,t)=>e*t)),l=i.backend_util.getReshaped(a.shape,s,u),c=i.backend_util.getPermuted(l.length,s.length),d=i.backend_util.getReshapedPermuted(a.shape,s,u),h=i.backend_util.getSliceBeginCoords(o,s.length),p=i.backend_util.getSliceSize(d,o,s.length),f=[],m=Fr({inputs:{x:a},backend:n,attrs:{shape:l}}),g=Gr({inputs:{x:m},backend:n,attrs:{perm:c}}),x=Fr({inputs:{x:g},backend:n,attrs:{shape:d}}),b=Mi({inputs:{x},backend:n,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(x),f.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Gi={kernelName:i.zvY,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:s}=r,o=n.readSync(i.dataId),u=n.readSync(a.dataId),l=Mt(o,u,a.dtype,a.shape,s);return n.makeTensorInfo([s],a.dtype,l)}},Hi={kernelName:i.hCO,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=(0,i.OBj)().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===o){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[i,s]=Vt(r.shape,a.shape,e,t,r.dtype),o=n.makeTensorInfo(s,r.dtype);return n.texData.get(o.dataId).values=i,o}let u;return u=s?new pr("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new dr("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(u,[r,a],r.dtype)}},ji={kernelName:i.eEB,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),o=n.readSync(a.dataId),u=i.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},Xi=$r({opSnippet:"return float(a != b);",cpuKernelImpl:dn,dtype:"bool"}),Ki={kernelName:i.yQU,backendName:"webgl",kernelFunc:Xi};function qi(e){const{inputs:t,backend:n}=e,{input:r}=t;return fr({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const Yi={kernelName:i.xJR,backendName:"webgl",kernelFunc:qi},Qi={kernelName:i.RFZ,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return fr({inputs:{x:s},backend:r});const t=i.lls(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=gr({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=qi({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(t),n}if(!i.D5U.hasEncodingLoss(s.dtype,o)){const e=fr({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,i]=Gt(e,s.shape,s.dtype,o);return r.makeTensorInfo(t,n,i)}if("int32"===o)return function(e,t){const n=new Gn(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",i.D5U.getTypedArrayFromDType("bool",1)),t=Xi({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},Zi="return ceil(x);",Ji=Sr({opSnippet:Zi,packedOpSnippet:Zi,cpuKernelImpl:Ht}),ea={kernelName:i.gJX,backendName:"webgl",kernelFunc:Ji};class ta{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class na{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const ra={kernelName:i.xnO,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let u;u=(0,i.OBj)().getBool("WEBGL_PACK_CLIP")?new na(a.shape):new ta(a.shape);const l=[[s],[o]];return n.runWebGLProgram(u,[a],a.dtype,l)}};class ia{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function aa(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const sa={kernelName:i.yj2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=n.texData.get(r.dataId),a=new ia(r.shape),s=[aa(r,i.complexTensorInfos.real),aa(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(a,s,s[0].dtype)}};class oa{constructor(e){this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ua{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(e,t);const n=this.outputShape,r=n.length,a=ee(r),s=Un("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const u=new Array(e.length-1);u[0]=e[0][t];for(let n=1;n<u.length;n++)u[n]=u[n-1]+e[n][t];const l=o[t],c=o.slice(-2),d=o.join();let h=`if (${l} < ${u[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<u.length;e++){const t=u[e-1];h+=`\n        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {\n          return getChannel(\n            getT${e}(${la(o,l,t)}),\n            vec2(${la(c,l,t)}));\n        }`}const p=u.length,f=u[u.length-1];h+=`\n        return getChannel(\n          getT${p}(${la(o,l,f)}),\n          vec2(${la(c,l,f)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function la(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function ca(e){const{inputs:t,backend:n}=e,{input:r}=t;return fr({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const da={kernelName:i.J_u,backendName:"webgl",kernelFunc:ca};function ha(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>qi({inputs:{input:e},backend:n}))),i=e.map((e=>ca({inputs:{input:e},backend:n}))),a=ha(r,t,n),s=ha(i,t,n),o=gr({inputs:{real:a,imag:s},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),i.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=i.D5U.sizeFromShape(e.shape.slice(t));return Fr({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=i.backend_util.computeOutShape(a.map((e=>e.shape)),1),u=1===a[0].shape[0],l=jt(s,o,r,u),c=i.backend_util.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(c,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}const s=e.filter((e=>i.D5U.sizeFromShape(e.shape)>0)),o=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=o?new Gn(e[0].shape,Qn):new ir(e[0].shape,Qn);return n.runWebGLProgram(t,e,r)}const u=(0,i.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>u){const e=[];for(let r=0;r<s.length;r+=u){const i=s.slice(r,r+u);e.push(ha(i,t,n))}const r=ha(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(o){const e=new ua(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}const{tensors2D:l,outShape:c}=function(e,t,n){const r=i.backend_util.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Fr({inputs:{x:e},attrs:{shape:[-1,i.D5U.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(s,t,n),d=new oa(l.map((e=>e.shape))),h=n.runWebGLProgram(d,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const p=Fr({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),p}function pa(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=i.D5U.parseAxisParam(a,t[0].shape)[0],o=t.map((e=>e.shape));i.backend_util.assertParamsConsistent(o,s);const u=i.backend_util.computeOutShape(t.map((e=>e.shape)),s);if(0===i.D5U.sizeFromShape(u))return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter((e=>i.D5U.sizeFromShape(e.shape)>0));return 1===l.length?fr({inputs:{x:l[0]},backend:n}):ha(l,s,n)}const fa={kernelName:i.Eh3,backendName:"webgl",kernelFunc:pa};class ma{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,s=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,x=m?2:3,b=m?3:1;let y="",w="";n&&(y=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class ga{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${a}, ${s});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xa{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=se(this.outputShape.length);const s=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)h+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<c;e++)h+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(d+1)/2;t++){const n=2*t;if(h+=`\n           xC = xCCorner + ${n*u};\n           `,1===o){if(n<c&&(s%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,h+=1===u&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<c)){const e=s%2==0?i.D5U.nearestLargerEven(u):u;u%2==0&&s%2==1||u%2!=0&&s%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,h+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):h+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<c&&(s%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<c&&(h+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<c&&(h+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<c&&(h+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}class ba{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=se(this.outputShape.length);const{dataFormat:n}=t,r=L(),i="channelsLast"===n,a=i?1:2,s=i?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)u+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${s}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}function ya(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function wa({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape,c=r.texData.get(e.dataId),d=n.inChannels,h=l[0]*l[1]*l[2],p=n.outChannels,f="channelsLast"===n.dataFormat;let m;const g=[];if(null!=s){const e=ya(s.shape,f);null!=e&&(s=Fr({inputs:{x:s},backend:r,attrs:{shape:e}}),g.push(s))}if(null!=a){const e=ya(a.shape,f);null!=e&&(a=Fr({inputs:{x:a},backend:r,attrs:{shape:e}}),g.push(a))}if((1!==h&&1!==p||!(d>jr))&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&i.D5U.arraysEqual(c.shape.slice(-3),l.slice(-3))){const d=l[0]*l[1]*(l[2]+1),h={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},p=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,i.D5U.assert(N(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const f=Fr({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(f);const x=Xr({a:h,b:f,backend:r,transposeA:!1,transposeB:!1,bias:a,activation:u,preluActivationWeights:s,leakyreluAlpha:o}),b=r.texData.get(x.dataId);i.D5U.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=p,b.shape=n.outShape,m=fr({inputs:{x},backend:r}),m.shape=n.outShape,g.push(x)}else{const i=n.outHeight*n.outWidth,l=Fr({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,i,n.inChannels]:[n.batchSize,n.inChannels,i]}}),c=Fr({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=Xr({a:f?l:c,b:f?c:l,transposeA:!f,transposeB:!1,backend:r,bias:a,activation:u,preluActivationWeights:s,leakyreluAlpha:o});m=Fr({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),g.push(l),g.push(c),g.push(d)}for(const e of g)r.disposeIntermediateTensorInfo(e);return m}function va({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:u=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=l*c*d,x=p*h,b=[n.batchSize,g,x],y=[];if(null!=s){const e=ya(s.shape,m);null!=e&&(s=Fr({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}if(null!=a){const e=ya(a.shape,m);null!=e&&(a=Fr({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}const w=Fr({inputs:{x:t},backend:r,attrs:{shape:[1,g,i.D5U.sizeFromShape(t.shape)/g]}});y.push(w);const v=new ba(b,n),k=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],C=r.runWebGLProgram(v,[e],"float32",k),I=Fr({inputs:{x:C},backend:r,attrs:{shape:b}});y.push(C),y.push(I);const S=null!=a,$=null!=s,R="leakyrelu"===u,T=u?Rr(u,!0):null,A=new Tr(m?I.shape:w.shape,m?w.shape:I.shape,m?[n.batchSize,x,n.outChannels]:[n.batchSize,n.outChannels,x],!0,!1,S,T,$,R),E=m?[I,w]:[w,I];if(a&&E.push(a),$&&E.push(s),R){const e=r.makeTensorInfo([],"float32",i.D5U.createScalarValue(o,"float32"));E.push(e),y.push(e)}const N=r.runWebGLProgram(A,E,"float32"),D=Fr({inputs:{x:N},backend:r,attrs:{shape:n.outShape}});y.push(N);for(const e of y)r.disposeIntermediateTensorInfo(e);return D}const ka={kernelName:i.mhS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=r,h=i.backend_util.convertConv2DDataFormat(l),p=i.backend_util.computeConv2DInfo(a.shape,s.shape,o,c,u,d,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&(0,i.OBj)().getBool("WEBGL_EXP_CONV")){const e=new xa(p),t=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=n.runWebGLProgram(e,[a,s],"float32",t)}else if((0,i.OBj)().getBool("WEBGL_CONV_IM2COL"))f=va({x:a,filter:s,convInfo:p,backend:n});else{const e=new ma(p);f=n.runWebGLProgram(e,[a,s],"float32")}else f=wa({x:a,filter:s,convInfo:p,backend:n});const m=Fr({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class Ca{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ia{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sa{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,s=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${i};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${s};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $a{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${i}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ra={kernelName:i.wUP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,h=i.backend_util.convertConv2DDataFormat(l),p=i.backend_util.computeConv2DInfo(a.shape,d,o,1,u,c,!1,h),f=new Ca(p);return n.runWebGLProgram(f,[a,s],"float32")}};class Ta{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=se(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,i=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const Aa={kernelName:i.wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:d}=r,h=i.backend_util.convertConv2DDataFormat(c),p=i.backend_util.computeConv2DInfo(o,s.shape,u,1,l,d,!1,h);if((0,i.OBj)().getBool("WEBGL_PACK")&&"channelsLast"===h){const e=[[p.strideHeight,p.strideWidth]],t=new Ta(p);return n.runWebGLProgram(t,[a,s],"float32",e)}{const e=new Ia(p);return n.runWebGLProgram(e,[a,s],"float32")}}},Ea={kernelName:i.x12,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dilations:l}=r,c=i.backend_util.computeConv3DInfo(a.shape,s.shape,o,l,u),d=new ga(c);return n.runWebGLProgram(d,[a,s],"float32")}},Na={kernelName:i.o2y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:u,filterShape:l}=r,c=i.backend_util.computeConv3DInfo(a.shape,l,o,1,u),d=new Sa(c);return n.runWebGLProgram(d,[a,s],"float32")}},Da={kernelName:i.ik2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:o,strides:u,inputShape:l}=r,c=i.backend_util.computeConv3DInfo(l,s.shape,u,1,o),d=new $a(c);return n.runWebGLProgram(d,[a,s],"float32")}},_a=Sr({opSnippet:Ir+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${hr}\n  return result;\n`}),Fa={kernelName:i.mc4,backendName:"webgl",kernelFunc:_a},Pa=Sr({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Oa={kernelName:i.TR1,backendName:"webgl",kernelFunc:Pa};class Ua{constructor(e,t,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,s,o,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const h="bilinear"===r?1:0,[p,f]=[s-1+".0",o-1+".0"],[m,g,x]=c>1?[""+(s-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,y,w]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${y};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Ba={kernelName:i.VcC,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:a,boxInd:s}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new Ua(i.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[i,a,s],"float32")}};var La;!function(e){e.Prod="*",e.Sum="+"}(La||(La={}));class za{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===La.Prod?"1.0":"0.0",s=n?a:`getX(${Ma(i,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let u="",l="";n?(u=r?"end != "+(o-1):"end != 0",l=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${o}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ee(i)} coords = getOutputCoords();\n        int end = ${Wa(i,"coords",this.op)};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${l};\n          ${Wa(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Ma(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Ma(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Wa(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Va(e,t,n,r,a,s){const o=t.shape.length,u=i.backend_util.getAxesPermutation([r],o);let l=t;null!=u&&(l=Gr({inputs:{x:t},backend:n,attrs:{perm:u}}));const c=i.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const d=l.shape[c];let h=fr({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const r=new za(e,l.shape,!1,s),i=[[t]],a=h;h=n.runWebGLProgram(r,[h],h.dtype,i),n.disposeIntermediateTensorInfo(a)}if(a){const t=new za(e,l.shape,a,s),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=u){const e=Gr({inputs:{x:h},backend:n,attrs:{perm:i.backend_util.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const Ga={kernelName:i.Byc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return Va(La.Prod,i,n,a,s,o)}},Ha={kernelName:i.iHb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return Va(La.Sum,i,n,a,s,o)}},ja={kernelName:i.QRR,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:s,binaryOutput:o}=r;if(1===i.shape.length){const e=n.readSync(i.dataId),t=n.readSync(a.dataId),r=Mt(e,t,a.dtype,a.shape,s);return n.makeTensorInfo([s],a.dtype,r)}if(2===i.shape.length){const e=n.bufferSync(i),t=n.bufferSync(a),r=Wt(e,t,s,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class Xa{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Ka={kernelName:i.T0n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:a,dataFormat:s}=r,o=i.shape[0],u=("NHWC"===s?i.shape[1]:i.shape[2])*a,l=("NHWC"===s?i.shape[2]:i.shape[3])*a,c=("NHWC"===s?i.shape[3]:i.shape[1])/(a*a),d=new Xa("NHWC"===s?[o,u,l,c]:[o,c,u,l],a,s);return n.runWebGLProgram(d,[i],i.dtype)}};class qa{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=se(this.outputShape.length);const a=e.filterHeight,s=e.filterWidth,o=e.outChannels/e.inChannels;let u="",l="";n&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}class Ya{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=se(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)p+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)p+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(h+1)/2;e++){const t=2*e;if(p+=`\n          xC = xCCorner + ${t*l};\n          `,1===u){if(t<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,p+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<d)){const e=o%2==0?i.D5U.nearestLargerEven(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,p+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):p+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<d&&(p+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<d&&(p+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<d&&(p+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";n&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const Qa={kernelName:i.cie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dilations:l,dimRoundingMode:c}=r;let d=l;null==d&&(d=[1,1]),i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(o,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`));const h=i.backend_util.computeConv2DInfo(a.shape,s.shape,o,d,u,c,!0);let p;p=(0,i.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new Ya(h):new qa(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[a,s],"float32",f)}};class Za{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ja{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,s=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const es={kernelName:i.sL$,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,filterShape:d}=r,h=i.backend_util.computeConv2DInfo(a.shape,d,o,u,l,c,!0),p=new Za(h);return n.runWebGLProgram(p,[a,s],"float32")}},ts={kernelName:i.y7R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,inputShape:d}=r,h=i.backend_util.computeConv2DInfo(d,s.shape,o,u,l,c,!0),p=new Ja(h);return n.runWebGLProgram(p,[a,s],"float32")}};class ns{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const rs={kernelName:i.$w,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=i.D5U.sizeFromShape(r.shape),o=Fr({inputs:{x:r},backend:n,attrs:{shape:[s]}}),u=new ns(s),l=n.runWebGLProgram(u,[o],o.dtype),c=Fr({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}};class is{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:s,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const as={kernelName:i.p4S,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dilations:l}=r,c=i.backend_util.computeDilation2DInfo(a.shape,s.shape,o,u,"NHWC",l);let d;const h=new is(c);d=n.runWebGLProgram(h,[a,s],"float32");const p=Fr({inputs:{x:d},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(d),p}},ss={kernelName:i.$g6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:u,idDims:l}=i.backend_util.decodeEinsumEquation(a,s.length);i.backend_util.checkEinsumDimSizes(o.length,l,s);const{path:c,steps:d}=i.backend_util.getEinsumComputePath(u,l),h=d.length;let p=null,f=o.length;const m=[];for(let e=0;e<h;++e){for(const t of d[e]){const{permutationIndices:e,expandDims:r}=i.backend_util.getEinsumPermutation(f,l[t]);let a;i.backend_util.isIdentityPermutation(e)?a=s[t]:(a=Gr({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),m.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);i.D5U.arraysEqual(a.shape,o)||(a=Fr({inputs:{x:a},backend:n,attrs:{shape:o}}),m.push(a)),null===p?p=a:(p=Dr({inputs:{a,b:p},backend:n}),m.push(p))}e<h-1&&(c[e]>=0&&(p=Wr({inputs:{x:p},backend:n,attrs:{axis:c[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},os=Sr({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),us={kernelName:i.SX0,backendName:"webgl",kernelFunc:os},ls={kernelName:i.HEU,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=(0,i.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pr("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new dr("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},cs=$r({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Xt}),ds={kernelName:i.hdR,backendName:"webgl",kernelFunc:cs},hs=Sr({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${i.backend_util.ERF_P};\n  float a1 = ${i.backend_util.ERF_A1};\n  float a2 = ${i.backend_util.ERF_A2};\n  float a3 = ${i.backend_util.ERF_A3};\n  float a4 = ${i.backend_util.ERF_A4};\n  float a5 = ${i.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),ps={kernelName:i.Omj,backendName:"webgl",kernelFunc:hs},fs=Sr({opSnippet:Ir+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Kt,dtype:"float32"}),ms={kernelName:i.NEP,backendName:"webgl",kernelFunc:fs};function gs(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,u=s.shape.slice();let l=a;return a<0&&(i.D5U.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),u.splice(l,0,1),Fr({inputs:{x:s},backend:r,attrs:{shape:u}})}const xs={kernelName:i.YFo,backendName:"webgl",kernelFunc:gs},bs="return exp(x) - 1.0;",ys=Sr({opSnippet:bs,packedOpSnippet:bs,cpuKernelImpl:qt}),ws={kernelName:i.Y0y,backendName:"webgl",kernelFunc:ys};class vs{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);s="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${s}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ks(e,t,n){const r=n.texData.get(e.dataId),a=i.D5U.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],o=Fr({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),u=o.shape,l=new vs("real",u,t),c=new vs("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],h=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=gr({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=Fr({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}const Cs={kernelName:i.vwp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ks(r,!1,n)}};class Is{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Ss(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||i.D5U.inferDtype(a),"string"===s){const e=i.D5U.getArrayFromDType(s,i.D5U.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new Is(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const $s={kernelName:i.deh,backendName:"webgl",kernelFunc:Ss};class Rs{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Ts={kernelName:i.Uyb,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new Rs(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}},As="return floor(x);",Es=Sr({opSnippet:As,packedOpSnippet:As,cpuKernelImpl:Yt}),Ns={kernelName:i.OR,backendName:"webgl",kernelFunc:Es},Ds=$r({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),_s={kernelName:i.jeX,backendName:"webgl",kernelFunc:Ds};class Fs{constructor(e){this.variableNames=["A"];const t=L(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Ps{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=L(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Os={kernelName:i.eBW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[c,d]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],h=[d,c],p=[d,c,s];if(u||o){const e=(0,i.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Us&&e===Bs||(Bs=e,Us=document.createElement("canvas").getContext("2d",{willReadFrequently:Bs})),Us.canvas.width=c,Us.canvas.height=d,Us.drawImage(a,0,0,c,d),a=Us.canvas}const f=n.makeTensorInfo(h,"int32");n.texData.get(f.dataId).usage=l.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),a);const m=(0,i.OBj)().getBool("WEBGL_PACK")?new Ps(p):new Fs(p),g=n.runWebGLProgram(m,[f],"int32");return n.disposeData(f.dataId),g}};let Us,Bs=(0,i.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Ls={kernelName:i._V0,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=i.backend_util.convertConv2DDataFormat(d),x=i.backend_util.computeConv2DInfo(a.shape,s.shape,l,h,c,p,!1,g);let b;const y=[],w=null!=o,v=null!=u,k="leakyrelu"===f,C=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=Fr({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(w&&e.push(t(o,d)),v&&e.push(t(u,d)),k){const t=n.makeTensorInfo([],"float32",i.D5U.createScalarValue(m,"float32"));e.push(t),y.push(t)}return e};if(1!==x.filterHeight||1!==x.filterWidth||1!==x.dilationHeight||1!==x.dilationWidth||1!==x.strideHeight||1!==x.strideWidth||"SAME"!==x.padInfo.type&&"VALID"!==x.padInfo.type)if(x.strideWidth<=2&&"channelsLast"===g&&(0,i.OBj)().getBool("WEBGL_EXP_CONV")){const e=f?Rr(f,!0):null,t=new xa(x,w,e,v,k),r=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],i=C();b=n.runWebGLProgram(t,i,"float32",r)}else if((0,i.OBj)().getBool("WEBGL_CONV_IM2COL"))b=va({x:a,filter:s,convInfo:x,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});else{const e=f?Rr(f,!1):null,t=new ma(x,w,e,v,k),r=C();b=n.runWebGLProgram(t,r,"float32")}else b=wa({x:a,filter:s,convInfo:x,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});const I=Fr({inputs:{x:b},backend:n,attrs:{shape:x.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}},zs={kernelName:i.luS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=[];let g=d;null==g&&(g=[1,1]),i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const x=i.backend_util.computeConv2DInfo(a.shape,s.shape,l,g,c,h,!0),b=(0,i.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels==1,y=p?Rr(p,b):null,w=[a,s],v=null!=o,k=null!=u,C="leakyrelu"===p;if(v&&w.push(o),k&&w.push(u),C){const e=n.makeTensorInfo([],"float32",i.D5U.createScalarValue(f,"float32"));w.push(e),m.push(e)}let I;I=b?new Ya(x,v,y,k,C):new qa(x,v,y,k,C);const S=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],$=n.runWebGLProgram(I,w,"float32",S);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),$}};class Ms{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const i=ee(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Ws={kernelName:i.q1x,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],u=i.D5U.sizeFromShape(r.shape),[l,c,d,h]=i.backend_util.prepareAndValidate(r,a),p=Fr({inputs:{x:a},backend:n,attrs:{shape:[c,o]}}),f=Fr({inputs:{x:r},backend:n,attrs:{shape:[i.D5U.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),i=Qt(e,t,r.dtype,c,o,d,h,r.shape,u);return n.makeTensorInfo(l,r.dtype,i.values)}const m=new Ms(o,h,[c,d],r.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),x=Fr({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),x}};class Vs{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=ee(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Gs(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:u}=r,l=i.D5U.parseAxisParam(o,a.shape)[0];if((0,i.OBj)().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];i.D5U.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const c=i.backend_util.segment_util.collectGatherOpShapeInfo(a,s,l,u),d=i.D5U.sizeFromShape(s.shape),h=[],p=Fr({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=Fr({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});h.push(p),h.push(f);const m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(f),t=n.bufferSync(p),r=Zt(t,e,m);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const g=new Vs(p.shape,m),x=n.runWebGLProgram(g,[p,f],p.dtype);h.push(x);const b=Fr({inputs:{x},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const Hs={kernelName:i.qi_,backendName:"webgl",kernelFunc:Gs},js=$r({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Jt,dtype:"bool"}),Xs={kernelName:i.iZT,backendName:"webgl",kernelFunc:js},Ks=$r({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:en}),qs={kernelName:i.Acj,backendName:"webgl",kernelFunc:Ks},Ys={kernelName:i.Qg5,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ks(r,!0,n)}},Qs=Sr({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Zs={kernelName:i.avt,backendName:"webgl",kernelFunc:Qs},Js=Sr({opSnippet:"return float(isinf(x));",dtype:"bool"}),eo={kernelName:i.iWB,backendName:"webgl",kernelFunc:Js},to=Sr({opSnippet:"return float(isnan(x));",dtype:"bool"}),no={kernelName:i.r7n,backendName:"webgl",kernelFunc:to},ro=$r({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:tn,dtype:"bool"}),io={kernelName:i.vtC,backendName:"webgl",kernelFunc:ro},ao=$r({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:nn,dtype:"bool"}),so={kernelName:i.CAk,backendName:"webgl",kernelFunc:ao},oo={kernelName:i.e7N,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:a}=n,s=rn(r,i,a);return t.makeTensorInfo([s.length],"float32",s)}},uo=Sr({opSnippet:Ir+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:an}),lo={kernelName:i.ZbH,backendName:"webgl",kernelFunc:uo},co=Sr({opSnippet:Ir+"\n  return log(1.0 + x);\n"}),ho={kernelName:i.kU,backendName:"webgl",kernelFunc:co},po=$r({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),fo={kernelName:i.PYm,backendName:"webgl",kernelFunc:po},mo=Sr({opSnippet:"return float(!(x >= 1.0));"}),go={kernelName:i.VfG,backendName:"webgl",kernelFunc:mo},xo=$r({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),bo={kernelName:i.MZg,backendName:"webgl",kernelFunc:xo};class yo{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,s=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class wo{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,s=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const vo={kernelName:i.eZ0,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:o,alpha:u,beta:l}=r,c=(0,i.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new wo(a.shape,s,o,u,l):new yo(a.shape,s,o,u,l);return n.runWebGLProgram(c,[a],a.dtype)}};class ko{constructor(e,t,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Co={kernelName:i.Hhh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i,y:a,dy:s}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,d=new ko(i.shape,o,u,l,c);return n.runWebGLProgram(d,[i,a,s],i.dtype)}};function Io(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r,u=a.shape.length,l=i.D5U.parseAxisParam(s,a.shape);let c=l;const d=i.backend_util.getAxesPermutation(c,u),h=null!=d,p=n.shouldExecuteOnCPU([a]);let f=a;if(h){if(p){const e=n.texData.get(f.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=a.shape[d[e]];const r=Fn(e,a.shape,a.dtype,d,t);f=n.makeTensorInfo(t,a.dtype),n.texData.get(f.dataId).values=r}else f=Mr(a,d,n);c=i.backend_util.getInnerMostAxes(c.length,u)}i.backend_util.assertAxesAreInnerMostDims("max",c,u);const[m,g]=i.backend_util.computeOutAndReduceShapes(f.shape,c);let x,b=m;if(o&&(b=i.backend_util.expandShapeToKeepDim(m,l)),p){const e=n.texData.get(f.dataId).values,t=sn(e,i.D5U.sizeFromShape(g),b,a.dtype);x=n.makeTensorInfo(b,a.dtype),n.texData.get(x.dataId).values=t}else x=function(e,t,n,r){const a=i.D5U.sizeFromShape(t),s=Fr({inputs:{x:e},attrs:{shape:[i.D5U.sizeFromShape(e.shape)/a,a]},backend:r}),o=Br(s,e.dtype,"max",r),u=Fr({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),u}(f,g,b,n);return h&&n.disposeIntermediateTensorInfo(f),x}const So={kernelName:i.YoZ,backendName:"webgl",kernelFunc:Io},$o=$r({opSnippet:cr+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+hr+"\n  return result;\n",cpuKernelImpl:on}),Ro={kernelName:i.BMI,backendName:"webgl",kernelFunc:$o},To={kernelName:i.mTV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;U(a,"maxPool");const{filterSize:s,strides:o,pad:u,dimRoundingMode:l}=r;i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const c=i.backend_util.computePool2DInfo(a.shape,s,o,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&i.D5U.arraysEqual(c.inShape,c.outShape))return fr({inputs:{x:a},backend:n});const d=new $i(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},Ao={kernelName:i.OAf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=i.backend_util.computePool3DInfo(a.shape,s,o,[1,1,1],u,c,l),h=new Ri(d,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}};class Eo{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,s=i-1-e.padInfo.top,o=a-1-e.padInfo.left,u=i*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class No{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=u-1-e.padInfo.top,h=l-1-e.padInfo.left,p=o*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${s}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Do={kernelName:i.OU7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,h=i.backend_util.computePool3DInfo(o.shape,u,l,[1,1,1],c,d),p=new Ri(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new No(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},_o={kernelName:i.OV7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,u=s;U([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:h}=r,p=i.backend_util.computePool2DInfo(u.shape,l,c,1,d,h),f=new $i(p,"max",!0),m=n.runWebGLProgram(f,[u],u.dtype),g=new Eo(p),x=n.runWebGLProgram(g,[a,m],u.dtype);return n.disposeIntermediateTensorInfo(m),x}},Fo={kernelName:i.vFR,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:u}=t,l=n;i.D5U.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(s,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`));const d=i.backend_util.computePool2DInfo(r.shape,a,s,c,o),[h,p]=function(e,t,n,r){let i=new $i(n,"max",!1);const a=r.runWebGLProgram(i,[e],"float32");return i=new $i(n,"max",!0,!0,t),[a,r.runWebGLProgram(i,[e],"float32")]}(r,u,d,l);return[h,p]}},Po={kernelName:i.q2K,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:a,axis:s}=t,o=n,u=r.shape.length,l=i.D5U.parseAxisParam(s,r.shape);let c=l;const d=i.backend_util.getAxesPermutation(c,u),h=null!=d,p=o.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=r.shape[d[e]];const n=Fn(e,r.shape,r.dtype,d,t);m=o.makeTensorInfo(t,r.dtype),o.texData.get(m.dataId).values=n}else m=Mr(r,d,o);f.push(m),c=i.backend_util.getInnerMostAxes(c.length,u)}i.backend_util.assertAxesAreInnerMostDims("sum",c,u);const[g,x]=i.backend_util.computeOutAndReduceShapes(m.shape,c);let b=g;a&&(b=i.backend_util.expandShapeToKeepDim(g,l));const y=function(e,t,n,r){const a=i.D5U.sizeFromShape(t),s=Fr({inputs:{x:e},attrs:{shape:[i.D5U.sizeFromShape(e.shape)/a,a]},backend:r}),o=Br(s,"float32","mean",r),u=Fr({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),u}(m,x,b,o);for(const e of f)o.disposeIntermediateTensorInfo(e);return y}},Oo={kernelName:i.c17,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,u=a.shape.length,l=i.D5U.parseAxisParam(s,a.shape);let c=l;const d=i.backend_util.getAxesPermutation(c,u);let h=a;null!=d&&(h=Gr({inputs:{x:a},backend:n,attrs:{perm:d}}),c=i.backend_util.getInnerMostAxes(c.length,a.shape.length)),i.backend_util.assertAxesAreInnerMostDims("min",c,u);const[p,f]=i.backend_util.computeOutAndReduceShapes(h.shape,c),m=Fr({inputs:{x:h},backend:n,attrs:{shape:[-1,i.D5U.sizeFromShape(f)]}}),g=Br(m,m.dtype,"min",n);let x;return x=Fr(o?{inputs:{x:g},backend:n,attrs:{shape:i.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),x}},Uo=$r({opSnippet:cr+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+hr+"\n  return result;\n",cpuKernelImpl:un}),Bo={kernelName:i.q8u,backendName:"webgl",kernelFunc:Uo};class Lo{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=ee(r),a=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${i} start = ${i}(${a});\n      ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class zo{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=ee(r),a=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=Un("rc",r),u=Un("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${i} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${i} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${a});\n      const ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Mo={kernelName:i.jQs,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:a,mode:s}=n,o=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zo(r.shape,a,s):new Lo(r.shape,a,s);return t.runWebGLProgram(o,[r],r.dtype)}},Wo=$r({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+hr+"\n  return result;\n"}),Vo={kernelName:i.Vbg,backendName:"webgl",kernelFunc:Wo};class Go{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const Ho=$r({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),jo={kernelName:i.oHH,backendName:"webgl",kernelFunc:Ho},Xo="return a - b;",Ko=$r({opSnippet:Xo,packedOpSnippet:Xo,supportsComplex:!0,cpuKernelImpl:Nn}),qo={kernelName:i.Tr8,backendName:"webgl",kernelFunc:Ko};function Yo(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=i.D5U.parseAxisParam([s],a.shape),u=Io({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=i.backend_util.expandShapeToKeepDim(u.shape,o),c=Fr({inputs:{x:u},backend:n,attrs:{shape:l}}),d=Ko({inputs:{a,b:c},backend:n}),h=fs({inputs:{x:d},backend:n}),p=Wr({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),f=Fr({inputs:{x:p},backend:n,attrs:{shape:l}}),m=Ho({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}const Qo={kernelName:i.Gcp,backendName:"webgl",kernelFunc:Yo},Zo={kernelName:i.NZg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:a,seed:s,normalized:o}=r,u=o?i:Yo({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new Go(l,c,a),h=[[s]],p=n.runWebGLProgram(d,[u],"int32",h);return o||n.disposeIntermediateTensorInfo(u),p}},Jo=Hn+"\n  return -x;\n",eu={kernelName:i.kuV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,i]=cn(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}let a;return a=(0,i.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ir(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Gn(r.shape,Jo),n.runWebGLProgram(a,[r],r.dtype)}},tu=i.GDt.nonMaxSuppressionV3Impl,nu={kernelName:i.uv1,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h}=tu(c,d,o,u,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},ru=i.GDt.nonMaxSuppressionV4Impl,iu={kernelName:i.cye,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=r,d=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:p,validOutputs:f}=ru(d,h,o,u,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},au=i.GDt.nonMaxSuppressionV5Impl,su={kernelName:i.W0H,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(a.dataId),h=n.readSync(s.dataId),p=o,f=u,m=l,g=c,{selectedIndices:x,selectedScores:b}=au(d,h,p,f,m,g);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class ou{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const uu={kernelName:i.we_,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:o,onValue:u,offValue:l}=r,c=i.D5U.sizeFromShape(a.shape),d=new ou(c,o,u,l),h=Fr({inputs:{x:a},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(d,[h],s);n.disposeIntermediateTensorInfo(h);const f=Fr({inputs:{x:p},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(p),f}};function lu(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=qi({inputs:{input:r},backend:n}),t=lu({inputs:{x:e},backend:n}),i=ca({inputs:{input:r},backend:n}),a=lu({inputs:{x:i},backend:n}),s=gr({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),s}return Ss({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const cu={kernelName:i.RuY,backendName:"webgl",kernelFunc:lu},du={kernelName:i.qWM,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=qi({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),a=ca({inputs:{input:i},backend:r}),s=lu({inputs:{x:a},backend:r}),o=gr({inputs:{real:n,imag:s},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(s),o}return Ss({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},hu={kernelName:i.QiL,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return gs({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{i.D5U.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),i.D5U.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=pa({inputs:t.map((e=>{const t=gs({inputs:{input:e},backend:n,attrs:{dim:a}});return u.push(t),t})),backend:n,attrs:{axis:a}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class pu{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=ee(r),a=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${a});\n      ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class fu{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=ee(r),a=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=Un("rc",r),u=Un("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${l}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${a});\n      const ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const mu=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(0===i.D5U.sizeFromShape(a.shape))return Ss({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}});const u=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fu(a.shape,s,o):new pu(a.shape,s,o),l=[[o]];return n.runWebGLProgram(u,[a],a.dtype,l)},gu={kernelName:i.lyA,backendName:"webgl",kernelFunc:mu},xu=$r({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+hr+"\n  return result;\n"}),bu={kernelName:i.pe_,backendName:"webgl",kernelFunc:xu},yu={kernelName:i.DlI,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,u=a.shape.length,l=[],c=i.D5U.parseAxisParam(s,a.shape);let d=c;const h=i.backend_util.getAxesPermutation(d,u);let p,f=a;if(null!=h&&(f=Gr({inputs:{x:a},backend:n,attrs:{perm:h}}),d=i.backend_util.getInnerMostAxes(d.length,u),l.push(f)),i.backend_util.assertAxesAreInnerMostDims("prod",d,u),n.shouldExecuteOnCPU([f])){const e=n.texData.get(f.dataId).values,{outVals:t,outShape:r,outDtype:i}=hn(f.shape,f.dtype,e,d);p=n.makeTensorInfo(r,i,t)}else{const[e,t]=i.backend_util.computeOutAndReduceShapes(f.shape,d),r=i.D5U.sizeFromShape(t),s=Fr({inputs:{x:f},backend:n,attrs:{shape:[-1,r]}}),o=Br(s,(0,i.z4k)(a.dtype),"prod",n);p=Fr({inputs:{x:o},backend:n,attrs:{shape:e}}),l.push(s),l.push(o)}if(o){l.push(p);const e=i.backend_util.expandShapeToKeepDim(p.shape,c);p=Fr({inputs:{x:p},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},wu={kernelName:i.dDz,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:i,paramsDenseValues:a,indices:s}=t,{outputRaggedRank:o}=r,u=i.map((e=>n.readSync(e.dataId))),l=i.map((e=>e.shape)),c=n.readSync(a.dataId),d=n.readSync(s.dataId),[h,p,f]=pn(u,l,c,a.shape,a.dtype,d,s.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},vu={kernelName:i.CQl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:i,deltas:a}=t,s=n.readSync(r.dataId),o=n.readSync(i.dataId),u=n.readSync(a.dataId),[l,c]=fn(s,r.shape,r.dtype,o,i.shape,u,a.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([c.length],r.dtype,c)]}},ku={kernelName:i.BiW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:i,values:a,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,l=n.readSync(i.dataId),c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=mn(l,i.shape,c,a.shape,a.dtype,d,s.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}},Cu=e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:a,dtype:s}=n,o=gn(r,i,a,s);return t.makeTensorInfo([o.length],s,o)},Iu={kernelName:i.e6w,backendName:"webgl",kernelFunc:Cu},Su=Sr({opSnippet:"return 1.0 / x;"}),$u={kernelName:i.$HU,backendName:"webgl",kernelFunc:Su},Ru=Sr({opSnippet:Hn+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Tu={kernelName:i.qkr,backendName:"webgl",kernelFunc:Ru},Au=Sr({opSnippet:Hn+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Eu={kernelName:i.SbG,backendName:"webgl",kernelFunc:Au};class Nu{constructor(e,t,n,r,i){this.variableNames=["A"],this.outputShape=[];const[a,s,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Du{constructor(e,t,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,s,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const _u={kernelName:i._Yw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:u}=r,[l,c]=u,d=(0,i.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Du(a.shape,l,c,s,o):new Nu(a.shape,l,c,s,o);return n.runWebGLProgram(d,[a],"float32")}};class Fu{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,s]=e,o=[n&&a>1?r-1:r,n&&s>1?i-1:i],u=[n&&a>1?a-1:a,n&&s>1?s-1:s],l=o[0]/u[0],c=o[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Pu={kernelName:i.zbQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:s}=r,o=new Fu(a.shape,i.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}};class Ou{constructor(e,t,n,r,i){this.variableNames=["A"],this.outputShape=[];const[a,s,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Uu{constructor(e,t,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,s,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Bu={kernelName:i.dpD,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:u}=r,[l,c]=u,d=(0,i.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Uu(a.shape,l,c,s,o):new Ou(a.shape,l,c,s,o);return n.runWebGLProgram(d,[a],a.dtype)}};class Lu{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,s]=e,o=[n&&a>1?r-1:r,n&&s>1?i-1:i],u=[n&&a>1?a-1:a,n&&s>1?s-1:s],l=o[0]/u[0],c=o[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const zu={kernelName:i.Hmb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:s}=r,o=new Lu(a.shape,i.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}};class Mu{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),i=ee(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Wu{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Un("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,s=ee(n);function o(n){const r=e.map(((r,i)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${i}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${i}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Vu={kernelName:i.mKl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=a.shape.length,u=i.D5U.parseAxisParam(s,a.shape);if(0===o)return fr({inputs:{x:a},backend:n});const l=(0,i.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wu(a.shape,u):new Mu(a.shape,u);return n.runWebGLProgram(l,[a],a.dtype)}};class Gu{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let i="";i="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Hu={kernelName:i.b9H,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,u=n,l=new Gu(r.shape,s),[c,d]=i.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),h=[[c,d,Math.sin(a),Math.cos(a)]];return u.runWebGLProgram(l,[r],r.dtype,h)}},ju=Sr({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Xu={kernelName:i.e07,backendName:"webgl",kernelFunc:ju},Ku=Sr({opSnippet:"return inversesqrt(x);",cpuKernelImpl:xn}),qu={kernelName:i.bV0,backendName:"webgl",kernelFunc:Ku};class Yu{constructor(e,t,n,r,i,a,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=ee(i.length),l=ee(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${u} strides = ${u}(${i});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}class Qu{constructor(e,t,n,r,i,a,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=ee(i.length),l=ee(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",x=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${u} strides = ${u}(${i});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${x};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}const Zu={kernelName:i.xQA,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=i.backend_util.calculateShapes(s,a,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,a.dtype);const f=Fr({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=Fr({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let x;x=(0,i.OBj)().getBool("WEBGL_PACK")?new Qu(l,u,f.shape.length,m.shape.length,d,p):new Yu(l,u,f.shape.length,m.shape.length,d,p);const b=n.runWebGLProgram(x,[m,f,g],m.dtype),y=Fr({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class Ju{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===(0,i.OBj)().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const el={kernelName:i.nr8,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:a}=t,{side:s}=r,o=new Ju(i.shape[0],i.shape[1],a.shape[1],s),u=[[i.shape[1]]];return n.runWebGLProgram(o,[i,a],"int32",u)}};class tl{constructor(e,t,n){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)i="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],s=[];for(let r=0;r<t.length;r++)s.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),i=s.join()}const a=ee(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const nl={kernelName:i.PhF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new tl(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],(0,i.x8V)(a.dtype,s.dtype))}},rl=Sr({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${i.backend_util.SELU_SCALEALPHA};\n  float scale = ${i.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),il={kernelName:i.oFR,backendName:"webgl",kernelFunc:rl},al=Sr({opSnippet:Ir+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:yn}),sl={kernelName:i.a5O,backendName:"webgl",kernelFunc:al},ol=Sr({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ul={kernelName:i.i5y,backendName:"webgl",kernelFunc:ol},ll=Sr({opSnippet:Ir+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${hr}\n  return result;\n`}),cl={kernelName:i.RQH,backendName:"webgl",kernelFunc:ll},dl=Sr({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),hl={kernelName:i.wYB,backendName:"webgl",kernelFunc:dl},pl=Sr({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),fl={kernelName:i.MRv,backendName:"webgl",kernelFunc:pl},ml={kernelName:i.TQc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;i.D5U.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const u=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const c=[],d=mu({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=i.backend_util.getReshaped(d.shape,s,u,!1),p=i.backend_util.getPermuted(h.length,s.length,!1),f=i.backend_util.getReshapedPermuted(d.shape,s,u,!1),m=Fr({inputs:{x:d},backend:n,attrs:{shape:h}}),g=Gr({inputs:{x:m},backend:n,attrs:{perm:p}}),x=Fr({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(d),c.push(m),c.push(g),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},gl={kernelName:i.O3z,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:i,denseShape:a,defaultValue:s}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);const o=n.readSync(r.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),c=n.readSync(s.dataId)[0],[d,h,p,f,m]=kn(o,r.shape,r.dtype,u,i.dtype,l,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},xl={kernelName:i.nhH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:i,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const s=Array.from(n.readSync(i.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,d]=Cn(o,r.shape,r.dtype,s,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},bl={kernelName:i.w3H,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const s=n.readSync(r.dataId),o=n.readSync(i.dataId),u=n.readSync(a.dataId),[l,c]=In(s,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},yl={kernelName:i.ZjV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const s=n.readSync(r.dataId),o=n.readSync(i.dataId),u=n.readSync(a.dataId),[l,c]=In(s,r.shape,r.dtype,o,u);return n.makeTensorInfo(c,r.dtype,l)}},wl={kernelName:i.D2d,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:u}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=i.backend_util.calculateShapes(s,a,u);if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=i.D5U.decodeString(n.readSync(o.dataId)[0]),f=bn(e,t,u,p,d,c,l,h,r,!1);return n.makeTensorInfo(u,f.dtype,f.values)}const f=new Yu(c,l,a.shape.length,s.shape.length,h,[p,1],!1),m=n.runWebGLProgram(f,[s,a,o],s.dtype),g=Fr({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(m),g}},vl={kernelName:i.L8s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,u=i.D5U.parseAxisParam(o,a.shape)[0],l=i.backend_util.prepareSplitSize(a,s,u),c=a.shape.length,d=new Array(c).fill(0),h=a.shape.slice();return l.map((e=>{const t=[...h];t[u]=e;const r=Mi({inputs:{x:a},backend:n,attrs:{begin:d,size:t}});return d[u]+=e,r}))}},kl="return sqrt(x);",Cl=Sr({opSnippet:kl,packedOpSnippet:kl,cpuKernelImpl:Sn}),Il={kernelName:i.FKq,backendName:"webgl",kernelFunc:Cl},Sl=Sr({opSnippet:"return x * x;"}),$l={kernelName:i.bK0,backendName:"webgl",kernelFunc:Sl},Rl="return (a - b) * (a - b);",Tl=$r({opSnippet:Rl,packedOpSnippet:Rl}),Al={kernelName:i._tC,backendName:"webgl",kernelFunc:Tl},El={kernelName:i.e0R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=n.readSync(a.dataId),o=i.backend_util.fromUint8ToStringArray(s),u=$n(o,"string",r);return n.makeTensorInfo(a.shape,"string",u)}},Nl={kernelName:i.h8e,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=Hn+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new Gn(r.shape,i);return n.runWebGLProgram(a,[r],r.dtype)}};class Dl{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=ee(n.length),a=ee(n.length);let s="";if(1===r)s="coords * strides + begin";else{let e=0;s=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${i} begin = ${i}(${e});\n      ${i} strides = ${i}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}const _l={kernelName:i.jQk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:v}=i.kuN.sliceInfo(a.shape,s,o,u,l,c,d,h,p);let k;if(g)k=Fr({inputs:{x:a},backend:n,attrs:{shape:m}});else if(x||b){i.D5U.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=i.kuN.computeOutShape(y,w,v),t=Mi({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});k=Fr({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=(0,i.f3b)(a.shape,a.dtype,e),r=Rn(f,t,v,y);k=n.makeTensorInfo(m,a.dtype,r.values)}else{const e=new Dl(y,v,f);k=n.runWebGLProgram(e,[a],a.dtype)}const C=Fr({inputs:{x:k},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(k),C}},Fl={kernelName:i._JP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:a,leftPad:s,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=Tn(h,p,i,a,s,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},Pl={kernelName:i.s1s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:i}=r,{input:a,delimiter:s}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);const o=n.readSync(a.dataId),u=n.readSync(s.dataId)[0],[l,c,d]=An(o,u,i),h=c.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}},Ol={kernelName:i.XkS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:i}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(a.dataId),o=En(s,i);return n.makeTensorInfo(a.shape,"int32",o)}},Ul=Sr({opSnippet:"return tan(x);"}),Bl={kernelName:i.sEM,backendName:"webgl",kernelFunc:Ul},Ll=Sr({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),zl={kernelName:i.MIZ,backendName:"webgl",kernelFunc:Ll},Ml={kernelName:i.SIB,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:o}=t,{}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=i.backend_util.calculateShapes(o,s,a.shape),p=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,s.dtype);const f=Fr({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=Fr({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=Fr({inputs:{x:a},backend:n,attrs:{shape:p}}),x=new Yu(l,u,f.shape.length,m.shape.length,d,p,!1,!0),b=n.runWebGLProgram(x,[m,f,g],g.dtype),y=Fr({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class Wl{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=ee(this.rank),i=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function Vl(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>i.D5U.decodeString(e))):e,r=(0,i.f3b)(a.shape,a.dtype,t),o=Dn(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new Wl(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}const Gl={kernelName:i.n9L,backendName:"webgl",kernelFunc:Vl};class Hl{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class jl{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Xl(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function Kl(e){let t=1;for(;t<e;)t*=2;return t}const ql={kernelName:i.cWu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,u=(0,i.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,i.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,d=c[c.length-1];if(n.shouldExecuteOnCPU([a])||d<u||s>l){const e=n.readSync(a.dataId),[t,r]=_n(e,c,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===d)return[a,Ss({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(a.dataId),p=null!==h&&h.isPacked,f=p?n.unpackTensor(a):a,m=i.D5U.sizeFromShape(c)/d,g=Fr({inputs:{x:f},attrs:{shape:[m,d]},backend:n});p&&Xl(n,f);const x=Kl(s),b=Kl(d);let y=null;const w=()=>null===y?[g,g]:[g,y],v=(e,t,r)=>{const i=w(),a=new Hl(r),s=[[d],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=y;y=n.runWebGLProgram(a,i,"int32",s),Xl(n,o)};for(let e=1;e<x;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)v(t,n,[m,b])}for(let e=b;e>x;e/=2){const t=w(),r=new jl([m,e/2]),i=[[d],[null===y?1:0],[x]],a=y;y=n.runWebGLProgram(r,t,"int32",i),Xl(n,a);const s=x/2,o=2*s;for(let e=s;e>=1;e/=2)v(o,e,y.shape)}let k=y;y=Mi({inputs:{x:y},backend:n,attrs:{begin:0,size:[m,s]}}),Xl(n,k);let C=Gs({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Xl(n,g);const I=c.slice(0,-1);I.push(s),k=y,y=Fr({inputs:{x:y},attrs:{shape:I},backend:n}),Xl(n,k);const S=C;return C=Fr({inputs:{x:C},attrs:{shape:I},backend:n}),Xl(n,S),[C,y]}};class Yl{constructor(e,t,n,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const s="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${s} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Ql={kernelName:i.wx7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:a}=t,{interpolation:s,fillMode:o,fillValue:u,outputShape:l}=r,[c,d,h,p]=i.shape,[f,m]=null!=l?l:[d,h],g=new Yl(d,h,s,o,u,[c,f,m,p]);return n.runWebGLProgram(g,[i,a],"float32")}},Zl={kernelName:i.kpP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:i}=n,{x:a}=t;U(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=Pn(s,i,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},Jl={kernelName:i.ToN,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:a}=r;a<0&&(a+=i.shape.length);const s=i,o=s.shape.length,u=i.shape[a],l=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(l[c++]=s.shape[e]);const d=[],h=new Array(o).fill(0),p=s.shape.slice();p[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){h[a]=e;const t=Mi({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),r=Fr({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class ec{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,s=a*Math.ceil(i/n);this.outputShape=[r,s];const o=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let d="";i%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const tc=[Kr,Yr,Zr,ei,ri,si,oi,ui,fi,mi,xi,yi,vi,Ci,Si,Ti,Ai,Di,_i,Fi,Ui,Vi,Gi,Hi,ji,Qi,ea,ra,xr,sa,fa,ka,Ra,Aa,Ea,Na,Da,Fa,Oa,Ba,Ga,Ha,ja,Ka,Qa,es,ts,rs,as,ss,us,ls,ds,ps,ms,xs,ws,Cs,$s,Ts,Ns,_s,Os,Ls,zs,Ws,Hs,Xs,qs,mr,Ys,da,Zs,eo,no,wr,io,so,oo,lo,ho,fo,go,bo,vo,Co,So,Ro,To,Ao,Do,_o,Fo,Po,Oo,Bo,Mo,Vo,Zo,_r,eu,nu,iu,su,Ki,uu,du,hu,gu,bu,Cr,yu,wu,vu,ku,Iu,Yi,jo,$u,Tu,Eu,Pr,_u,Pu,Bu,zu,Vu,Hu,Xu,qu,Zu,el,nl,il,sl,ul,cl,hl,Wi,Qo,fl,ml,gl,xl,bl,yl,wl,vl,Il,$l,Al,El,Nl,_l,Fl,Pl,Ol,qo,Vr,Bl,zl,Ml,Gl,ql,Ql,Hr,Zl,Jl,{kernelName:i.Qvg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r,u=a.shape.length,l=[];let c=0;const d=i.backend_util.getAxesPermutation([c],u);let h=a;null!=d&&(h=Gr({inputs:{x:a},backend:n,attrs:{perm:d}}),l.push(h),c=i.backend_util.getInnerMostAxes(1,u)[0]);const p=i.backend_util.segment_util.computeOutShape(h.shape,c,o),f=i.D5U.sizeFromShape([h.shape[c]]),m=Fr({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=(0,i.z4k)(a.dtype),x=(e,t,r,a,s)=>{const o=e.shape[0],u=e.shape[1],c=i.backend_util.segment_util.segOpComputeOptimalWindowSize(u,s),d=new ec({windowSize:c,inSize:u,batchSize:o,numSegments:s},t),h=n.compileAndRun(d,[e,r],a);if(l.push(h),h.shape[1]===s)return h;const p=Cu({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=Vl({inputs:{x:p},backend:n,attrs:{reps:[u/c]}});return l.push(p),l.push(f),x(h,t,f,a,s)},b=Fr({inputs:{x:x(m,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:p}});let y=b;if(null!=d){l.push(b);const e=i.backend_util.getUndoAxesPermutation(d);y=Gr({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},cu];for(const e of tc)(0,i.wCN)(e)},408:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{addImpl:()=>en,castImpl:()=>Yt,ceilImpl:()=>an,concatImpl:()=>sn,equalImpl:()=>on,expImpl:()=>un,expm1Impl:()=>ln,floorDivImpl:()=>dn,floorImpl:()=>cn,gatherNdImpl:()=>hn,gatherV2Impl:()=>pn,greaterEqualImpl:()=>mn,greaterImpl:()=>fn,lessEqualImpl:()=>xn,lessImpl:()=>gn,logImpl:()=>bn,maxImpl:()=>yn,maximumImpl:()=>wn,minimumImpl:()=>vn,multiplyImpl:()=>kn,negImpl:()=>In,notEqualImpl:()=>Sn,prodImpl:()=>Rn,rangeImpl:()=>Tn,rsqrtImpl:()=>An,scatterImpl:()=>En,simpleAbsImpl:()=>Ht,sliceImpl:()=>Nn,stridedSliceImpl:()=>Dn,stringNGramsImpl:()=>Fn,subImpl:()=>Pn,tileImpl:()=>Un,topKImpl:()=>zn,transposeImpl:()=>$n,uniqueImpl:()=>Mn});var i=n(320);const a=(0,i.OBj)();a.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),a.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),a.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),a.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!0)),a.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),a.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),a.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),a.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),a.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),a.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>0)),a.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),a.registerFlag("WEBGPU_PRINT_SHADER",(()=>""));class s{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class o{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,n=!1,r=!0){let i;const a=u(e,t);return r?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t,n,r=!0){if(0===this.freeBuffers.size)return;const i=u(t,n),a=this.usedBuffers.get(i),s=a.indexOf(e);if(s<0)throw new Error("Cannot find the buffer in buffer manager");a[s]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=t,r?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=t)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function u(e,t){return`${e}_${t}`}class l{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const i=e*t*d(n),a=c(e,t,n,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const e=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(e),e}this.numBytesAllocated+=i;const s=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(a).push(s),s}releaseTexture(e,t,n,r,i){if(0===this.freeTextures.size)return;const a=c(t,n,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const s=this.usedTextures.get(a),o=s.indexOf(e);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");s.splice(o,1);const u=t*n*d(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function c(e,t,n,r){return`${e}_${t}_${n}_${r}`}function d(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function h(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,r=e.map((e=>`${t}.${"xyzwuv"[e]}`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}const p=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`,f=(e,t="f32")=>{switch(e){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component ${t} is not supported.`)}};function m(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function g(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function x(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function b(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const y="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",w="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function v(e,t=""){const n=e.length,r=""!==t?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",a=""!==t?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const s=i.D5U.computeStrides(e),o=m(n),u=[];for(let e=0;e<n;e++)u.push(`d${e}`);if(1===s.length)return`    fn ${r}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${a}; let d1 = index - d0 * uniforms.${a};\n      return vec2<i32>(d0, d1);\n    }`;let l;return l="var index2 = index;"+s.map(((e,t)=>`let ${u[t]} = index2 / uniforms.${a}.${g(t)}; ${t===s.length-1?`let ${u[t+1]} = index2 - ${u[t]} * uniforms.${a}.${g(t)}`:`index2 = index2 - ${u[t]} * uniforms.${a}.${g(t)}`};`)).join(""),`\n    fn ${r}(index : i32) -> ${o} {\n      ${l}\n      return ${o}(${u.join(",")});\n    }\n  `}function k(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:i.D5U.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function C(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function I(e,t=1){if("float32"===e)return f(t,"f32");if("int32"===e||"bool"===e)return f(t,"i32");throw new Error(`type ${e} is not supported.`)}function S(e){return!(e.dispatchLayout.hasOwnProperty("y")&&0!==e.dispatchLayout.y.length||e.dispatchLayout.hasOwnProperty("z")&&0!==e.dispatchLayout.z.length)}const $=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function R(e,t,n=[1,1,1],r=[1,1,1]){const[i,a,s]=[Math.ceil($(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil($(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil($(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[i,a,s]}function T(e,t,n=!1){if(n)return[8,8,1];const r=$(e.x.map((e=>t[e]))),i=$(e.y.map((e=>t[e])));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function A(e,t,n=!1){if(n)return[4,4,1];const r=$(e.x.map((e=>t[e]))),i=$(e.y.map((e=>t[e])));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function E(e){return{x:e.map(((e,t)=>t))}}function N(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function D(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function _(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGPU backend.`))}))}var F;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(F||(F={}));const P=(0,i.OBj)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class O extends i.Zuw{nextDataId(){return O.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!D())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new s(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new o(this.device),this.textureManager=new l(this.device),this.tensorMap=new i.JLz(this,(0,i.SRH)()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),(0,i.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage,!1))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),(0,i.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(i.D5U.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n,complexTensorInfos:r}=t;if(null!=n||"string"===t.dtype)return n;if("complex64"===t.dtype){const t=this.readSync(r.real.dataId),n=this.readSync(r.imag.dataId),a=i.D5U.convertBackendValuesAndArrayBuffer(i.backend_util.mergeRealAndImagArrays(t,n).buffer,"float32");return this.convertAndCacheOnCPU(e,a),a}const a=["opaque","premultiplied"],s=t.resourceInfo,o=s.size;i.D5U.assert(o%4==0,(()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."));const u=o/4,l=new ArrayBuffer(o),c=256,d=a.map((e=>new OffscreenCanvas(c,256))),h=new OffscreenCanvas(c,256);this.ensureComputePassEnded(),d.map(((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[t]}),n.getCurrentTexture()})).map(((e,t)=>{const n=(n,r,i)=>{this.ensureCommandEncoderReady(),this.currentCommandEncoder.copyBufferToTexture({buffer:s.buffer,bytesPerRow:1024,offset:i},{texture:e},{width:n,height:r}),this.submitQueue();const o=h.getContext("2d",{willReadFrequently:!0});o.clearRect(0,0,n,r),o.drawImage(d[t],0,0);const u=o.getImageData(0,0,n,r).data,c=a[t],p=new Uint8ClampedArray(l,i,n*r*4);for(let e=0;e<p.length;e+=4)if("premultiplied"===c)p[e+3]=u[e+3];else{const t=u[e];p[e]=u[e+2],p[e+1]=u[e+1],p[e+2]=t}},r=Math.floor(u/65536);let i=c,o=256,p=0;for(let e=0;e<r;e++)n(i,o,p),p+=262144;const f=u%65536;o=Math.floor(f/c),o>0&&(n(i,o,p),p+=1024*o),i=f%c,i>0&&n(i,1,p)}));const p=i.D5U.convertBackendValuesAndArrayBuffer(l,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return n;let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],a=e[1];r=i.backend_util.mergeRealAndImagArrays(n,a)}else{const e=t.resourceInfo,n=await this.getBufferData(e.buffer,e.size);r=i.D5U.convertBackendValuesAndArrayBuffer(n,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e,t,n){const r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let r=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const a={id:this.nextDataId()};this.tensorMap.set(a,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const s=this.tensorMap.get(a),o=N(s.dtype)*i.D5U.sizeFromShape(s.shape);if(e.buffer.size<o)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(r=this.copyBuffer(r,o,r.usage)),s.resourceInfo={size:r.size,usage:r.usage,buffer:r},(0,i.SRH)().makeTensorFromDataId(a,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:a,resourceInfo:s}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==s)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=s.size,u=this.bufferManager.acquireBuffer(o,s.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s.buffer,0,u,0,o),this.submitQueue();const l=this.makeTensorInfo(a,r),c=(0,i.SRH)().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:c,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>i.D5U.decodeString(e)));return(0,i.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,i.f3b)(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=i.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=i.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(a);return o.kernelMs=i.D5U.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){return"string"===t&&null!=n&&n.length>0&&i.D5U.isString(n[0])&&(n=n.map((e=>i.D5U.encodeString(e)))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=N(t.dtype)*i.D5U.sizeFromShape(t.shape);let r;if(t.values){if(r=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage(),!0),"unmapped"===r.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),i=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,n),this.stagingPendingDisposal.push({size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e})}else{const e=r.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:r}}makeUniforms(e){let t=0,n=0;const r=[];let a=1;e.forEach((e=>{let s;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:s=4;break;case 2:s=8;break;case 3:case 4:case 5:case 6:s=16;break;default:i.D5U.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(s=16),s>a&&(a=s),t=Math.ceil(t/s)*s,n=e.data.length,r.push(t),t+=4*e.data.length})),t=Math.ceil(t/a)*a;const s=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=r[t];"int32"===e.type?new Int32Array(s,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(s,n,e.data.length).set(e.data):new Float32Array(s,n,e.data.length).set(e.data)}));const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(o,0,s,0,t);const u={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:o};return this.uniformPendingDisposal.push(u),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,t,n,r,a){if(a||(a=this.makeTensorInfo(e.outputShape,n)),0===i.D5U.sizeFromShape(a.shape))return this.tensorMap.get(a.dataId).values=i.D5U.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,r=t.dispatchLayout,a=t.dispatch;if(a.every((e=>e<=n)))return a;i.D5U.assert(a[0]>n&&void 0===r.y&&void 0===r.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let s=Math.ceil(Math.sqrt(a[0]));return s>n?(s=Math.ceil(Math.cbrt(a[0])),i.D5U.assert(s<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[s,s,s]):[s,s,1]})(this.device,e);let s=[],o=[];if(!e.isFromPixels){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=t.concat(a).map((e=>e.shape));const n="int32";if(o.map((e=>{s.push({type:n,data:e});const t=i.D5U.computeStrides(e);s.push({type:n,data:t})})),e.size){const t=i.D5U.sizeFromShape(e.outputShape);s.push({type:n,data:[e.outputComponent?t/e.outputComponent:t]})}}const u=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),l=function(e,t,n,r){let a=e.shaderKey;if(e.isFromPixels)return a;const s=n.map((e=>e.dtype)).concat(r.dtype),o=n.map((e=>i.backend_util.getBroadcastDims(e.shape,r.shape))),u=n.map((e=>i.D5U.arraysEqual(e.shape,r.shape))).join("_"),l=o.map((e=>e.join("_"))).join(";"),c=C(e)?"flatDispatch":"";return a+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+t.map((e=>e.length)).join(",")+s.join(",")+e.variableNames.join(",")+l+u+c,a}(e,o,u,a);let c;l in this.pipelineCache?c=this.pipelineCache[l]:(c=((e,t,n,r,a)=>{const s=function(e,t,n){const r=[],a=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${C(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${a}u +\n                localIndex);\n        `}\n      }\n    `),n.isFromPixels){r.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${I(t.dtype,n.outputComponent)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const e=S(n);return[y,r.join("\n"),v(t.shape),n.getUserCode(),b(e,n)].join("\n")}let s,o,u="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(((t,n)=>{const r=m(e[n].shape.length);u+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `,s=e[n].shape.length-1,o=m(s),u+=`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides: ${o}, `}));const l=m(t.shape.length);u+=`outShape : ${l}, `,s=t.shape.length-1,o=m(s),u+=`\n         outShapeStrides: ${o}, `,n.size&&(u+="size : i32, "),n.uniforms&&(u+=n.uniforms),u+="};",u=u.replace(/(\w+)\s*:\s*vec(5|6)/g,(e=>"@align(16) "+e)).replace(/vec(5|6)\s*,\s*(\w+)/g,((e,t,n)=>`vec${t}, @align(16) ${n}`)),r.push(u),n.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${I(t.dtype,n.outputComponent)}>;\n    `),n.variableNames.forEach(((t,i)=>{r.push(`\n      @group(0) @binding(${1+i}) var<storage, read> ${t}: array<${n.variableComponents?I(e[i].dtype,n.variableComponents[i]):I(e[i].dtype,n.outputComponent)}>;\n        `)})),""!==u&&r.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const c=function(e,t){const{x:n,y:r=[],z:i=[]}=t,a=e.length,s=n.length+r.length+i.length;if(s!==a)return"";if(n.length===a)return`fn getOutputCoords() -> ${m(a)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;let o="";const u=[n,r,i];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=h(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<s;e++)l.push(`d${e}`);const c=m(s);let d=`fn getOutputCoords() -> ${c} {\n  ${o}\n`;return 0===l.length?d+=`return ${c}(0); }`:d+=`return ${c}(${l.join(",")}); }`,d}(t.shape,n.dispatchLayout),d=[y,r.join("\n")+w,v(t.shape),c,k(t.shape.length)];n.atomic||d.push(function(e,t,n){const r=e.length,i=I(t,n);let a=`fn setOutputAtIndex(flatIndex : i32, value : ${f(n)}) {\n      result[flatIndex] = ${i}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${f(n,"i32")}) {\n      result[flatIndex] = ${i}(value);\n    }\n    `;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=m(r);a+=`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${f(n)}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${f(n,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n    `}return a}(t.shape,t.dtype,n.outputComponent)),n.variableNames.forEach(((t,n)=>{d.push(`${v(e[n].shape,t)}`)}));const p=e.map(((e,r)=>function(e,t,n,r){let a=function(e,t){const n=e.name,r=e.shape.length,i=m(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=s.map((e=>`${e} : i32`)).join(", ");if(r<1)return`\n      fn ${a}() -> ${f(t)} {\n        return ${f(t)}(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${r}D`;return 0===r&&(l="1D"),`\n    fn ${a}(${o}) -> ${f(t)} {\n      return ${f(t)}(${n}[getIndexFromCoords${l}(${i}(${s.join(",")}),\n        ${u})${1===t?"":` / ${t}`}]);\n    }\n   `}(e,n);return e.shape.length<=t.length&&(a+=function(e,t,n,r){const a=e.name,s=a.charAt(0).toUpperCase()+a.slice(1),o="get"+s+"ByOutput",u=e.shape.length,l=t.length,c=m(l);if(i.D5U.arraysEqual(e.shape,t)&&r)return`\n    fn ${o}Index(globalIndex : i32) -> ${f(n)} {\n      return ${f(n)}(${a}[globalIndex]);\n    }\n\n    fn ${o}Coords(coords : ${c}) -> ${f(n)} {\n      return ${f(n)}(${a}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${1===n?"":` / ${n}`}]);\n    }\n    `;const d=i.backend_util.getBroadcastDims(e.shape,t),h=l-u;let p="";if(0===u)return`\n    fn ${o}Index(globalIndex : i32) -> ${f(n)}{\n      return get${s}();\n    }\n\n    fn ${o}Coords(coords : ${c}) -> ${f(n)}{\n      return get${s}();\n    }\n  `;p=l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${g(e+h)} = 0;`)).join("\n");let x="";if(l<2&&u>0)x="coords";else if(l>1){const t=m(u),n=e.shape.map(((e,t)=>`coords.${g(t+h)}`)).join(", ");x=`${t}(${n})`}else x="coords";const b=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,y=`${u}D`;return`\n  fn ${o}Index(globalIndex : i32) -> ${f(n)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${p}\n    return ${f(n)}(${a}[getIndexFromCoords${y}(${x}, ${b})${1===n?"":` / ${n}`}]);\n  }\n\n  fn ${o}Coords(coordsIn : ${c}) -> ${f(n)} {\n    var coords = coordsIn;\n    ${p}\n    return ${f(n)}(${a}[getIndexFromCoords${y}(${x}, ${b})${1===n?"":` / ${n}`}]);\n  }\n`}(e,t,n,r)),a}(e,t.shape,n.variableComponents?n.variableComponents[r]:n.outputComponent,n.dispatchLayout.x.length===t.shape.length))).join("\n");d.push(p),d.push(n.getUserCode());const x=S(n);return d.push(b(x,n)),d.join("\n")}(n,{dtype:r.dtype,shape:r.shape},t),o=e.createShaderModule({code:s,label:t.constructor.name}),u=e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"});let l=(0,i.OBj)().get("WEBGPU_PRINT_SHADER");if(""!==l){l=l.toLowerCase();const e=l.split(",");("all"===l||e.some((e=>a.toLowerCase().includes(e))))&&(console.group(a),console.debug(s),console.groupEnd())}return u})(this.device,e,u,a,l),this.pipelineCache[l]=c),r&&(s=[...s,...r]);const d=[this.tensorToBinding(a),...t.map((e=>this.tensorToBinding(e))),this.makeUniforms(s)],p=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:d.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const x=this.getComputePass(),$=null!=this.activeTimers;return $&&this.supportTimeQuery&&x.writeTimestamp(this.querySet,0),x.setPipeline(c),x.setBindGroup(0,p),x.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),$&&this.supportTimeQuery&&x.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(a.dataId),(0,i.OBj)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),$&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),a}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),i/1e6}shouldExecuteOnCPU(e,t=P){return(0,i.OBj)().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&i.D5U.sizeFromShape(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var U;O.nextDataId=0,D()&&(0,i.jqO)("webgpu",(async()=>{const e={powerPreference:(0,i.OBj)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={};t.features.has("timestamp-query-inside-passes")&&(n.requiredFeatures=["timestamp-query-inside-passes"]);const r=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const a=await t.requestDevice(n),s=await t.requestAdapterInfo();return new O(a,s)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.GREATER=7]="GREATER",e[e.GREATER_EQUAL=8]="GREATER_EQUAL",e[e.INT_DIV=9]="INT_DIV",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(U||(U={}));const B="\n  resultTemp = select(resultTemp, valueForNaN, isNaN | isnan(a) | isnan(b));",L="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",z="return a + b;",M="var resultTemp = atan2(a, b);",W="return areal * breal - aimag * bimag;",V="return areal * bimag + aimag * breal;",G="return a / b;",H="return select(a * (b + 1.0), a, b >= 0.);",j="return select(a * (b + vec4<f32>(1.0)), a, b >= vec4<f32>(0.));",X="return f32(a == b);",K="return vec4<f32>(a == b);",q="return f32(a > b);",Y="return vec4<f32>(a > b);",Q="return f32(a >= b);",Z="return vec4<f32>(a >= b);",J="\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n",ee="\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n",te="return f32(a < b);",ne="return vec4<f32>(a < b);",re="return f32(a <= b);",ie="return vec4<f32>(a <= b);",ae="return f32(a >= 1.0 && b >= 1.0);",se="return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));",oe="return f32(a >= 1.0 || b >= 1.0);",ue="return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));",le="var resultTemp = max(a, b);",ce="var resultTemp = min(a, b);",de="\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n",he="\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n",pe="return a * b;",fe="\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n",me="\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n",ge="\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n",xe="\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n",be="if (a < 0.0) { return b * a; }  return a;",ye="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",we="return (a - b) * (a - b);",ve="return a - b;";function ke(e,t){do{let n;switch(e){case U.ATAN2:n=M;break;case U.MAX:n=le;break;case U.MIN:n=ce;break;case U.MOD:n=t?he:de;break;case U.NOT_EQUAL:n=t?me:fe;break;case U.POW:n=t?xe:ge;break;default:continue}return`\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        ${n}\n        ${t?L:B}\n        return resultTemp;\n      }\n    `}while(0);switch(e){case U.ADD:return z;case U.COMPLEX_MULTIPLY_IMAG:return V;case U.COMPLEX_MULTIPLY_REAL:return W;case U.DIV:return G;case U.ELU_DER:return t?j:H;case U.EQUAL:return t?K:X;case U.GREATER:return t?Y:q;case U.GREATER_EQUAL:return t?Z:Q;case U.INT_DIV:return t?ee:J;case U.LESS:return t?ne:te;case U.LESS_EQUAL:return t?ie:re;case U.LOGICAL_AND:return t?se:ae;case U.LOGICAL_OR:return t?ue:oe;case U.MUL:return pe;case U.PRELU:return t?ye:be;case U.SQUARED_DIFFERENCE:return we;case U.SUB:return ve;default:throw new Error(`BinaryType ${e} is not implemented!`)}}var Ce;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(Ce||(Ce={}));const Ie="return abs(a);",Se="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n",$e="\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n",Re="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n",Te="return asinh(a);",Ae="\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n",Ee="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n",Ne="return ceil(a);",De="return cos(a);",_e="\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n",Fe="return exp(a) - 1.0;",Pe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Oe="\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n",Ue=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${i.backend_util.ERF_P};\n  let a1 = ${i.backend_util.ERF_A1};\n  let a2 = ${i.backend_util.ERF_A2};\n  let a3 = ${i.backend_util.ERF_A3};\n  let a4 = ${i.backend_util.ERF_A4};\n  let a5 = ${i.backend_util.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,Be="return exp(a);",Le="return floor(a);",ze="return f32(!isnan(a) && !isinf(a));",Me="return f32(isinf(a));",We="return f32(isnan(a));",Ve="return a;",Ge="if (a < 0.0) { return uniforms.NAN; }\n  return log(a);",He="\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n",je="return f32(!(a >= 1.0));",Xe="return -a;",Ke="if (a < 0.0) { return uniforms.alpha * a; } return a;",qe="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",Ye="return 1.0 / a;",Qe="return select(a, 0.0, a < 0.0);",Ze="return clamp(a, 0.0, 6.0);",Je="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",et="\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n",tt="return round(a);",nt="return inverseSqrt(a);",rt=`\n  if (a >= 0.0) {\n    return ${i.backend_util.SELU_SCALE} * a;\n  } else {\n    return ${i.backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`,it="return 1.0 / (1.0 + exp(-1.0 * a));",at="return sign(a);",st="return sin(a);",ot="\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n",ut="\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n",lt="return sqrt(a);",ct="return a * a;",dt="\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n",ht="return tan(a);",pt="\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n",ft="return f32(i32((a)));";function mt(e,t){switch(e){case Ce.ABS:return Ie;case Ce.ACOS:return Se;case Ce.ACOSH:return $e;case Ce.ASIN:return Re;case Ce.ASINH:return Te;case Ce.ATAN:return Ae;case Ce.ATANH:return Ee;case Ce.COS:return De;case Ce.COSH:return _e;case Ce.CEIL:return Ne;case Ce.ELU:return t?Oe:Pe;case Ce.ERF:return Ue;case Ce.EXP:return Be;case Ce.EXPM1:return Fe;case Ce.FLOOR:return Le;case Ce.IS_FINITE:return ze;case Ce.IS_INF:return Me;case Ce.IS_NAN:return We;case Ce.LINEAR:return Ve;case Ce.LOG:return Ge;case Ce.LOG1P:return He;case Ce.LOGICAL_NOT:return je;case Ce.NEG:return Xe;case Ce.LEAKYRELU:return t?qe:Ke;case Ce.RECIPROCAL:return Ye;case Ce.RELU:return t?et:Qe;case Ce.RELU6:return t?Je:Ze;case Ce.ROUND:return tt;case Ce.RSQRT:return nt;case Ce.SELU:return rt;case Ce.SIGMOID:return it;case Ce.SIGN:return at;case Ce.SIN:return st;case Ce.SINH:return ot;case Ce.SOFTPLUS:return ut;case Ce.SQRT:return lt;case Ce.SQUARE:return ct;case Ce.STEP:return dt;case Ce.TAN:return ht;case Ce.TANH:return pt;case Ce.TO_INT:return ft;default:throw new Error(`BinaryType ${e} is not implemented!`)}}function gt(e,t=!1,n=!1,r=3){if(null===e)return"";let i="";if("linear"===e)i=mt(Ce.LINEAR);else if("relu"===e)i=mt(Ce.RELU,n);else if("elu"===e)i=mt(Ce.ELU,n);else if("relu6"===e)i=mt(Ce.RELU6,n);else if("prelu"===e)i=ke(U.PRELU,n);else if("sigmoid"===e)i=mt(Ce.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);i=mt(Ce.LEAKYRELU,n)}const a=f(n?4:1);let s="";return s=t?`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${i}\n      }`:`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        ${i}\n      }`,s}function xt(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function bt(e,t,n=!1,r=!1,a=!1,s=1){i.D5U.assert(e&&1===s||!e,(()=>`transposeA ${e} is not compatible with component size ${s}`));const o=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${f(s)} {\n    var value = ${f(s)}(0.0);\n    let col = colIn * ${s};\n    ${n&&a?o:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${f(s)} {\n    let col = colIn * ${s};\n    var value = ${f(s)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function yt(e,t,n,r,i=!1,a=!1,s=!1,o=1){return`\n  ${bt(n,r,i,a,s,o)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${f(o)}) {\n    let col = colIn * ${o};\n    ${i&&a?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${xt(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function wt(e,t,n=!1,r=32,a=!1,s=32,o=!1){const u=t[1]*e[1],l=t[0]*e[0],c=n?u:r,d=n?r:u,h=c/t[0],p=r/t[1],f=e[1];return i.D5U.assert((n&&4===h&&4===e[1]||!n&&(3===h||4===h))&&c%t[0]==0&&r%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${h} must be 3 or 4.\n      tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/e[0]}>, ${r}>;\n\n  ${x()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${f};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${f};\n    let globalCol = i32(globalId.x);\n    let batch = ${a?"0":"i32(globalId.z)"};\n    let batchA = ${a||!o?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${a||!o?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${u};\n\n    let numTiles = ${a?`${Math.ceil(s/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};\n    var kStart = ${a?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc: array<vec4<f32>, ${f}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${p};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ${t} + inputCol);\n        `)(n,h)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${r/h}; k++) {\n            let BCached0 = mm_Bsub[k * ${h}][tileCol];\n            let BCached1 = mm_Bsub[k * ${h} + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ${h} + 2][tileCol];\n            ${3===h?"":`let BCached3 = mm_Bsub[k * ${h} + 3][tileCol];`}\n\n            ${((e,t,n)=>e?`\n        let ACached0 = mm_Asub[k * ${t}][localRow];\n        let ACached1 = mm_Asub[k * ${t} + 1][localRow];\n        let ACached2 = mm_Asub[k * ${t} + 2][localRow];\n        ${3===t?"":`let ACached3 = mm_Asub[k * ${t} + 3][localRow];`}\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n          acc[i] = fma(BCached1, vec4<f32>(ACached1[i]), acc[i]);\n          acc[i] = fma(BCached2, vec4<f32>(ACached2[i]), acc[i]);\n          ${3===t?"":"acc[i] = fma(BCached3, vec4<f32>(ACached3[i]), acc[i]);"}\n        }`:`\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = fma(BCached0, vec4<f32>(ACached.x), acc[i]);\n          acc[i] = fma(BCached1, vec4<f32>(ACached.y), acc[i]);\n          acc[i] = fma(BCached2, vec4<f32>(ACached.z), acc[i]);\n          ${3===t?"":"acc[i] = fma(BCached3, vec4<f32>(ACached.w), acc[i]);"}\n        }`)(n,h,f)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const vt=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function kt(e,t,n=!1,r=32,a=!1,s=32,o=!1,u=!1){const l=e[1]*t[1],c=e[0]*t[0],d=n?l:r,h=n?r:l;i.D5U.assert(h%t[1]==0&&d%t[0]==0&&r%t[1]==0,(()=>`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${r} must be divisible by workgroupSize[1]${t[1]}`));const p=h/t[1],f=d/t[0],m=r/t[1],g=e[1],b=e[0],y=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${c};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n            ${vt(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${b}>;\n        for (var k = 0; k < ${r}; k++) {\n          for (var inner = 0; inner < ${b}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${b};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${b};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${p};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${vt(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${r};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${b}>;\n    for (var k = 0; k < ${r}; k++) {\n      for (var inner = 0; inner < ${b}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${h}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;\n\n    ${x()} {\n      let batch = ${a?"0":"i32(globalId.z)"};\n      let batchA = ${a||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${a||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${a?`${Math.ceil(s/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};\n      var kStart = ${a?`i32(globalId.z) * ${s}`:"0"};\n\n      var acc : array<array<f32, ${b}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${y}\n    }\n  `}class Ct{constructor(e,t,n=!1,r=!1,i=null,a=null,s=null,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n,r=!1){const i=[8,8,1],a=[4,4,1];return r||(e<=8&&(a[1]=1),t<=16&&n<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:a}}(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=i,c=null!=s;l&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=i,[e%r==0,t%i==0,n%this.tileInner==0]}getUserCode(){return`\n      ${gt(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${yt(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?wt(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e,t=!1){i.D5U.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${x()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${r=t,r?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  "});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `;var r}(this.workgroupSize,this.transposeA):kt(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `}}class It{constructor(e,t=!1,n=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize);const s=null!=r,o=null!=a;s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=s,this.activation=i,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${gt(this.activation,this.hasPreluActivationWeights)}\n      ${yt(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${x()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class St{constructor(e,t,n,r=!1,i=!1,a=null,s=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=a;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=s,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`\n      ${gt(this.activation,this.hasPreluActivationWeights)}\n      ${yt(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${x()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class $t{constructor(e,t,n=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,i.D5U.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const a=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=a?4:1,a||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=R(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=r,this.shaderKey=`matMulSplitK_${n}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`\n      ${bt(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${f(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${p("&result[flatIndex + i]",e>1?"value[i]":"value","float32")}\n          }\n        }\n      }\n      ${4===e?wt(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):kt(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class Rt{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${gt(this.activation,this.hasPreluActivationWeights)}\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${xt(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class Tt{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function At(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||i.D5U.inferDtype(a),"string"===s){const e=i.D5U.getArrayFromDType(s,i.D5U.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new Tt(r),n=[{type:"float32",data:[a]}];return t.runWebGPUProgram(e,[],s,n)}}const Et={kernelName:i.deh,backendName:"webgpu",kernelFunc:At};function Nt(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=i.D5U.sizeFromShape(r.shape),o=i.D5U.inferFromImplicitShape(a,s),u=i.D5U.sizeFromShape(o);return i.D5U.assert(s===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const Dt={kernelName:i.HZH,backendName:"webgpu",kernelFunc:Nt};function _t({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const c=e.shape.length,d=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],p=r?t.shape[d-1]:t.shape[d-2],f=n?e.shape[c-1]:e.shape[c-2],m=r?t.shape[d-2]:t.shape[d-1],g=e.shape.slice(0,-2),x=t.shape.slice(0,-2),b=i.D5U.sizeFromShape(g),y=i.D5U.sizeFromShape(x),w=i.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);i.D5U.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const v=n?[b,h,f]:[b,f,h],k=r?[y,m,p]:[y,p,m],C=Nt({inputs:{x:e},backend:a,attrs:{shape:v}}),I=Nt({inputs:{x:t},backend:a,attrs:{shape:k}}),S=[C,I],$=Math.max(b,y),R=[C,I],T=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[h]}];let A,E;const N=[$,f,m];let D=(0,i.OBj)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(D<0){const e=(0,i.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:a.thresholdToIncreaseWorkgroups,n=$*Math.ceil(f/32)*Math.ceil(m/32);D=n<=t||f<=8&&n<=2*t?$*f*m<=128?F.MatMulReduceProgram:1===$&&p>=2e3?F.MatMulSplitKProgram:F.MatMulSmallOutputSizeProgram:F.MatMulPackedProgram}switch(D){case F.MatMulReduceProgram:A=new It(N,n,r,s,l,o);break;case F.MatMulSplitKProgram:if(E=At({backend:a,attrs:{shape:N,value:0,dtype:e.dtype}}),A=new $t(N,p,n,r),s||l){E=a.runWebGPUProgram(A,R,e.dtype,T,E);const t=new Rt(E.shape,s,l,o);let n=null;const r=[E];s&&r.push(s),o&&r.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],t.uniforms+=" alpha : f32,");const i=a.runWebGPUProgram(t,r,E.dtype,n);S.push(E);const c=Nt({inputs:{x:i},backend:a,attrs:{shape:w}});S.push(i);for(const e of S)a.disposeData(e.dataId);return c}break;case F.MatMulSmallOutputSizeProgram:A=new St(v,k,N,n,r,s,l,o);break;case F.MatMulPackedProgram:const t=a.adapterInfo.isIntel();A=new Ct(v,N,n,r,s,l,o,t);break;default:throw new Error(`Unsupported MatMulProgramType ${D}.`)}s&&R.push(s),o&&R.push(o),"leakyrelu"===l&&(T.push({type:"float32",data:[u]}),A.uniforms+=" alpha : f32,"),E=a.runWebGPUProgram(A,R,e.dtype,T,E);const _=Nt({inputs:{x:E},backend:a,attrs:{shape:w}});S.push(E);for(const e of S)a.disposeData(e.dataId);return _}const Ft={kernelName:i.usg,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a,bias:s,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return _t({a:i,b:a,transposeA:u,transposeB:l,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}};class Pt{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${ke(this.op,!1)}\n      }\n\n      ${x("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Ot{constructor(e,t,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=E(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4==0,a=n.length>0&&n[n.length-1]%4==0;r&&a?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(i.D5U.isScalarShape(n)||1===n[n.length-1])||a&&(i.D5U.isScalarShape(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${ke(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${x("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${x("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${t}(getAByOutputCoords(coords));\n           let b = ${t}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function Ut(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Bt={kernelName:i.iJz,backendName:"webgpu",kernelFunc:Ut};function Lt(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.makeTensorInfo(r.shape,"complex64"),s=n.tensorMap.get(a.dataId),o=Ut({inputs:{x:r},backend:n}),u=Ut({inputs:{x:i},backend:n});return s.complexTensorInfos={real:o,imag:u},a}const zt={kernelName:i.Zz9,backendName:"webgpu",kernelFunc:Lt};class Mt{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${mt(this.op,!1)}\n      }\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function Wt({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:i})=>{const{x:a}=r,s=i,o=n||a.dtype;if(s.shouldExecuteOnCPU([a])&&null!=t){const e=s.tensorMap.get(a.dataId),n=t(e.values,o);return s.makeTensorInfo(a.shape,o,n)}const u=new Mt(a.shape,e);return s.runWebGPUProgram(u,[a],o)}}function Vt({opType:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:a,backend:s})=>{const{a:o,b:u}=a,l=s;if(n&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(u.dataId);let r,a;if(e!==U.MUL)[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:o.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},c=new Ot(e,o.shape,u.shape);return l.runWebGPUProgram(c,[a,s],(0,i.x8V)(n.dtype,r.dtype))}));else{const e=new Pt(U.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),i=new Pt(U.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),s=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];r=l.runWebGPUProgram(e,s,"float32"),a=l.runWebGPUProgram(i,s,"float32")}const s=Lt({inputs:{real:r,imag:a},backend:l});return l.disposeData(r.dataId),l.disposeData(a.dataId),s}const c=r||(0,i.x8V)(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,n=l.tensorMap.get(u.dataId).values,r="string"===o.dtype?i.backend_util.fromUint8ToStringArray(e):e,a="string"===o.dtype?i.backend_util.fromUint8ToStringArray(n):n,[s,d]=t(o.shape,u.shape,r,a,c);return l.makeTensorInfo(d,c,s)}const d=new Ot(e,o.shape,u.shape);return l.runWebGPUProgram(d,[o,u],c)}}function Gt(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function Ht(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function jt(e){return(t,n,r,a,s)=>{const o=i.backend_util.assertAndGetBroadcastShape(t,n),u=o.length,l=i.D5U.computeStrides(o),c=i.D5U.sizeFromShape(o),d=i.D5U.getTypedArrayFromDType(s,c),h=t.length,p=n.length,f=i.D5U.computeStrides(t),m=i.D5U.computeStrides(n),g=i.backend_util.getBroadcastDims(t,o),x=i.backend_util.getBroadcastDims(n,o);if(g.length+x.length===0)for(let t=0;t<d.length;++t)d[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<d.length;++t){const n=i.D5U.indexToLoc(t,u,l),s=n.slice(-h);g.forEach((e=>s[e]=0));const o=i.D5U.locToIndex(s,h,f),c=n.slice(-p);x.forEach((e=>c[e]=0));const b=i.D5U.locToIndex(c,p,m);d[t]=e(r[o],a[b])}return[d,o]}}function Xt(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(i.shape,"float32",s)},o}function Kt(e,t,n="float32"){if("complex64"===n)return Xt({inputs:{real:Kt(e,t,"float32"),imag:Kt(e,t,"float32")},backend:e});const r=i.D5U.makeZerosTypedArray(i.D5U.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function qt(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Yt(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=i.D5U.toTypedArray([0],n),[a,s]=jt(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Qt(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return qt({inputs:{x:a},backend:n});const e=Kt(n,a.shape,a.dtype),t=Qt({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Xt({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=function(e){const{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}({inputs:{input:a},backend:n}),t=Qt({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!i.D5U.hasEncodingLoss(a.dtype,s)){const e=qt({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const o=n.data.get(a.dataId).values,[u,l,c]=Yt(o,a.shape,a.dtype,s);return n.makeTensorInfo(u,l,c)}function Zt(e,t,n,r){return null==n?({inputs:n,backend:a})=>{const{a:s,b:o}=n,u=a;Gt([s,o],e);const l=u.data.get(s.dataId).values,c=u.data.get(o.dataId).values,d="string"===s.dtype?i.backend_util.fromUint8ToStringArray(l):l,h="string"===s.dtype?i.backend_util.fromUint8ToStringArray(c):c,p=r||s.dtype,[f,m]=t(s.shape,o.shape,d,h,p);return u.makeTensorInfo(m,p,f)}:({inputs:e,backend:i})=>{const{a,b:s}=e,o=i;if("complex64"===a.dtype||"complex64"===s.dtype){const e=Qt({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,i=t.complexTensorInfos.imag,u=o.data.get(r.dataId).values,l=o.data.get(i.dataId).values,c=Qt({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=o.data.get(h.dataId).values,m=o.data.get(p.dataId).values,[g,x,b]=n(a.shape,s.shape,u,l,f,m),y=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",x),v=Xt({inputs:{real:y,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(w),v}{const e=o.data.get(a.dataId).values,n=o.data.get(s.dataId).values,i=r||a.dtype,[u,l]=t(a.shape,s.shape,e,n,i);return o.makeTensorInfo(l,i,u)}}}function Jt(e){return(t,n,r,a,s,o)=>{const u=i.backend_util.assertAndGetBroadcastShape(t,n),l=i.D5U.sizeFromShape(u),c=u.length,d=i.D5U.computeStrides(u),h=i.D5U.getTypedArrayFromDType("float32",l),p=i.D5U.getTypedArrayFromDType("float32",l),f=i.backend_util.getBroadcastDims(t,u),m=i.backend_util.getBroadcastDims(n,u),g=i.backend_util.mergeRealAndImagArrays(r,a),x=i.backend_util.mergeRealAndImagArrays(s,o),b=t.length,y=i.D5U.computeStrides(t),w=n.length,v=i.D5U.computeStrides(n);if(f.length+m.length===0)for(let t=0;t<h.length;t++){const n=t%g.length,r=t%x.length,i=e(g[2*n],g[2*n+1],x[2*r],x[2*r+1]);h[t]=i.real,p[t]=i.imag}else for(let t=0;t<h.length;t++){const n=i.D5U.indexToLoc(t,c,d),r=n.slice(-b);f.forEach((e=>r[e]=0));const a=i.D5U.locToIndex(r,b,y),s=n.slice(-w);m.forEach((e=>s[e]=0));const o=i.D5U.locToIndex(s,w,v),u=e(g[2*a],g[2*a+1],x[2*o],x[2*o+1]);h[t]=u.real,p[t]=u.imag}return[h,p,u]}}i.SYM,i.Zz9,i.iJz,i.xJR,i.RFZ;const en=jt(((e,t)=>e+t)),tn=Jt(((e,t,n,r)=>({real:e+n,imag:t+r})));function nn(e){return(t,n,r)=>{const a=i.D5U.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}function rn(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;Gt(o,e);const u=s,l=u.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=i.backend_util.fromUint8ToStringArray(l)}else c=l;const d=n||o.dtype,h=t(c,d,a);return u.makeTensorInfo(o.shape,d,h)}}Zt(i.mm_,en,tn),i.mm_;const an=nn((e=>Math.ceil(e)));function sn(e,t,n,r){const a=i.D5U.getArrayFromDType(n,i.D5U.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=i.D5U.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?i.backend_util.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[i+t]=s[o++]}r+=e.shape[1]}))}return a}rn(i.gJX,an),i.gJX;const on=jt(((e,t)=>e===t?1:0)),un=(Zt(i.hdR,on,null,"bool"),i.hdR,nn((e=>Math.exp(e)))),ln=(rn(i.NEP,un,"float32"),i.NEP,nn((e=>Math.expm1(e)))),cn=(rn(i.Y0y,ln),i.Y0y,nn((e=>Math.floor(e)))),dn=(rn(i.OR,cn),i.OR,jt(((e,t)=>Math.floor(e/t))));function hn(e,t,n,r,a,s,o,u,l){const c=(0,i.f3b)([r,s],n);for(let n=0;n<r;n++){const r=[];let i=0;for(let t=0;t<a;t++){const s=e[n*a+t];i+=s*o[t],r.push(s)}if(i<0||i>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<s;e++)c.values[n*s+e]=t.get(...t.indexToLoc(i*s+e))}return c}function pn(e,t,n){const r=(0,i.f3b)(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),a=i[0],s=i[2],o=t.locToIndex([a,s]);i[2]=t.values[o];const u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r}Zt(i.jeX,dn,null,"int32"),i.jeX;const fn=jt(((e,t)=>e>t?1:0)),mn=(Zt(i.iZT,fn,null,"bool"),i.iZT,jt(((e,t)=>e>=t?1:0))),gn=(Zt(i.Acj,mn,null,"bool"),i.Acj,jt(((e,t)=>e<t?1:0))),xn=(Zt(i.vtC,gn,null,"bool"),i.vtC,jt(((e,t)=>e<=t?1:0))),bn=(Zt(i.CAk,xn,null,"bool"),i.CAk,nn((e=>Math.log(e))));function yn(e,t,n,r){const a=i.D5U.getTypedArrayFromDType(r,i.D5U.sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let i=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>i)&&(i=t)}a[n]=i}return a}rn(i.ZbH,bn),i.ZbH;const wn=jt(((e,t)=>Math.max(e,t))),vn=(Zt(i.BMI,wn),i.BMI,jt(((e,t)=>Math.min(e,t)))),kn=(Zt(i.q8u,vn),i.q8u,jt(((e,t)=>e*t))),Cn=Jt(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));function In(e,t,n){const r=i.D5U.createScalarValue(-1,n);return kn([],t,r,e,n)}Zt(i.wYn,kn,Cn),i.wYn,i.kuV;const Sn=jt(((e,t)=>e!==t?1:0));function $n(e,t,n,r,a){const s=t.length,o=i.D5U.sizeFromShape(t),u=i.D5U.computeStrides(t),l=i.D5U.computeStrides(a),c=i.D5U.getTypedArrayFromDType(n,i.D5U.sizeFromShape(a));for(let t=0;t<o;++t){const n=i.D5U.indexToLoc(t,s,u),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];c[i.D5U.locToIndex(a,s,l)]=e[t]}return c}function Rn(e,t,n,r){const[a,s]=i.backend_util.computeOutAndReduceShapes(e,r),o=(0,i.x8V)(t,"int32"),u=i.D5U.makeZerosTypedArray(i.D5U.sizeFromShape(a),o),l=i.D5U.sizeFromShape(s);for(let e=0;e<u.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];u[e]=r}return{outVals:u,outShape:a,outDtype:o}}function Tn(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return i.D5U.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((t-e)/n)),s=i.D5U.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}Zt(i.yQU,Sn,null,"bool"),i.yQU,i.G3Y,i.DlI;const An=nn((e=>1/Math.sqrt(e)));function En(e,t,n,r,a,s,o,u,l,c){const d=[r/a,a],h=e.values,p=t.values;if(0===r)return(0,i.f3b)(n,t.dtype);const f=l instanceof i.YDk?l:(0,i.f3b)(d,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<s;e++){const i=[];let s=0;for(let t=0;t<o;t++){const n=h[e*o+t];i.push(n),s+=n*u[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${i} does not index into ${n}`);for(let n=0;n<a;n++)c?f.values[s*a+n]+=p[e*a+n]:f.values[s*a+n]=0===t.rank?p[0]:p[e*a+n]}return f}function Nn(e,t,n,r,a){const s=i.kuN.isSliceContinous(r,t,n),o=i.D5U.sizeFromShape(n),u=i.D5U.computeStrides(r);if(s){const n=i.kuN.computeFlatOffset(t,u);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const l="string"===a?i.backend_util.fromUint8ToStringArray(e):e,c=(0,i.f3b)(r,a,l),d=(0,i.f3b)(n,a);for(let e=0;e<d.size;++e){const n=d.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));d.set(c.get(...r),...n)}return"string"===a?i.backend_util.fromStringArrayToUint8(d.values):d.values}function Dn(e,t,n,r){const a=(0,i.f3b)(e,t.dtype);for(let e=0;e<a.size;e++){const i=a.indexToLoc(e),s=new Array(i.length);for(let e=0;e<s.length;e++)s[e]=i[e]*n[e]+r[e];a.set(t.get(...s),...i)}return a}rn(i.bV0,An),i.bV0,i.p2w;class _n{constructor(e,t,n,r,a,s){this.separator=i.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=i.D5U.encodeString(n),this.rightPad=i.D5U.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,a){for(let s=0;s<i;++s){const o=this.getPadWidth(a),u=Math.max(0,o-s),l=Math.max(0,o-(i-(s+1))),c=a-(u+l),d=t+(u>0?0:s-o);let h=0;h+=u*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=l*this.rightPad.length,h+=(u+l+c-1)*this.separator.length,n[r+s]=new Uint8Array(h);const p=n[r+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let i=1;i<r;++i){let r=t[i]>=e;if(r=r&&t[i]<=n,!r)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=i.D5U.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}const o=new Array(s[a]);for(let n=0;n<a;++n){const r=t[n];let i=s[n];if(this.nGramWidths.forEach((a=>{const s=t[n+1]-t[n],u=this.getNumNGrams(s,a);this.createNGrams(e,r,o,i,u,a),i+=u})),this.preserveShort&&i===s[n]){const a=t[n+1]-t[n];if(0===a)continue;const s=a+2*this.padWidth,u=1;this.createNGrams(e,r,o,i,u,s)}}return[o,s]}}function Fn(e,t,n,r,i,a,s,o){return new _n(n,r,i,a,s,o).compute(e,t)}const Pn=jt(((e,t)=>e-t)),On=Jt(((e,t,n,r)=>({real:e-n,imag:t-r})));function Un(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=(0,i.f3b)(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const a=e.locToIndex(i);r.values[t]=e.values[a]}return r}Zt(i.Tr8,Pn,On),i.Tr8;const Bn=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Ln(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,a=t-n+1,s=Math.log(i),o=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*o*(i-o)/i)*Math.sign(a-i/2);Ln(e,t,Math.max(n,Math.floor(t-a*o/i+u)),Math.min(r,Math.floor(t+(i-a)*o/i+u)))}const a=e[t];let s=n,o=r;for(i.D5U.swap(e,n,t),Bn(e[r],a)>0&&i.D5U.swap(e,n,r);s<o;){for(i.D5U.swap(e,s,o),s++,o--;Bn(e[s],a)<0;)s+=1;for(;Bn(e[o],a)>0;)o-=1}0===Bn(e[n],a)?i.D5U.swap(e,n,o):(o+=1,i.D5U.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function zn(e,t,n,r,a){const s=t[t.length-1],[o,u]=[e.length/s,s],l=i.D5U.getTypedArrayFromDType(n,o*r),c=i.D5U.getTypedArrayFromDType("int32",o*r);for(let t=0;t<o;t++){const n=t*u,i=e.subarray(n,n+u);let s=new Array(i.length);i.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(Ln(s,r),s=s.slice(0,r)),a&&s.sort(Bn);const o=t*r,d=l.subarray(o,o+r),h=c.subarray(o,o+r);for(let e=0;e<r;e++)d[e]=s[e].value,h[e]=s[e].index}const d=t.slice();return d[d.length-1]=r,[(0,i.f3b)(d,n,l),(0,i.f3b)(d,"int32",c)]}function Mn(e,t,n,r){const a=i.D5U.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];const o=new Map,u=new Int32Array(n[a]),l=new i.YDk(s,r,e),c=[],d=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}const r=o.get(n);if(null!=r)u[t]=r;else{const e=o.size;o.set(n,e),u[t]=e,c.push(t)}}const h=s.slice();h[1]=o.size;const p=new i.YDk(h,r);c.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[a]=h[1],{outputValues:p.values,outputShape:f,indices:u}}const{addImpl:Wn,castImpl:Vn,ceilImpl:Gn,concatImpl:Hn,equalImpl:jn,expImpl:Xn,expm1Impl:Kn,floorImpl:qn,floorDivImpl:Yn,gatherNdImpl:Qn,gatherV2Impl:Zn,greaterEqualImpl:Jn,greaterImpl:er,lessEqualImpl:tr,lessImpl:nr,logImpl:rr,maxImpl:ir,maximumImpl:ar,minimumImpl:sr,multiplyImpl:or,negImpl:ur,notEqualImpl:lr,prodImpl:cr,rangeImpl:dr,rsqrtImpl:hr,scatterImpl:pr,simpleAbsImpl:fr,sliceImpl:mr,stridedSliceImpl:gr,stringNGramsImpl:xr,subImpl:br,tileImpl:yr,topKImpl:wr,transposeImpl:vr,uniqueImpl:kr}=r,Cr=Wt({opType:Ce.ABS,cpuKernelImpl:fr}),Ir={kernelName:i.SYM,backendName:"webgpu",kernelFunc:Cr},Sr=Wt({opType:Ce.ACOS}),$r={kernelName:i.VGw,backendName:"webgpu",kernelFunc:Sr},Rr=Wt({opType:Ce.ACOSH}),Tr={kernelName:i.SpW,backendName:"webgpu",kernelFunc:Rr},Ar=Vt({opType:U.ADD,cpuKernelImpl:Wn,supportsComplex:!0}),Er={kernelName:i.mm_,backendName:"webgpu",kernelFunc:Ar};class Nr{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${x("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const Dr={kernelName:i.Xze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return Ut({inputs:{x:r[0]},backend:n});const a=r.map((e=>e.dtype)).reduce(((e,t)=>(0,i.x8V)(e,t))),s=r.map((e=>e.shape)),o=new Nr(s);return n.runWebGPUProgram(o,r,a)}};class _r{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){i.D5U.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${x()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Fr{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=m(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC.${g(t)}`;return n.join()}(this.newDim);return`\n      ${x("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Pr(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,o=n,u=a.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=a.shape[s[e]];if(n.shouldExecuteOnCPU([a])){const e=o.tensorMap.get(a.dataId).values,t=vr(e,a.shape,a.dtype,s,l);return n.makeTensorInfo(l,a.dtype,t)}if(2===a.shape.length&&i.D5U.arraysEqual(s,[1,0])){const e=new _r(a.shape,s);return o.runWebGPUProgram(e,[a],a.dtype)}const c=new Fr(a.shape,s);return o.runWebGPUProgram(c,[a],a.dtype)}const Or={kernelName:i.G3Y,backendName:"webgpu",kernelFunc:Pr};class Ur{constructor(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=i.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,e.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       \n         var<workgroup> xBestValues : array<f32, ${n}>;\n       \n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${x("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}function Br(e,t,n,r,a){const s=e.shape.length,o=[],u=i.D5U.parseAxisParam(t,e.shape);let l=u;const c=i.backend_util.getAxesPermutation(l,s);let d=e;null!=c&&(d=Pr({inputs:{x:e},attrs:{perm:c},backend:a}),l=i.backend_util.getInnerMostAxes(l.length,s),o.push(d)),i.backend_util.assertAxesAreInnerMostDims(r,l,s);const[h,p]=i.backend_util.computeOutAndReduceShapes(d.shape,l);let f,m=h;if(n&&(m=i.backend_util.expandShapeToKeepDim(h,u)),"max"!==r&&"prod"!==r||!a.shouldExecuteOnCPU([d])){const t=i.D5U.sizeFromShape(p),n={windowSize:t,inSize:t,batchSize:i.D5U.sizeFromShape(d.shape)/t,outSize:1},s="mean"===r?"float32":(0,i.z4k)(e.dtype),u=[{type:"int32",data:[t]}],l=new Ur(n,r,a.device.limits.maxComputeWorkgroupSizeX),c=a.runWebGPUProgram(l,[d],s,u);o.push(c),f=Nt({inputs:{x:c},attrs:{shape:m},backend:a})}else{const t=a.tensorMap.get(d.dataId).values;switch(r){case"max":const n=ir(t,i.D5U.sizeFromShape(p),m,e.dtype);f=a.makeTensorInfo(m,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:u}=cr(d.shape,d.dtype,t,l);f=a.makeTensorInfo(o,u,s);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}return o.forEach((e=>a.disposeData(e.dataId))),f}const Lr={kernelName:i.oT6,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return Br(i,s,a,"all",n)}},zr={kernelName:i.IKK,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return Br(i,s,a,"any",n)}};class Mr{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op="min"===n?"<":">";const[a,s]=i.backend_util.computeOutAndReduceShapes(e,r);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=E(this.outputShape),i.D5U.sizeFromShape(s)<32||i.D5U.sizeFromShape(a)>1e3?(this.type="plain",this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=R(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${g(this.inputShape.length-1)}`,n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${g(t)},`;return e};return"shared"===this.type?`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      \n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    \n\n      ${x("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `:`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const Wr={kernelName:i.sJF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=i.D5U.parseAxisParam(s,a.shape);const u=i.backend_util.getAxesPermutation(o,a.shape.length);let l=a;const c=[];null!=u&&(l=Pr({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(l),o=i.backend_util.getInnerMostAxes(o.length,l.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const d=new Mr(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",h);return c.forEach((e=>n.disposeData(e.dataId))),p}},Vr={kernelName:i.aJk,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=i.D5U.parseAxisParam(s,a.shape);const u=i.backend_util.getAxesPermutation(o,a.shape.length);let l=a;const c=[];null!=u&&(l=Pr({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(l),o=i.backend_util.getInnerMostAxes(o.length,l.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const d=new Mr(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",h);return c.forEach((e=>n.disposeData(e.dataId))),p}},Gr=Wt({opType:Ce.ASIN}),Hr={kernelName:i.M2y,backendName:"webgpu",kernelFunc:Gr},jr=Wt({opType:Ce.ASINH}),Xr={kernelName:i.qw7,backendName:"webgpu",kernelFunc:jr},Kr=Wt({opType:Ce.ATAN}),qr={kernelName:i.jMg,backendName:"webgpu",kernelFunc:Kr},Yr=Vt({opType:U.ATAN2}),Qr={kernelName:i.QCc,backendName:"webgpu",kernelFunc:Yr},Zr=Wt({opType:Ce.ATANH}),Jr={kernelName:i.Oyi,backendName:"webgpu",kernelFunc:Zr};class ei{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class ti{constructor(e,t,n=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${n}_${r}_${i}`}getUserCode(){let e;e="avg"===this.poolType?"resultValue = resultValue + value; count = count + 1.0;":this.computePositions?`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`:"resultValue = max(value, resultValue);";let t="resultValue";return"avg"===this.poolType&&(t="resultValue / max(count, 1.0)"),`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${e}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}class ni{constructor(e,t,n=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${n}_${r}_${i}`}getUserCode(){let e;e="avg"===this.poolType?"resultValue += value; count += 1.0;":this.computePositions?`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`:"resultValue = max(value, resultValue);";let t="resultValue";return"avg"===this.poolType&&(t="resultValue / max(count, 1.0)"),`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${e}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}function ri(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:a,keepDims:s}=r;return Br(i,a,s,"max",n)}const ii={kernelName:i.YoZ,backendName:"webgpu",kernelFunc:ri};function ai(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:a,axis:s}=r;return Br(i,s,a,"mean",n)}const si={kernelName:i.q2K,backendName:"webgpu",kernelFunc:ai};function oi(e,t,n,r){if(1===t.filterWidth&&1===t.filterHeight&&i.D5U.arraysEqual(t.inShape,t.outShape))return Ut({inputs:{x:e},backend:r});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const a=e.shape.length,s=Nt({inputs:{x:e},backend:r,attrs:{shape:[e.shape[a-3]*e.shape[a-2],e.shape[a-1]]}});let o;"avg"===n?o=ai({inputs:{x:s},backend:r,attrs:{axis:0,keepDims:!1}}):(i.D5U.assert("max"===n,(()=>`Invalid pool type ${n}`)),o=ri({inputs:{x:s},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const u=Nt({inputs:{x:o},backend:r,attrs:{shape:t.outShape}});return r.disposeData(s.dataId),r.disposeData(o.dataId),u}let a;const s=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?a=new ei(t):("avg"===n?a=new ti(t,"avg"):(i.D5U.assert("max"===n,(()=>`Invalid pool type ${n}`)),a=new ti(t,"max")),s.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),r.runWebGPUProgram(a,[e],e.dtype,s)}const ui={kernelName:i.JhU,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:l}=r;return oi(a,i.backend_util.computePool2DInfo(a.shape,s,o,1,u,l),"avg",n)}},li={kernelName:i._k9,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=i.backend_util.computePool3DInfo(a.shape,s,o,[1,1,1],u,c,l),h=new ni(d,"avg"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[a],a.dtype,p)}};class ci{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class di{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const hi={kernelName:i.IMb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,h=i.backend_util.computePool3DInfo(o.shape,u,l,1,c,d),p=new di(h),f=1/(h.filterDepth*h.filterHeight*h.filterWidth),m=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return n.runWebGPUProgram(p,[a],o.dtype,m)}},pi={kernelName:i.ROF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;_([a,s],"avgPoolGrad");const{filterSize:u,strides:l,pad:c}=r,d=i.backend_util.computePool2DInfo(o.shape,u,l,1,c),h=new ci(d),p=1/(d.filterHeight*d.filterWidth),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(h,[a],o.dtype,f)}},fi={kernelName:i.XLW,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:a}=t,{transposeA:s,transposeB:o}=r;return _t({a:i,b:a,transposeA:s,transposeB:o,backend:n})}};class mi{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${m(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=m(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return gi.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;return n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${gi[t]} = uniforms.start.${g(t)} + coords.${gi[t]};`)),`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const gi=["x","y","z","w","u","v"];function xi(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[u,l]=i.kuN.parseSliceParams(a,s,o);if(i.kuN.assertParamsValid(a,u,l),n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.tensorMap.get(a.dataId),t=mr(e.values,u,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}if(0===i.D5U.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);const c=new mi(u,l),d=[{type:"int32",data:u}];return n.runWebGPUProgram(c,[a],a.dtype,d)}const bi={kernelName:i.p2w,backendName:"webgpu",kernelFunc:xi},yi={kernelName:i.zws,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;i.D5U.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const u=s.reduce(((e,t)=>e*t)),l=i.backend_util.getReshaped(a.shape,s,u),c=i.backend_util.getPermuted(l.length,s.length),d=i.backend_util.getReshapedPermuted(a.shape,s,u),h=i.backend_util.getSliceBeginCoords(o,s.length),p=i.backend_util.getSliceSize(d,o,s.length),f=[],m=Nt({inputs:{x:a},backend:n,attrs:{shape:l}}),g=Pr({inputs:{x:m},backend:n,attrs:{perm:c}}),x=Nt({inputs:{x:g},backend:n,attrs:{shape:d}}),b=xi({inputs:{x},backend:n,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(x),f.forEach((e=>n.disposeData(e.dataId))),b}},wi=`\n  fn bincount_write(index: i32, value: f32) {\n    ${p("&result[index]","value","float32")}\n  }\n`;class vi{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":wi}\n  ${x("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const ki={kernelName:i.zvY,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o}=r,u=i.D5U.sizeFromShape(a.shape),l=i.D5U.sizeFromShape(s.shape)>0,c=[o],d=s.dtype,h=At({backend:n,attrs:{shape:c,value:0,dtype:d}}),p=new vi([u],l),f=[{type:"int32",data:[o]}],m=l?[a,s]:[a];return n.runWebGPUProgram(p,m,d,f,h)}};class Ci{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${x("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}const Ii={kernelName:i.eEB,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t;if(n.shouldExecuteOnCPU([r,a])){const e=n.tensorMap.get(r.dataId),t=n.tensorMap.get(a.dataId),s=e.values,o=t.values,u=i.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const s=i.D5U.sizeFromShape(r.shape),o=i.D5U.sizeFromShape(a.shape),u=Math.max(s,o),l=new Ci(u),c=[{type:"int32",data:[s]},{type:"int32",data:[o]}];return n.runWebGPUProgram(l,[r,a],"int32",c)}},Si=Vt({opType:U.NOT_EQUAL,dtype:"bool",cpuKernelImpl:lr}),$i={kernelName:i.yQU,backendName:"webgpu",kernelFunc:Si};function Ri(e){const{inputs:t,backend:n}=e,{input:r}=t;return Ut({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const Ti={kernelName:i.xJR,backendName:"webgpu",kernelFunc:Ri},Ai={kernelName:i.RFZ,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return Ut({inputs:{x:s},backend:r});const t=i.lls(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=Lt({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeData(n.dataId),a}if("complex64"===s.dtype){const t=Ri({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeData(t.dataId),n}if(!i.D5U.hasEncodingLoss(s.dtype,o)){const e=Ut({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const e=r.tensorMap.get(s.dataId).values,[t,n,i]=Vn(e,s.shape,s.dtype,o);return r.makeTensorInfo(t,n,i)}if("int32"===o)return function(e,t){const n=new Mt(e.shape,Ce.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",i.D5U.getTypedArrayFromDType("bool",1)),t=Si({inputs:{a:s,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},Ei=Wt({opType:Ce.CEIL,cpuKernelImpl:Gn}),Ni={kernelName:i.gJX,backendName:"webgpu",kernelFunc:Ei};class Di{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${x("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class _i{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${x("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const Fi={kernelName:i.xnO,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let u;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return u=i.D5U.sizeFromShape(a.shape)%4==0?new Di(a.shape):new _i(a.shape),n.runWebGPUProgram(u,[a],a.dtype,l)}};class Pi{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}function Oi(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Ui={kernelName:i.yj2,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=n.tensorMap.get(r.dataId),a=new Pi(r.shape),s=[Oi(r,i.complexTensorInfos.real),Oi(r,i.complexTensorInfos.imag)];return n.runWebGPUProgram(a,s,s[0].dtype)}};class Bi{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=i.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${x("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function Li(e){const{inputs:t,backend:n}=e,{input:r}=t;return Ut({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const zi={kernelName:i.J_u,backendName:"webgpu",kernelFunc:Li};function Mi(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>Ri({inputs:{input:e},backend:n}))),i=e.map((e=>Li({inputs:{input:e},backend:n}))),a=Mi(r,t,n),s=Mi(i,t,n),o=Lt({inputs:{real:a,imag:s},backend:n});return r.forEach((e=>n.disposeData(e.dataId))),i.forEach((e=>n.disposeData(e.dataId))),n.disposeData(a.dataId),n.disposeData(s.dataId),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=i.D5U.sizeFromShape(e.shape.slice(t));return Nt({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=i.backend_util.computeOutShape(a.map((e=>e.shape)),1),u=1===a[0].shape[0],l=Hn(s,o,r,u),c=i.backend_util.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(c,r,l);return a.forEach((e=>n.disposeData(e.dataId))),d}const s=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>s){const r=[];for(let i=0;i<e.length;i+=s){const a=e.slice(i,i+s);r.push(Mi(a,t,n))}const i=Mi(r,t,n);for(const e of r)n.disposeData(e.dataId);return i}const{tensors2D:o,outShape:u}=function(e,t,n){const r=i.backend_util.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Nt({inputs:{x:e},backend:n,attrs:{shape:[i.D5U.sizeFromShape(e.shape.slice(0,t)),i.D5U.sizeFromShape(e.shape.slice(t))]}}))),outShape:r}}(e,t,n),l=o.map((e=>e.shape)),c=new Bi(l),d=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],d.push({type:"int32",data:[h[0]]});for(let e=1;e<h.length;e++)h[e]=h[e-1]+l[e][1],d.push({type:"int32",data:[h[e]]})}const p=n.runWebGPUProgram(c,o,o[0].dtype,d);o.forEach((e=>n.disposeData(e.dataId)));const f=Nt({inputs:{x:p},backend:n,attrs:{shape:u}});return n.disposeData(p.dataId),f}function Wi(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=i.D5U.parseAxisParam(a,t[0].shape)[0],o=t.map((e=>e.shape));i.backend_util.assertParamsConsistent(o,s);const u=i.backend_util.computeOutShape(t.map((e=>e.shape)),s);if(0===i.D5U.sizeFromShape(u))return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter((e=>i.D5U.sizeFromShape(e.shape)>0));return 1===l.length?Ut({inputs:{x:l[0]},backend:n}):Mi(l,s,n)}const Vi={kernelName:i.Eh3,backendName:"webgpu",kernelFunc:Wi};class Gi{constructor(e,t,n,r,i=!1,a=null,s=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=T(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=A(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),s&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=s,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?wt(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):kt(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,i=!1,a=null,s=!1,o=4,u=4,l=4){const c=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",d=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",h=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",m=e?"row":"col",g=e?"col":"row",x=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${m} / outWidth;\n      let outCol = ${m} % outWidth;\n\n      let WRow = ${g} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${g} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${g} % inChannels;\n      var resData = ${f(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${h} && xCol >= 0 && xCol < ${p}) {\n        ${c}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,b=e?t&&r?`\n      let col = colIn * ${o};\n      ${x}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${x}\n      }\n      return ${f(o)}(0.0);`:r&&n?`\n      let col = colIn * ${o};\n      ${x}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${x}\n      }\n      return ${f(o)}(0.0);`,y=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=f(l),v=f(e?o:u),k=f(e?u:o);return`\n      ${gt(a,s,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {\n        ${e?b:y}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${k} {\n        ${e?y:b}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${d}\n        ${xt(i,a)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class Hi{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${gt(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${xt(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${x("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class ji{constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${x("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${i};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function Xi(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Ki({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:u=null}){const l=null!=a,c=null!=s,d="channelsLast"===n.dataFormat,h=d&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type,p=(0,i.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(h||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:s=0,activation:o=null}){const u="channelsLast"===n.dataFormat,l=!u,c=[];let d,h;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const i=n.inHeight*n.inWidth*n.inChannels;d=Nt({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,i]}}),h=Nt({inputs:{x:t},backend:r,attrs:{shape:[1,i,n.outChannels]}})}else d=Nt({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),h=Nt({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(c.push(d),c.push(h),null!=a){const e=Xi(a.shape,u);null!=e&&(a=Nt({inputs:{x:a},backend:r,attrs:{shape:e}}),c.push(a))}if(null!=i){const e=Xi(i.shape,u);null!=e&&(i=Nt({inputs:{x:i},backend:r,attrs:{shape:e}}),c.push(i))}const p=_t({a:u?d:h,b:u?h:d,transposeA:l,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:s}),f=Nt({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});c.push(p);for(const e of c)r.disposeData(e.dataId);return f}({x:e,filter:t,convInfo:n,backend:r,bias:a,activation:u,preluActivationWeights:s,leakyreluAlpha:o});const f=(0,i.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>0?f:r.thresholdToIncreaseWorkgroups,g=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if((0,i.OBj)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:s=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:d,strideHeight:h,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:x,dataFormat:b}=n,y="channelsLast"===b,w=u*l*c,v=m*f,k=y?[n.batchSize,v,w]:[n.batchSize,w,v],C=new ji(k,y),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[h,d]},{type:"int32",data:[x,g]},{type:"int32",data:[f]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],S=r.runWebGPUProgram(C,[e],e.dtype,I),$=[];$.push(S);const R=Nt({inputs:{x:t},backend:r,attrs:{shape:[1,w,-1]}});if($.push(R),null!=a){const e=Xi(a.shape,y);null!=e&&(a=Nt({inputs:{x:a},backend:r,attrs:{shape:e}}),$.push(a))}if(null!=i){const e=Xi(i.shape,y);null!=e&&(i=Nt({inputs:{x:i},backend:r,attrs:{shape:e}}),$.push(i))}const T=_t({a:y?S:R,b:y?R:S,transposeA:!y,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:s}),A=Nt({inputs:{x:T},backend:r,attrs:{shape:n.outShape}});$.push(T);for(const e of $)r.disposeData(e.dataId);return A}({x:e,filter:t,convInfo:n,backend:r,bias:a,preluActivationWeights:s,leakyreluAlpha:o,activation:u});let x;const b=[n.padInfo.top,n.padInfo.left],y=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(p)x=new Hi(n,l,u,c);else{const e=d?n.outHeight*n.outWidth:n.outChannels,t=d?n.outChannels:n.outHeight*n.outWidth,i=n.filterHeight*n.filterWidth*n.inChannels;y.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[i]});const a=r.adapterInfo.isIntel();x=new Gi(n,e,t,i,l,u,c,a)}const w=[],v=[e,t];l&&(d||1!==a.shape.length||(a=Nt({inputs:{x:a},backend:r,attrs:{shape:[a.shape[0],1,1]}}),w.push(a)),v.push(a)),c&&(d||1!==s.shape.length||(s=Nt({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),w.push(s)),v.push(s)),"leakyrelu"===u&&(y.push({type:"float32",data:[o]}),x.uniforms+=" alpha : f32,");const k=r.runWebGPUProgram(x,v,e.dtype,y);for(const e of w)r.disposeData(e.dataId);return k}const qi={kernelName:i.mhS,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=n,h=i.backend_util.convertConv2DDataFormat(l);return Ki({x:a,filter:s,convInfo:i.backend_util.computeConv2DInfo(a.shape,s.shape,o,c,u,d,!1,h),backend:r})}};class Yi{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,r=`\n    ${x()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${r}\n    `:`\n    ${x("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Qi{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${x("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Zi{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${x("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Ji{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${x("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const ea={kernelName:i.wUP,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,h=i.backend_util.convertConv2DDataFormat(l),p=i.backend_util.computeConv2DInfo(a.shape,d,o,1,u,c,!1,h),f=new Qi(p),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return n.runWebGPUProgram(f,[a,s],a.dtype,m)}};class ta{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,i.D5U.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=T(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=A(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?wt(this.elementsPerThread,this.workgroupSize):kt(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${f(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${f(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${f(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${f(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${f(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${f(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${f(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const na={kernelName:i.wm,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:d}=r,h=i.backend_util.convertConv2DDataFormat(c),p=i.backend_util.computeConv2DInfo(o,s.shape,u,1,l,d,!1,h),f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if((0,i.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==p.dataFormat)m=new Yi(p);else{m=new ta(p);const e=p.inHeight*p.inWidth,t=p.inChannels,n=p.filterHeight*p.filterWidth*p.outChannels;f.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(m,[a,s],"float32",f)}};class ra{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}const ia={kernelName:i.x12,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dilations:l}=r,c=i.backend_util.computeConv3DInfo(a.shape,s.shape,o,l,u),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],p=new ra(c),f=(0,i.x8V)(a.dtype,s.dtype);return n.runWebGPUProgram(p,[a,s],f,h)}},aa={kernelName:i.o2y,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:u,filterShape:l}=r,c=i.backend_util.computeConv3DInfo(a.shape,l,o,1,u),d=new Zi(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(d,[a,s],s.dtype,h)}},sa={kernelName:i.ik2,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,pad:u,inputShape:l}=r,c=i.backend_util.computeConv3DInfo(l,s.shape,o,1,u),d=new Ji(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(d,[a,s],a.dtype,h)}},oa=Wt({opType:Ce.COS}),ua={kernelName:i.mc4,backendName:"webgpu",kernelFunc:oa},la=Wt({opType:Ce.COSH}),ca={kernelName:i.TR1,backendName:"webgpu",kernelFunc:la};class da{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,s,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${a});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${s};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const ha={kernelName:i.VcC,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:a,boxInd:s}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new da(i.shape[3],a.shape,o,u),d=[{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[i,a,s],"float32",d)}};var pa;!function(e){e.Prod="*",e.Sum="+"}(pa||(pa={}));class fa{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===pa.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${ma(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`\n      ${x("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${ga(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${a};\n           ${ga(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${ma(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function ma(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function ga(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function xa(e,t,n,r,a,s){const o=t.shape.length,u=i.backend_util.getAxesPermutation([r],o);let l=t;null!=u&&(l=Pr({inputs:{x:t},backend:n,attrs:{perm:u}}));const c=i.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const d=l.shape[c];let h=Ut({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const r=new fa(e,l.shape,!1,s),i=h,a=[{type:"float32",data:[t]}];h=n.runWebGPUProgram(r,[h],h.dtype,a),n.disposeData(i.dataId)}if(a){const t=new fa(e,l.shape,a,s),r=h,i=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(t,[h],h.dtype,i),n.disposeData(r.dataId)}if(null!=u){const e=Pr({inputs:{x:h},backend:n,attrs:{perm:i.backend_util.getUndoAxesPermutation(u)}});return n.disposeData(h.dataId),n.disposeData(l.dataId),e}return h}const ba={kernelName:i.Byc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return xa(pa.Prod,i,n,a,s,o)}},ya={kernelName:i.iHb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:s,reverse:o}=r;return xa(pa.Sum,i,n,a,s,o)}},wa={kernelName:i.QRR,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o,binaryOutput:u}=r,l=1===a.shape.length,c=i.D5U.sizeFromShape(s.shape)>0,d=s.dtype,h=l?[a.shape[0]]:[a.shape[0],a.shape[1]],p=At({backend:n,attrs:{shape:l?[o]:[a.shape[0],o],value:0,dtype:d}}),f=new vi(h,c,u),m=[{type:"int32",data:[o]}],g=c?[a,s]:[a];return n.runWebGPUProgram(f,g,d,m,p)}};class va{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ka={kernelName:i.T0n,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:a,dataFormat:s}=r,o=i.shape[0],u=("NHWC"===s?i.shape[1]:i.shape[2])*a,l=("NHWC"===s?i.shape[2]:i.shape[3])*a,c=("NHWC"===s?i.shape[3]:i.shape[1])/(a*a),d=[{type:"int32",data:[a]}],h=new va("NHWC"===s?[o,u,l,c]:[o,c,u,l],s);return n.runWebGPUProgram(h,[i],i.dtype,d)}};class Ca{constructor(e,t,n,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${gt(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${x()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${xt(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class Ia{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),i.D5U.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${gt(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${x()} {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${xt(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class Sa{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${gt(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${xt(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const $a={kernelName:i.cie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=r,h=i.backend_util.convertConv2DDataFormat(l);let p=c;null==p&&(p=[1,1]);const f=i.backend_util.computeConv2DInfo(a.shape,s.shape,o,p,u,d,!0,h),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let x;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?x=new Ca(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?x=new Ia(f):(x=new Sa(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),n.runWebGPUProgram(x,[a,s],a.dtype,m)}};class Ra{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Ta{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Aa={kernelName:i.sL$,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,filterShape:d}=r,h=i.backend_util.computeConv2DInfo(a.shape,d,o,u,l,c,!0),p=new Ra(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(p,[a,s],"float32",f)}},Ea={kernelName:i.y7R,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,inputShape:d}=r,h=i.backend_util.computeConv2DInfo(d,s.shape,o,u,l,c,!0),p=new Ta(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(p,[a,s],a.dtype,f)}};class Na{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const Da={kernelName:i.$w,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=i.D5U.sizeFromShape(r.shape),o=Nt({inputs:{x:r},backend:n,attrs:{shape:[s]}}),u=new Na(s),l=n.runWebGPUProgram(u,[o],o.dtype),c=Nt({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeData(o.dataId),n.disposeData(l.dataId),c}};class _a{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${x("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const Fa={kernelName:i.p4S,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:u,dilations:l}=r,c=i.backend_util.computeDilation2DInfo(a.shape,s.shape,o,u,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new _a(c);return n.runWebGPUProgram(p,[a,s],a.dtype,h)}};class Pa{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=E(e.outShape),this.dispatch=R(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${x("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${p("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class Oa{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=E(e.outShape),this.dispatch=R(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${x("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${p("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}const Ua={kernelName:i.Vn9,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:o}=t,{strides:u,pad:l,dilations:c}=r,d=i.backend_util.computeDilation2DInfo(a.shape,s.shape,u,l,"NHWC",c),h=s.dtype,p=new Oa(d,s.shape,h),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[i.D5U.sizeFromShape(d.outShape)]}],m=At({backend:n,attrs:{shape:s.shape,value:0,dtype:h}});return n.runWebGPUProgram(p,[a,s,o],h,f,m)}},Ba={kernelName:i.ekb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:o}=t,{strides:u,pad:l,dilations:c}=r,d=i.backend_util.computeDilation2DInfo(a.shape,s.shape,u,l,"NHWC",c),h=a.dtype,p=new Pa(d,h),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[i.D5U.sizeFromShape(d.outShape)]}],m=At({backend:n,attrs:{shape:d.inShape,value:0,dtype:h}});return n.runWebGPUProgram(p,[a,s,o],h,f,m)}},La=Vt({opType:U.MUL,cpuKernelImpl:or,supportsComplex:!0}),za={kernelName:i.wYn,backendName:"webgpu",kernelFunc:La};function Ma(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return Br(i,a,s,"sum",n)}const Wa={kernelName:i.GBy,backendName:"webgpu",kernelFunc:Ma},Va={kernelName:i.$g6,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:u,idDims:l}=i.backend_util.decodeEinsumEquation(a,s.length);i.backend_util.checkEinsumDimSizes(o.length,l,s);const{path:c,steps:d}=i.backend_util.getEinsumComputePath(u,l),h=d.length;let p=null,f=o.length;const m=[];for(let e=0;e<h;++e){for(const t of d[e]){const{permutationIndices:e,expandDims:r}=i.backend_util.getEinsumPermutation(f,l[t]);let a;i.backend_util.isIdentityPermutation(e)?a=s[t]:(a=Pr({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),m.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);i.D5U.arraysEqual(a.shape,o)||(a=Nt({inputs:{x:a},backend:n,attrs:{shape:o}}),m.push(a)),null===p?p=a:(p=La({inputs:{a,b:p},backend:n}),m.push(p))}e<h-1&&(c[e]>=0&&(p=Ma({inputs:{x:p},backend:n,attrs:{axis:c[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeData(e.dataId);return p}},Ga=Wt({opType:Ce.ELU}),Ha={kernelName:i.SX0,backendName:"webgpu",kernelFunc:Ga},ja={kernelName:i.HEU,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:i}=t,a=new Ot(U.ELU_DER,r.shape,i.shape);return n.runWebGPUProgram(a,[r,i],r.dtype)}},Xa=Vt({opType:U.EQUAL,dtype:"bool",cpuKernelImpl:jn}),Ka={kernelName:i.hdR,backendName:"webgpu",kernelFunc:Xa},qa=Wt({opType:Ce.ERF}),Ya={kernelName:i.Omj,backendName:"webgpu",kernelFunc:qa},Qa=Wt({opType:Ce.EXP,cpuKernelImpl:Xn,dtype:"float32"}),Za={kernelName:i.NEP,backendName:"webgpu",kernelFunc:Qa};function Ja(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,u=s.shape.slice();let l=a;return a<0&&(i.D5U.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),u.splice(l,0,1),Nt({inputs:{x:s},backend:r,attrs:{shape:u}})}const es={kernelName:i.YFo,backendName:"webgpu",kernelFunc:Ja},ts=Wt({opType:Ce.EXPM1,cpuKernelImpl:Kn}),ns={kernelName:i.Y0y,backendName:"webgpu",kernelFunc:ts};class rs{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function is(e,t,n){const r=n.tensorMap.get(e.dataId),a=i.D5U.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],o=[],u=Nt({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}});o.push(u);const l=u.shape,c=new rs("real",l),d=new rs("imag",l),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?l[1]:1]}],f=n.runWebGPUProgram(c,h,"float32",p);o.push(f);const m=n.runWebGPUProgram(d,h,"float32",p);o.push(m);const g=Lt({inputs:{real:f,imag:m},backend:n});o.push(g);const x=Nt({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach((e=>n.disposeData(e.dataId))),x}const as={kernelName:i.vwp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return is(r,!1,n)}};class ss{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const os={kernelName:i.Uyb,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new ss(n.shape);return r.runWebGPUProgram(i,[n],n.dtype)}},us=Wt({opType:Ce.FLOOR,cpuKernelImpl:qn}),ls={kernelName:i.OR,backendName:"webgpu",kernelFunc:us},cs=Vt({opType:U.INT_DIV,cpuKernelImpl:Yn,dtype:"int32"}),ds={kernelName:i.jeX,backendName:"webgpu",kernelFunc:cs};class hs{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${x("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const ps={kernelName:i.eBW,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,c="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,[d,h]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[h,d,s],f=o||u;if(c||l||f){let e;{if(f){const e=(0,i.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=fs&&e===ms||(ms=e,fs=document.createElement("canvas").getContext("2d",{willReadFrequently:ms})),fs.canvas.width=d,fs.canvas.height=h,fs.drawImage(a,0,0,d,h),a=fs.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",s=n.textureManager.acquireTexture(p[1],p[0],r,t);n.queue.copyExternalImageToTexture({source:a},{texture:s},[p[1],p[0]]),e={width:d,height:h,format:r,usage:t,texture:s}}const t=i.D5U.sizeFromShape(p),r=i.D5U.computeStrides(p),o=new hs(p,s,!1),u=[{type:"uint32",data:[t]},{type:"uint32",data:[s]},{type:"uint32",data:[...r]}],l=n.makeTensorInfo([h,d],"int32");n.tensorMap.get(l.dataId).resourceInfo=e;const c=n.runWebGPUProgram(o,[l],"int32",u);return n.disposeData(l.dataId),c}const m=a.data;let g=m;if(null!=s&&4!==s){g=new Uint8Array(a.width*a.height*s);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<s&&(g[t++]=m[n])}const x=n.makeTensorInfo(p,"int32",new Int32Array(g));return n.uploadToGPU(x.dataId),x}};let fs,ms=(0,i.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class gs{constructor(e,t,n,r,a){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(e,t),i.backend_util.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(i.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=a&&(i.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=a,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),`\n      ${x("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const xs={kernelName:i.sHE,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:i,offset:a,mean:s,variance:o}=e,{varianceEpsilon:u}=t,l=n,c=[r,s,o];let d=null;null!=a&&(d=a.shape,c.push(a));let h=null;null!=i&&(h=i.shape,c.push(i));const p=new gs(r.shape,s.shape,o.shape,d,h),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,c,r.dtype,f)}},bs={kernelName:i._V0,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=i.backend_util.convertConv2DDataFormat(d);return Ki({x:a,filter:s,convInfo:i.backend_util.computeConv2DInfo(a.shape,s.shape,l,h,c,p,!1,g),backend:n,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}},ys={kernelName:i.luS,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=d;null==m&&(m=[1,1]),i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=i.backend_util.computeConv2DInfo(a.shape,s.shape,l,m,c,h,!0),x=[a,s],b=null!=o,y=null!=u;b&&x.push(o),y&&x.push(u);const w=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let v;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?v=new Ia(g,b,p,y):(v=new Sa(g,b,p,y),w.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(w.push({type:"float32",data:[f]}),v.uniforms+=" alpha : f32,"),n.runWebGPUProgram(v,x,"float32",w)}};class ws{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${m(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const vs={kernelName:i.q1x,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],u=i.D5U.sizeFromShape(r.shape),[l,c,d,h]=i.backend_util.prepareAndValidate(r,a),p=Nt({inputs:{x:a},backend:n,attrs:{shape:[c,o]}}),f=Nt({inputs:{x:r},backend:n,attrs:{shape:[i.D5U.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),i=Qn(e,t,r.dtype,c,o,d,h,r.shape,u);return n.makeTensorInfo(l,r.dtype,i.values)}const m=new ws(o,[c,d]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],x=n.runWebGPUProgram(m,[f,p],f.dtype,g),b=Nt({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),b}};class ks{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Cs(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:u}=r,l=i.D5U.parseAxisParam(o,a.shape)[0],c=i.backend_util.segment_util.collectGatherOpShapeInfo(a,s,l,u),d=i.D5U.sizeFromShape(s.shape),h=[],p=Nt({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=Nt({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});h.push(p),h.push(f);const m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])){const e=n.tensorMap.get(f.dataId).values,t=(0,i.f3b)(f.shape,f.dtype,e),r=n.tensorMap.get(p.dataId).values,a=(0,i.f3b)(p.shape,p.dtype,r),s=Zn(a,t,m);return h.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(c.outputShape,s.dtype,s.values)}const g=new ks(p.shape,m),x=n.runWebGPUProgram(g,[p,f],p.dtype);h.push(x);const b=Nt({inputs:{x},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeData(e.dataId))),b}const Is={kernelName:i.qi_,backendName:"webgpu",kernelFunc:Cs},Ss=Vt({opType:U.GREATER,cpuKernelImpl:er,dtype:"bool"}),$s={kernelName:i.iZT,backendName:"webgpu",kernelFunc:Ss},Rs=Vt({opType:U.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Jn}),Ts={kernelName:i.Acj,backendName:"webgpu",kernelFunc:Rs},As={kernelName:i.Qg5,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return is(r,!0,n)}},Es=Wt({opType:Ce.IS_FINITE,dtype:"bool"}),Ns={kernelName:i.avt,backendName:"webgpu",kernelFunc:Es},Ds=Wt({opType:Ce.IS_INF,dtype:"bool"}),_s={kernelName:i.iWB,backendName:"webgpu",kernelFunc:Ds},Fs=Wt({opType:Ce.IS_NAN,dtype:"bool"}),Ps={kernelName:i.r7n,backendName:"webgpu",kernelFunc:Fs},Os={kernelName:i.J$2,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:a}=r,s=[{type:"float32",data:[a]}],o=new Mt(i.shape,Ce.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[i],"float32",s)}},Us=Vt({opType:U.LESS,dtype:"bool",cpuKernelImpl:nr}),Bs={kernelName:i.vtC,backendName:"webgpu",kernelFunc:Us},Ls=Vt({opType:U.LESS_EQUAL,dtype:"bool",cpuKernelImpl:tr}),zs={kernelName:i.CAk,backendName:"webgpu",kernelFunc:Ls};class Ms{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Ws={kernelName:i.e7N,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:a}=n,s=(i-r)/(a-1),o=new Ms(a),u=[{type:"float32",data:[r]},{type:"float32",data:[s]}];return t.runWebGPUProgram(o,[],"float32",u)}},Vs=Wt({opType:Ce.LOG,cpuKernelImpl:rr}),Gs={kernelName:i.ZbH,backendName:"webgpu",kernelFunc:Vs},Hs=Wt({opType:Ce.LOG1P}),js={kernelName:i.kU,backendName:"webgpu",kernelFunc:Hs},Xs=Vt({opType:U.LOGICAL_AND,dtype:"bool"}),Ks={kernelName:i.PYm,backendName:"webgpu",kernelFunc:Xs},qs=Wt({opType:Ce.LOGICAL_NOT}),Ys={kernelName:i.VfG,backendName:"webgpu",kernelFunc:qs},Qs=Vt({opType:U.LOGICAL_OR}),Zs={kernelName:i.MZg,backendName:"webgpu",kernelFunc:Qs},Js="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class eo{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${Js}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class to{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,i.D5U.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=R(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${x()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${Js}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const no={kernelName:i.eZ0,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:a,bias:s,alpha:o,beta:u}=r;let l;l=a>16?new eo(i.shape):new to(i.shape,a);const c=[{type:"int32",data:[a]},{type:"float32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[i],i.dtype,c)}};class ro{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}const io={kernelName:i.Hhh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,y:a,dy:s}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,d=new ro(i.shape),h=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[i,a,s],i.dtype,h)}},ao=Vt({opType:U.MAX,cpuKernelImpl:ar}),so={kernelName:i.BMI,backendName:"webgpu",kernelFunc:ao},oo={kernelName:i.mTV,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:l}=r;return oi(a,i.backend_util.computePool2DInfo(a.shape,s,o,1,u,l),"max",n)}},uo={kernelName:i.OAf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=i.backend_util.computePool3DInfo(a.shape,s,o,[1,1,1],u,c,l),h=new ni(d,"max"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[a],a.dtype,p)}};class lo{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class co{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const ho={kernelName:i.OU7,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,h=i.backend_util.computePool3DInfo(o.shape,u,l,[1,1,1],c,d),p=new ni(h,"max",!0);let f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[o],"int32",f),g=new co(h);f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const x=n.runWebGPUProgram(g,[a,m],o.dtype,f);return n.disposeData(m.dataId),x}},po={kernelName:i.OV7,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,u=s;_([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:h}=r,p=i.backend_util.computePool2DInfo(u.shape,l,c,1,d,h),f=new ti(p,"max",!0);let m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const g=n.runWebGPUProgram(f,[u],"int32",m),x=new lo(p);m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const b=n.runWebGPUProgram(x,[a,g],u.dtype,m);return n.disposeData(g.dataId),b}},fo={kernelName:i.vFR,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:u}=r,{x:l}=t;i.D5U.assert(4===l.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`));const c=[1,1];i.D5U.assert(i.backend_util.eitherStridesOrDilationsAreOne(s,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`));const d=i.backend_util.computePool2DInfo(l.shape,a,s,c,o),h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let p=new ti(d,"max",!1);const f=n.runWebGPUProgram(p,[l],l.dtype,h);return p=new ti(d,"max",!0,!0,u),[f,n.runWebGPUProgram(p,[l],"int32",h)]}},mo={kernelName:i.c17,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return Br(i,a,s,"min",n)}},go=Vt({opType:U.MIN,cpuKernelImpl:sr}),xo={kernelName:i.q8u,backendName:"webgpu",kernelFunc:go};class bo{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",s=m(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let start = ${s}(${t});\n          let end = ${s}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${a} < ${r}) {\n              ${a} = ${r} * 2 - ${a} - ${this.offset};\n            } else if(${a} >= ${i}) {\n              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const yo={kernelName:i.jQs,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:i,mode:a}=t,s=n,o=i.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new bo(r.shape,i,a);return s.runWebGPUProgram(u,[r],r.dtype,o)}},wo=Vt({opType:U.MOD}),vo={kernelName:i.Vbg,backendName:"webgpu",kernelFunc:wo};class ko{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${x("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}class Co{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${x("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}function Io(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=Nt({inputs:{x:a},backend:n,attrs:{shape:[i.D5U.sizeFromShape(a.shape)/a.shape[s],a.shape[s]]}}),u=new Co(o.shape),l=n.runWebGPUProgram(u,[o],a.dtype),c=Nt({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeData(o.dataId),n.disposeData(l.dataId),c}const So={kernelName:i.Gcp,backendName:"webgpu",kernelFunc:Io},$o={kernelName:i.NZg,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:a,seed:s,normalized:o}=r,u=o?i:Io({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new ko(l,a),h=[{type:"float32",data:[s]},{type:"int32",data:[c]}],p=n.runWebGPUProgram(d,[u],"int32",h);return o||n.disposeData(u.dataId),p}},Ro={kernelName:i.kuV,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,i]=ur(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}const i=new Mt(r.shape,Ce.NEG);return n.runWebGPUProgram(i,[r],r.dtype)}},To={kernelName:i.uv1,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h}=i.GDt.nonMaxSuppressionV3Impl(c,d,o,u,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Ao={kernelName:i.W0H,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(a.dataId),h=n.readSync(s.dataId),p=o,f=u,m=l,g=c,{selectedIndices:x,selectedScores:b}=i.GDt.nonMaxSuppressionV5Impl(d,h,p,f,m,g);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Eo{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${x("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const No={kernelName:i.we_,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:o,onValue:u,offValue:l}=r,c=i.D5U.sizeFromShape(a.shape),d=new Eo(c,o),h=Nt({inputs:{x:a},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[u]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(d,[h],s,p);n.disposeData(h.dataId);const m=Nt({inputs:{x:f},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeData(f.dataId),m}};function Do(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Ri({inputs:{input:r},backend:n}),t=Do({inputs:{x:e},backend:n}),i=Li({inputs:{input:r},backend:n}),a=Do({inputs:{x:i},backend:n}),s=Lt({inputs:{real:t,imag:a},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),s}return At({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const _o={kernelName:i.RuY,backendName:"webgpu",kernelFunc:Do},Fo={kernelName:i.qWM,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=Ri({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),a=Li({inputs:{input:i},backend:r}),s=Do({inputs:{x:a},backend:r}),o=Lt({inputs:{real:n,imag:s},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(a.dataId),r.disposeData(s.dataId),o}return At({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},Po={kernelName:i.QiL,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Ja({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{i.D5U.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),i.D5U.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Wi({inputs:t.map((e=>{const t=Ja({inputs:{input:e},backend:n,attrs:{dim:a}});return u.push(t),t})),backend:n,attrs:{axis:a}});return u.forEach((e=>n.disposeData(e.dataId))),l}};class Oo{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=m(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${r})`:`${r}`,s=e>1?"any(outC < start)":"outC < start",o=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let start = ${i};\n          let end = ${a};\n          let outC = getCoordsFromIndex(index);\n\n          if (${s} || ${o}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const Uo=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(s.every((e=>i.D5U.arraysEqual(e,[0,0]))))return Ut({inputs:{x:a},backend:n});if(0===i.D5U.sizeFromShape(a.shape))return At({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}});const u=[{type:"float32",data:[o]}];s.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new Oo(a.shape,s);return n.runWebGPUProgram(l,[a],a.dtype,u)},Bo={kernelName:i.lyA,backendName:"webgpu",kernelFunc:Uo},Lo=Vt({opType:U.POW}),zo={kernelName:i.pe_,backendName:"webgpu",kernelFunc:Lo},Mo={kernelName:i.o0g,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,a=new Ot(U.PRELU,r.shape,i.shape);return n.runWebGPUProgram(a,[r,i],"float32")}},Wo={kernelName:i.DlI,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:s}=r;return Br(i,a,s,"prod",n)}},Vo={kernelName:i.e6w,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:a,dtype:s}=n,o=dr(r,i,a,s);return t.makeTensorInfo([o.length],s,o)}},Go=Vt({opType:U.DIV}),Ho={kernelName:i.oHH,backendName:"webgpu",kernelFunc:Go},jo=Wt({opType:Ce.RECIPROCAL}),Xo={kernelName:i.$HU,backendName:"webgpu",kernelFunc:jo},Ko=Wt({opType:Ce.RELU}),qo={kernelName:i.qkr,backendName:"webgpu",kernelFunc:Ko},Yo=Wt({opType:Ce.RELU6}),Qo={kernelName:i.SbG,backendName:"webgpu",kernelFunc:Yo};class Zo{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Jo={kernelName:i._Yw,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,size:s,halfPixelCenters:o}=r,[u,l]=s,c=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],d=new Zo(i.shape,u,l);return n.runWebGPUProgram(d,[i],"float32",c)}};class eu{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const tu={kernelName:i.zbQ,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:s}=r,[,o,u]=i.shape,[,l,c]=a.shape,d=[s&&l>1?o-1:o,s&&c>1?u-1:u],h=[s&&l>1?l-1:l,s&&c>1?c-1:c],p=d[0]/h[0],f=d[1]/h[1],m=1/p,g=1/f,x=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2,y=new eu(i.shape,s),w=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[b]}];return n.runWebGPUProgram(y,[a],a.dtype,w)}};class nu{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const ru={kernelName:i.dpD,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:s,size:o}=r,[u,l]=o,c=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],d=new nu(i.shape,u,l,s);return n.runWebGPUProgram(d,[i],i.dtype,c)}};class iu{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const au={kernelName:i.Hmb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:s}=r,[,o,u]=i.shape,[,l,c]=a.shape,d=[s&&l>1?o-1:o,s&&c>1?u-1:u],h=[s&&l>1?l-1:l,s&&c>1?c-1:c],p=1/(d[0]/h[0]),f=1/(d[1]/h[1]),m=2*Math.ceil(p)+2,g=2*Math.ceil(f)+2,x=new iu(i.shape,s),b=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(x,[a],a.dtype,b)}};class su{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const ou={kernelName:i.mKl,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=a.shape.length;if(0===o)return Ut({inputs:{x:a},backend:n});const u=a.shape,l=[1,1,1,1];u.forEach(((e,t)=>{l[t+4-o]=e}));const c=i.D5U.parseAxisParam(s,a.shape),d=[0,0,0,0];c.forEach((e=>{d[e+4-o]=1}));const h=[{type:"int32",data:d}],p=Nt({inputs:{x:a},backend:n,attrs:{shape:l}}),f=new su(l),m=n.runWebGPUProgram(f,[p],p.dtype,h);n.disposeData(p.dataId);const g=Nt({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class uu{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${x("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const lu={kernelName:i.b9H,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,u=n,l=new uu(r.shape,s),[c,d]=i.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];return"number"==typeof s?h.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):h.push({type:"float32",data:s}),u.runWebGPUProgram(l,[r],r.dtype,h)}},cu=Wt({opType:Ce.ROUND}),du={kernelName:i.e07,backendName:"webgpu",kernelFunc:cu},hu=Wt({opType:Ce.RSQRT,cpuKernelImpl:hr}),pu={kernelName:i.bV0,backendName:"webgpu",kernelFunc:hu};class fu{constructor(e,t,n,r,i,a,s,o=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=s,this.sumDupeIndices=o,this.dispatchLayout=E(e),this.dispatch=R(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${s}_${o}`;const u=m(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const a=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${i}\n      ${x("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${I(this.type)}(${a});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?p("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const mu={kernelName:i.xQA,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=i.backend_util.calculateShapes(s,a,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,a.dtype);const f=Nt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=Nt({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=m.dtype,x=At({backend:n,attrs:{shape:p,value:0,dtype:g}}),b=[{type:"int32",data:[u]},{type:"int32",data:d},{type:"int32",data:[i.D5U.sizeFromShape(m.shape)]}],y=new fu(m.shape,u,f.shape.length,m.shape.length,d,p,g),w=n.runWebGPUProgram(y,[m,f],g,b,x),v=Nt({inputs:{x:w},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(w.dataId),v}};class gu{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const xu={kernelName:i.nr8,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:a}=t,{side:s}=r,o=new gu([a.shape[0],a.shape[1]],s),u=[{type:"int32",data:[i.shape[1]]}];return n.runWebGPUProgram(o,[i,a],"int32",u)}};class bu{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let e=0;e<this.outputShape.length;e++)i.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=i.join()}return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const yu={kernelName:i.PhF,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new bu(r.shape.length,a.shape,a.shape.length);return n.runWebGPUProgram(o,[r,a,s],(0,i.x8V)(a.dtype,s.dtype))}},wu=Wt({opType:Ce.SELU}),vu={kernelName:i.oFR,backendName:"webgpu",kernelFunc:wu},ku=Wt({opType:Ce.SIGMOID}),Cu={kernelName:i.a5O,backendName:"webgpu",kernelFunc:ku},Iu=Wt({opType:Ce.SIGN}),Su={kernelName:i.i5y,backendName:"webgpu",kernelFunc:Iu},$u=Wt({opType:Ce.SIN}),Ru={kernelName:i.RQH,backendName:"webgpu",kernelFunc:$u},Tu=Wt({opType:Ce.SINH}),Au={kernelName:i.wYB,backendName:"webgpu",kernelFunc:Tu},Eu=Wt({opType:Ce.SOFTPLUS}),Nu={kernelName:i.MRv,backendName:"webgpu",kernelFunc:Eu},Du={kernelName:i.TQc,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;i.D5U.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const u=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const c=[],d=Uo({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=i.backend_util.getReshaped(d.shape,s,u,!1),p=i.backend_util.getPermuted(h.length,s.length,!1),f=i.backend_util.getReshapedPermuted(d.shape,s,u,!1),m=Nt({inputs:{x:d},backend:n,attrs:{shape:h}}),g=Pr({inputs:{x:m},backend:n,attrs:{perm:p}}),x=Nt({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(d),c.push(m),c.push(g),c.forEach((e=>n.disposeData(e.dataId))),x}};class _u{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e;i++)r.push(`(${n[i]} % ${t}aShape[${i}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${x("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function Fu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(n.shouldExecuteOnCPU([a])||"string"===a.dtype||a.shape.length>=5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>i.D5U.decodeString(e))):e,r=(0,i.f3b)(a.shape,a.dtype,t),o=yr(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new _u(a.shape,s);return n.runWebGPUProgram(o,[a],a.dtype)}const Pu={kernelName:i.n9L,backendName:"webgpu",kernelFunc:Fu},Ou={kernelName:i.D2d,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:u}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=i.backend_util.calculateShapes(s,a,u),f=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=i.D5U.decodeString(n.readSync(o.dataId)[0]),m=pr(e,t,u,p,d,c,l,h,r,f);return n.makeTensorInfo(u,m.dtype,m.values)}const m=[p/d,d],g=Nt({inputs:{x:a},backend:n,attrs:{shape:[c,l]}}),x=s.shape.length?Nt({inputs:{x:s},backend:n,attrs:{shape:[c,d]}}):Ut({inputs:{x:s},backend:n}),b=x.dtype,y=n.makeTensorInfo([],b,i.D5U.makeZerosTypedArray(1,b)),w=Nt({inputs:{x:o},backend:n,attrs:{shape:Array(m.length).fill(1)}}),v=Fu({inputs:{x:w},backend:n,attrs:{reps:m}}),k=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[i.D5U.sizeFromShape([c,d])]}];switch(c){case 0:break;case 1:{const e=new fu([c,d],l,g.shape.length,x.shape.length,h,m,b,f);n.runWebGPUProgram(e,[x,g],b,k,v)}break;default:{const e=new fu([c,d],l,g.shape.length,y.shape.length,h,m,b,f);n.runWebGPUProgram(e,[y,g],b,k,v)}{const e=new fu([c,d],l,g.shape.length,x.shape.length,h,m,b);n.runWebGPUProgram(e,[x,g],b,k,v)}}const C=Nt({inputs:{x:v},backend:n,attrs:{shape:u}});return n.disposeData(g.dataId),n.disposeData(x.dataId),n.disposeData(w.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),C}},Uu={kernelName:i.L8s,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,u=i.D5U.parseAxisParam(o,a.shape)[0],l=i.backend_util.prepareSplitSize(a,s,u),c=a.shape.length,d=new Array(c).fill(0),h=a.shape.slice();return l.map((e=>{const t=[...h];t[u]=e;const r=xi({inputs:{x:a},backend:n,attrs:{begin:d,size:t}});return d[u]+=e,r}))}},Bu=Wt({opType:Ce.SQRT}),Lu={kernelName:i.FKq,backendName:"webgpu",kernelFunc:Bu},zu={kernelName:i.bK0,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new Mt(n.shape,Ce.SQUARE);return r.runWebGPUProgram(i,[n],n.dtype)}},Mu=Vt({opType:U.SQUARED_DIFFERENCE}),Wu={kernelName:i._tC,backendName:"webgpu",kernelFunc:Mu},Vu={kernelName:i.h8e,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=new Mt(r.shape,Ce.STEP,"stepAlpha : f32,"),a=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(i,[r],r.dtype,a)}};class Gu{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=m(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${x("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Hu={kernelName:i.jQk,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:v}=i.kuN.sliceInfo(a.shape,s,o,u,l,c,d,h,p);let k;if(g)k=Nt({inputs:{x:a},backend:n,attrs:{shape:m}});else if(x||b){i.D5U.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=i.kuN.computeOutShape(y,w,v),t=xi({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});k=Nt({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeData(t.dataId)}else if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=(0,i.f3b)(a.shape,a.dtype,e),r=gr(f,t,v,y);k=n.makeTensorInfo(m,a.dtype,r.values)}else{const e=new Gu(f),t=[{type:"int32",data:y},{type:"int32",data:v}],r=n.runWebGPUProgram(e,[a],a.dtype,t);k=Nt({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}return k}},ju={kernelName:i._JP,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:a,leftPad:s,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=xr(h,p,i,a,s,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},Xu=Vt({opType:U.SUB,cpuKernelImpl:br,supportsComplex:!0}),Ku={kernelName:i.Tr8,backendName:"webgpu",kernelFunc:Xu},qu=Wt({opType:Ce.TAN}),Yu={kernelName:i.sEM,backendName:"webgpu",kernelFunc:qu},Qu=Wt({opType:Ce.TANH}),Zu={kernelName:i.MIZ,backendName:"webgpu",kernelFunc:Qu},Ju={kernelName:i.SIB,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:o}=t,{}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=i.backend_util.calculateShapes(o,s,a.shape),p=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,s.dtype);const f=[],m=Nt({inputs:{x:s},backend:n,attrs:{shape:[l,u]}});f.push(m);const g=Nt({inputs:{x:o},backend:n,attrs:{shape:[l,c]}});f.push(g);const x=Nt({inputs:{x:a},backend:n,attrs:{shape:p}});f.push(x);const b=Fu({inputs:{x},backend:n,attrs:{reps:Array(p.length).fill(1)}}),y=new fu([l,c],u,m.shape.length,g.shape.length,d,p,a.dtype,!1),w=[{type:"int32",data:[u]},{type:"int32",data:d},{type:"int32",data:[i.D5U.sizeFromShape([l,c])]}],v=n.runWebGPUProgram(y,[g,m],x.dtype,w,b);f.push(v);const k=Nt({inputs:{x:v},backend:n,attrs:{shape:a.shape}});return f.forEach((e=>n.disposeData(e.dataId))),k}};class el{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${x("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class tl{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${x("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function nl(e,t){null!==t&&e.disposeData(t.dataId)}function rl(e){let t=1;for(;t<e;)t*=2;return t}const il={kernelName:i.cWu,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,u=a.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),[t,r]=wr(e,u,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[a,At({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const c=i.D5U.sizeFromShape(u)/l,d=Nt({inputs:{x:a},attrs:{shape:[c,l]},backend:n}),h=rl(s),p=rl(l);let f=null;const m=()=>null===f?[d,d]:[d,f],g=(e,t,r)=>{const i=m(),a=new el(r),s=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(a,i,"int32",s),nl(n,o)};for(let e=1;e<h;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[c,p])}for(let e=p;e>h;e/=2){const t=m(),r=new tl([c,e/2]),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[h]}],a=f;f=n.runWebGPUProgram(r,t,"int32",i),nl(n,a);const s=h/2,o=2*s;for(let e=s;e>=1;e/=2)g(o,e,f.shape)}let x=f;f=xi({inputs:{x:f},backend:n,attrs:{begin:0,size:[c,s]}}),nl(n,x);let b=Cs({inputs:{x:d,indices:f},backend:n,attrs:{axis:1,batchDims:1}});nl(n,d);const y=u.slice(0,-1);y.push(s),x=f,f=Nt({inputs:{x:f},attrs:{shape:y},backend:n}),nl(n,x);const w=b;return b=Nt({inputs:{x:b},attrs:{shape:y},backend:n}),nl(n,w),[b,f]}};class al{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=E(this.outputShape),this.dispatch=R(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${x("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const sl={kernelName:i.wx7,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:a}=t,{interpolation:s,fillMode:o,fillValue:u,outputShape:l}=r,[c,d,h,p]=i.shape,[f,m]=null!=l?l:[d,h],g=new al([c,f,m,p]),x="nearest"===s?1:2;let b;switch(o){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const y=[{type:"int32",data:[x]},{type:"int32",data:[b]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[i,a],"float32",y)}},ol={kernelName:i.ToN,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:a}=r;a<0&&(a+=i.shape.length);const s=i,o=s.shape.length,u=i.shape[a],l=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(l[c++]=s.shape[e]);const d=[],h=new Array(o).fill(0),p=s.shape.slice();p[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){h[a]=e;const t=xi({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),r=Nt({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),f}};class ul{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=E(e),this.dispatch=R(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${x("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${p("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}const ll=[Ft,Ir,$r,Tr,Er,Dr,Lr,zr,Wr,Vr,Hr,Xr,qr,Qr,Jr,ui,li,hi,pi,fi,yi,ki,Ii,Ai,Ni,Fi,zt,Ui,Vi,qi,ea,na,ia,aa,sa,ua,ca,ha,ba,ya,wa,ka,Aa,Ea,$a,Da,Fa,Ua,Ba,Va,Ha,ja,Ka,Ya,Za,es,ns,as,Et,os,ps,ls,ds,xs,bs,ys,vs,Is,$s,Ts,Bt,As,zi,Ns,_s,Ps,Os,Bs,zs,Ws,js,Gs,Ks,Ys,Zs,no,io,ii,so,oo,po,uo,ho,fo,si,mo,xo,yo,vo,$o,za,Ro,To,Ao,$i,No,Fo,Po,Bo,zo,Mo,Wo,Vo,Ti,Ho,Xo,qo,Qo,Dt,Jo,tu,ru,au,ou,lu,du,pu,mu,xu,yu,vu,Cu,Su,Ru,Au,bi,Vu,Hu,ju,So,Nu,Du,Ou,Uu,Lu,zu,Wu,Ku,Wa,Yu,Zu,Ju,Pu,il,sl,Or,ol,{kernelName:i.Qvg,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r,u=a.shape.length,l=[];let c=0;const d=i.backend_util.getAxesPermutation([c],u);let h=a;null!=d&&(h=Pr({inputs:{x:a},backend:n,attrs:{perm:d}}),l.push(h),c=i.backend_util.getInnerMostAxes(1,u)[0]);const p=i.backend_util.segment_util.computeOutShape(h.shape,c,o),f=i.D5U.sizeFromShape([h.shape[c]]),m=Nt({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=a.dtype,x=[m.shape[0],o],b=At({backend:n,attrs:{shape:x,value:0,dtype:g}}),y=new ul(m.shape,x,g),w=[{type:"int32",data:[o]},{type:"int32",data:[i.D5U.sizeFromShape(m.shape)]}],v=n.runWebGPUProgram(y,[m,s],g,w,b),k=Nt({inputs:{x:v},backend:n,attrs:{shape:p}});l.push(v);let C=k;if(null!=d){l.push(k);const e=i.backend_util.getUndoAxesPermutation(d);C=Pr({inputs:{x:C},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeData(e.dataId))),C}},_o];for(const e of ll)(0,i.wCN)(e)},320:(e,t,n)=>{"use strict";n.d(t,{SYM:()=>ge,VGw:()=>xe,SpW:()=>be,mm_:()=>ye,Xze:()=>we,oT6:()=>ve,IKK:()=>ke,sJF:()=>Ce,aJk:()=>Ie,M2y:()=>Se,qw7:()=>$e,jMg:()=>Re,QCc:()=>Ae,Oyi:()=>Te,JhU:()=>Ee,_k9:()=>De,IMb:()=>_e,ROF:()=>Ne,XLW:()=>Fe,zws:()=>Pe,zvY:()=>Oe,hCO:()=>Ue,eEB:()=>Be,RFZ:()=>Le,gJX:()=>ze,xnO:()=>Me,Zz9:()=>We,yj2:()=>Ve,Eh3:()=>Ge,mhS:()=>He,wUP:()=>je,wm:()=>Xe,x12:()=>Ke,o2y:()=>qe,ik2:()=>Ye,mc4:()=>Qe,TR1:()=>Ze,VcC:()=>tt,Byc:()=>Je,iHb:()=>et,JLz:()=>d,QRR:()=>nt,T0n:()=>rt,cie:()=>it,sL$:()=>at,y7R:()=>st,$w:()=>ot,p4S:()=>ut,Vn9:()=>ct,ekb:()=>lt,$g6:()=>pt,SX0:()=>ft,HEU:()=>mt,hdR:()=>xt,Omj:()=>gt,NEP:()=>bt,YFo:()=>yt,Y0y:()=>wt,vwp:()=>vt,deh:()=>kt,Uyb:()=>Ct,OR:()=>It,jeX:()=>St,eBW:()=>Cr,sHE:()=>$t,_V0:()=>$r,luS:()=>Rr,q1x:()=>Tt,qi_:()=>Rt,iZT:()=>At,Acj:()=>Et,Qg5:()=>Dt,iJz:()=>Nt,J_u:()=>_t,avt:()=>Ft,iWB:()=>Pt,r7n:()=>Ot,Zuw:()=>h,eZ0:()=>jt,Hhh:()=>Xt,J$2:()=>Ut,vtC:()=>Bt,CAk:()=>Lt,e7N:()=>zt,ZbH:()=>Mt,kU:()=>Wt,PYm:()=>Vt,VfG:()=>Gt,MZg:()=>Ht,YoZ:()=>Kt,mTV:()=>Yt,OAf:()=>Zt,OU7:()=>Jt,OV7:()=>Qt,vFR:()=>en,BMI:()=>qt,q2K:()=>tn,c17:()=>nn,q8u:()=>rn,jQs:()=>an,Vbg:()=>sn,NZg:()=>on,wYn:()=>un,kuV:()=>ln,uv1:()=>dn,cye:()=>hn,W0H:()=>pn,yQU:()=>cn,we_:()=>mn,qWM:()=>fn,QiL:()=>gn,lyA:()=>xn,pe_:()=>bn,o0g:()=>yn,DlI:()=>wn,dDz:()=>vn,CQl:()=>kn,BiW:()=>Cn,e6w:()=>In,xJR:()=>Sn,oHH:()=>ht,$HU:()=>$n,qkr:()=>Rn,SbG:()=>_n,HZH:()=>Tn,_Yw:()=>Nn,zbQ:()=>Dn,dpD:()=>An,Hmb:()=>En,mKl:()=>Fn,b9H:()=>Ir,e07:()=>Pn,bV0:()=>On,xQA:()=>Un,nr8:()=>Ln,PhF:()=>zn,oFR:()=>Mn,a5O:()=>jn,i5y:()=>Hn,RQH:()=>Vn,wYB:()=>Gn,p2w:()=>Wn,Gcp:()=>Zn,MRv:()=>Xn,TQc:()=>Yn,O3z:()=>Jn,nhH:()=>er,w3H:()=>tr,ZjV:()=>nr,D2d:()=>rr,L8s:()=>Qn,FKq:()=>Kn,bK0:()=>ar,_tC:()=>ir,e0R:()=>sr,h8e:()=>kr,jQk:()=>or,_JP:()=>ur,s1s:()=>lr,XkS:()=>cr,Tr8:()=>dr,GBy:()=>qn,sEM:()=>hr,MIZ:()=>pr,esB:()=>vi,YDk:()=>xi,SIB:()=>Bn,n9L:()=>fr,cWu:()=>mr,wx7:()=>gr,G3Y:()=>xr,kpP:()=>br,ToN:()=>yr,Qvg:()=>wr,RuY:()=>vr,usg:()=>Sr,IHx:()=>Ua,NqF:()=>Ws,y3$:()=>Oa,backend_util:()=>l,UFq:()=>Gs,Jyw:()=>a,Xhn:()=>s,f3b:()=>Ca,pju:()=>Aa,iUl:()=>Hs,zoF:()=>js,C2$:()=>i,B90:()=>_a,hiC:()=>La,SRH:()=>Na,OBj:()=>de,Qqt:()=>Xs,dt4:()=>Ks,N_N:()=>Fa,BHj:()=>jo,GDt:()=>c,LTh:()=>qs,VdP:()=>Ys,dC7:()=>za,glt:()=>Ko,vku:()=>Qs,jqO:()=>Pa,wCN:()=>Pr,XLQ:()=>Vs,iD$:()=>Ha,XD2:()=>Zs,tPi:()=>Js,kuN:()=>o,h62:()=>Wa,L9e:()=>eo,luU:()=>es,z4k:()=>Ei,RRF:()=>to,odF:()=>no,lub:()=>Da,x8V:()=>Ai,D5U:()=>r,lls:()=>io});var r={};n.r(r),n.d(r,{arraysEqual:()=>T,arraysEqualWithNull:()=>R,assert:()=>k,assertNonNegativeIntegerDimensions:()=>ie,assertNonNull:()=>I,assertShapesMatch:()=>C,bytesFromStringArray:()=>G,bytesPerElement:()=>V,checkConversionForErrors:()=>z,clamp:()=>g,computeStrides:()=>Q,convertBackendValuesAndArrayBuffer:()=>ee,createScalarValue:()=>Zr,createShuffledIndices:()=>D,decodeString:()=>ri,distSquared:()=>v,encodeString:()=>ni,fetch:()=>ti,fingerPrint64:()=>Qr,flatten:()=>ai,getArrayFromDType:()=>L,getTypedArrayFromDType:()=>B,hasEncodingLoss:()=>W,hexToLong:()=>zr,indexToLoc:()=>se,inferDtype:()=>K,inferFromImplicitShape:()=>P,isBoolean:()=>j,isFunction:()=>q,isInt:()=>A,isNumber:()=>X,isPromise:()=>oe,isScalarShape:()=>$,isString:()=>H,isTypedArray:()=>ii,isValidDtype:()=>M,locToIndex:()=>ae,makeOnesTypedArray:()=>te,makeZerosNestedTypedArray:()=>re,makeZerosTypedArray:()=>ne,nearestDivisor:()=>Y,nearestLargerEven:()=>x,now:()=>ei,parseAxisParam:()=>O,randUniform:()=>w,repeatedTry:()=>F,rightPad:()=>_,shuffle:()=>f,shuffleCombo:()=>m,sizeFromShape:()=>S,sizeToSquarishShape:()=>N,squeezeShape:()=>U,sum:()=>y,swap:()=>b,tanh:()=>E,toNestedArray:()=>J,toTypedArray:()=>Jr});var i={};n.r(i),n.d(i,{isBrowser:()=>Hi,isMobile:()=>Gi,mockIsMobile:()=>Vi});var a={};n.r(a),n.d(a,{assertAndGetBroadcastShape:()=>is,getBroadcastDims:()=>ns,getReductionAxes:()=>rs});var s={};n.r(s),n.d(s,{draw:()=>vs,fromPixels:()=>ks,fromPixelsAsync:()=>bs,toPixels:()=>ws});var o={};n.r(o),n.d(o,{assertParamsValid:()=>Ss,computeFlatOffset:()=>Bs,computeOutShape:()=>Rs,getNormalizedAxes:()=>Ns,isSliceContinous:()=>Us,maskToAxes:()=>$s,parseSliceParams:()=>Ls,sliceInfo:()=>zs,startForAxis:()=>Ps,startIndicesWithElidedDims:()=>Ds,stopForAxis:()=>Os,stopIndicesWithElidedDims:()=>_s,stridesForAxis:()=>Fs,stridesWithElidedDims:()=>Ts});var u={};n.r(u),n.d(u,{collectGatherOpShapeInfo:()=>Sl,computeOutShape:()=>Il,segOpComputeOptimalWindowSize:()=>Cl});var l={};n.r(l),n.d(l,{ERF_A1:()=>Mu,ERF_A2:()=>Wu,ERF_A3:()=>Vu,ERF_A4:()=>Gu,ERF_A5:()=>Hu,ERF_P:()=>zu,PARALLELIZE_THRESHOLD:()=>$u,RowPartitionType:()=>vu,SELU_SCALE:()=>Lu,SELU_SCALEALPHA:()=>Bu,applyActivation:()=>yu,assertAndGetBroadcastShape:()=>is,assertAxesAreInnerMostDims:()=>zo,assertParamsConsistent:()=>qo,assignToTypedArray:()=>Qu,axesAreInnerMostDims:()=>Oo,calculateShapes:()=>Uu,checkEinsumDimSizes:()=>sl,checkPadOnDimRoundingMode:()=>du,combineLocations:()=>Uo,combineRaggedTensorToTensorShapes:()=>ku,complexWithEvenIndex:()=>Ku,complexWithOddIndex:()=>qu,computeConv2DInfo:()=>eu,computeConv3DInfo:()=>tu,computeDefaultPad:()=>nu,computeDilation2DInfo:()=>Qo,computeOptimalWindowSize:()=>Ru,computeOutAndReduceShapes:()=>Bo,computeOutShape:()=>Yo,computePool2DInfo:()=>Zo,computePool3DInfo:()=>Jo,convertConv2DDataFormat:()=>cu,decodeEinsumEquation:()=>il,eitherStridesOrDilationsAreOne:()=>uu,expandShapeToKeepDim:()=>Lo,exponent:()=>Ju,exponents:()=>Zu,fromStringArrayToUint8:()=>Rl,fromUint8ToStringArray:()=>$l,getAxesPermutation:()=>Mo,getBroadcastDims:()=>ns,getComplexWithIndex:()=>Yu,getEinsumComputePath:()=>ol,getEinsumPermutation:()=>al,getFusedBiasGradient:()=>bu,getFusedDyActivation:()=>xu,getImageCenter:()=>Tu,getInnerMostAxes:()=>Vo,getPermuted:()=>Eu,getRaggedRank:()=>Iu,getReductionAxes:()=>rs,getReshaped:()=>Au,getReshapedPermuted:()=>Nu,getRowPartitionTypesHelper:()=>Cu,getSliceBeginCoords:()=>Du,getSliceSize:()=>_u,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>dl,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>hl,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>pl,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>gl,getSparseReshapeInputOutputMismatchErrorMessage:()=>bl,getSparseReshapeInputOutputMultipleErrorMessage:()=>xl,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>fl,getSparseReshapeNegativeOutputDimErrorMessage:()=>ml,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>kl,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>yl,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>wl,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>vl,getUndoAxesPermutation:()=>Wo,isIdentityPermutation:()=>ul,log:()=>Ar,mergeRealAndImagArrays:()=>ju,prepareAndValidate:()=>Fu,prepareSplitSize:()=>cl,segment_util:()=>u,shouldFuse:()=>wu,slice_util:()=>o,splitRealAndImagArrays:()=>Xu,stridesOrDilationsArePositive:()=>lu,tupleValuesAreOne:()=>ou,upcastType:()=>Ai,validateDefaultValueShape:()=>Su,validateInput:()=>Ou,validateUpdateShape:()=>Pu,warn:()=>Tr});var c={};n.r(c),n.d(c,{nonMaxSuppressionV3Impl:()=>go,nonMaxSuppressionV4Impl:()=>xo,nonMaxSuppressionV5Impl:()=>bo,whereImpl:()=>Tl});class d{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class h{refCount(e){return p("refCount")}incRef(e){return p("incRef")}timerAvailable(){return!0}time(e){return p("time")}read(e){return p("read")}readSync(e){return p("readSync")}readToGPU(e,t){return p("readToGPU")}numDataIds(){return p("numDataIds")}disposeData(e,t){return p("disposeData")}write(e,t,n){return p("write")}move(e,t,n,r,i){return p("move")}createTensorFromGPUData(e,t,n){return p("createTensorFromGPUData")}memory(){return p("memory")}floatPrecision(){return p("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return p("dispose")}}function p(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function f(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,b(e,t,n)}function m(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,b(e,n,r),b(t,n,r)}function g(e,t,n){return Math.max(e,Math.min(t,n))}function x(e){return e%2==0?e:e+1}function b(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function y(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function w(e,t){const n=Math.random();return t*n+(1-n)*e}function v(e,t){let n=0;for(let r=0;r<e.length;r++){const i=Number(e[r])-Number(t[r]);n+=i*i}return n}function k(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function C(e,t,n=""){k(T(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function I(e){k(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function S(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $(e){return 0===e.length}function R(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function T(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function A(e){return e%1==0}function E(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function N(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function D(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return f(t),t}function _(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function F(e,t=(e=>0),n,r){return new Promise(((i,a)=>{let s=0;const o=()=>{if(e())return void i();s++;const u=t(s);null!=n&&s>=n?a():null!=r?r(o,u):setTimeout(o,u)};o()}))}function P(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const i=e.slice();return i[r]=t/n,i}function O(e,t){const n=t.length;return k((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),k(e.every((e=>A(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function U(e,t){const n=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||i?null:O(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[s]||a[s]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[s]<=t&&s++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function B(e,t){return L(e,t)}function L(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function z(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function M(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function W(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function V(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function G(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function H(e){return"string"==typeof e||e instanceof String}function j(e){return"boolean"==typeof e}function X(e){return"number"==typeof e}function K(e){return Array.isArray(e)?K(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":X(e)?"float32":H(e)?"string":j(e)?"bool":"float32"}function q(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Y(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Q(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Z(e,t,n,r=!1){const i=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)i[t]=n[e+t]}else{const a=t[0],s=t.slice(1),o=s.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)i[t]=Z(e+t*o,s,n,r)}return i}function J(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Z(0,e,t,n)}function ee(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function te(e,t){const n=ne(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function ne(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function re(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return J(e,new Float32Array(n));if("int32"===t)return J(e,new Int32Array(n));if("bool"===t)return J(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ie(e){e.forEach((t=>{k(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function ae(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function se(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function oe(e){return e&&e.then&&"function"==typeof e.then}const ue="tfjsflags";class le{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ce,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(oe(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);ue in e&&e[ue].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}function ce(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function de(){return pe}let he,pe=null;function fe(){if(null==he){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}he=e}return he}function me(e,t){const n=function(){const e=fe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const ge="Abs",xe="Acos",be="Acosh",ye="Add",we="AddN",ve="All",ke="Any",Ce="ArgMax",Ie="ArgMin",Se="Asin",$e="Asinh",Re="Atan",Te="Atanh",Ae="Atan2",Ee="AvgPool",Ne="AvgPoolGrad",De="AvgPool3D",_e="AvgPool3DGrad",Fe="BatchMatMul",Pe="BatchToSpaceND",Oe="Bincount",Ue="BitwiseAnd",Be="BroadcastArgs",Le="Cast",ze="Ceil",Me="ClipByValue",We="Complex",Ve="ComplexAbs",Ge="Concat",He="Conv2D",je="Conv2DBackpropFilter",Xe="Conv2DBackpropInput",Ke="Conv3D",qe="Conv3DBackpropFilterV2",Ye="Conv3DBackpropInputV2",Qe="Cos",Ze="Cosh",Je="Cumprod",et="Cumsum",tt="CropAndResize",nt="DenseBincount",rt="DepthToSpace",it="DepthwiseConv2dNative",at="DepthwiseConv2dNativeBackpropFilter",st="DepthwiseConv2dNativeBackpropInput",ot="Diag",ut="Dilation2D",lt="Dilation2DBackpropInput",ct="Dilation2DBackpropFilter",dt="Draw",ht="RealDiv",pt="Einsum",ft="Elu",mt="EluGrad",gt="Erf",xt="Equal",bt="Exp",yt="ExpandDims",wt="Expm1",vt="FFT",kt="Fill",Ct="FlipLeftRight",It="Floor",St="FloorDiv",$t="FusedBatchNorm",Rt="GatherV2",Tt="GatherNd",At="Greater",Et="GreaterEqual",Nt="Identity",Dt="IFFT",_t="Imag",Ft="IsFinite",Pt="IsInf",Ot="IsNan",Ut="LeakyRelu",Bt="Less",Lt="LessEqual",zt="LinSpace",Mt="Log",Wt="Log1p",Vt="LogicalAnd",Gt="LogicalNot",Ht="LogicalOr",jt="LRN",Xt="LRNGrad",Kt="Max",qt="Maximum",Yt="MaxPool",Qt="MaxPoolGrad",Zt="MaxPool3D",Jt="MaxPool3DGrad",en="MaxPoolWithArgmax",tn="Mean",nn="Min",rn="Minimum",an="MirrorPad",sn="Mod",on="Multinomial",un="Multiply",ln="Neg",cn="NotEqual",dn="NonMaxSuppressionV3",hn="NonMaxSuppressionV4",pn="NonMaxSuppressionV5",fn="OnesLike",mn="OneHot",gn="Pack",xn="PadV2",bn="Pow",yn="Prelu",wn="Prod",vn="RaggedGather",kn="RaggedRange",Cn="RaggedTensorToTensor",In="Range",Sn="Real",$n="Reciprocal",Rn="Relu",Tn="Reshape",An="ResizeNearestNeighbor",En="ResizeNearestNeighborGrad",Nn="ResizeBilinear",Dn="ResizeBilinearGrad",_n="Relu6",Fn="Reverse",Pn="Round",On="Rsqrt",Un="ScatterNd",Bn="TensorScatterUpdate",Ln="SearchSorted",zn="Select",Mn="Selu",Wn="Slice",Vn="Sin",Gn="Sinh",Hn="Sign",jn="Sigmoid",Xn="Softplus",Kn="Sqrt",qn="Sum",Yn="SpaceToBatchND",Qn="SplitV",Zn="Softmax",Jn="SparseFillEmptyRows",er="SparseReshape",tr="SparseSegmentMean",nr="SparseSegmentSum",rr="SparseToDense",ir="SquaredDifference",ar="Square",sr="StaticRegexReplace",or="StridedSlice",ur="StringNGrams",lr="StringSplit",cr="StringToHashBucketFast",dr="Sub",hr="Tan",pr="Tanh",fr="Tile",mr="TopK",gr="Transform",xr="Transpose",br="Unique",yr="Unpack",wr="UnsortedSegmentSum",vr="ZerosLike",kr="Step",Cr="FromPixels",Ir="RotateWithOffset",Sr="_FusedMatMul",$r="FusedConv2D",Rr="FusedDepthwiseConv2D";function Tr(...e){de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(...e)}function Ar(...e){de().getBool("IS_TEST")||de().getBool("PROD")||console.log(...e)}const Er=me("kernelRegistry",(()=>new Map)),Nr=me("gradRegistry",(()=>new Map));function Dr(e,t){const n=Or(e,t);return Er.get(n)}function _r(e){return Nr.get(e)}function Fr(e){const t=Er.entries(),n=[];for(;;){const{done:r,value:i}=t.next();if(r)break;const[a,s]=i,[o]=a.split("_");o===e&&n.push(s)}return n}function Pr(e){const{kernelName:t,backendName:n}=e,r=Or(t,n);Er.has(r)&&Tr(`The kernel '${t}' for backend '${n}' is already registered`),Er.set(r,e)}function Or(e,t){return`${t}_${e}`}function Ur(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Br=n(720);const Lr=n.n(Br)()||Br;function zr(e){return Lr.fromString(e,!0,16)}const Mr=zr("c3a5c85c97cb3127"),Wr=zr("b492b66fbe98f273"),Vr=zr("9ae16a3b2f90404f");function Gr(e){return e.xor(e.shru(47))}function Hr(e,t,n){const r=e.slice(t,t+n);return Lr.fromBytes(Array.from(r),!0,!0)}function jr(e,t){return Hr(e,t,8)}function Xr(e,t){return Hr(e,t,4)}function Kr(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function qr(e,t,n=zr("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let i=t.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function Yr(e,t,n,r){return function(e,t,n,r,i,a){i=i.add(e),a=Kr(a.add(i).add(r),21);const s=i;return i=(i=i.add(t)).add(n),a=a.add(Kr(i,44)),[i.add(r),a.add(s)]}(jr(e,t),jr(e,t+8),jr(e,t+16),jr(e,t+24),n,r)}function Qr(e,t=e.length){const n=Lr.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=Vr.add(2*t),r=jr(e,0).add(Vr),i=jr(e,t-8);return qr(Kr(i,37).mul(n).add(r),Kr(r,25).add(i).mul(n),n)}if(t>=4){const n=Vr.add(2*t);return qr(Xr(e,0).shl(3).add(t),Xr(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Gr(Vr.mul(n).xor(Mr.mul(r))).mul(Vr)}return Vr}(e,t):function(e,t=e.length){const n=Vr.add(2*t),r=jr(e,0).mul(Wr),i=jr(e,8),a=jr(e,t-8).mul(n),s=jr(e,t-16).mul(Vr);return qr(Kr(r.add(i),43).add(Kr(a,30)).add(s),r.add(Kr(i.add(Vr),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=Vr.add(2*t),r=jr(e,0).mul(Vr),i=jr(e,8),a=jr(e,t-8).mul(n),s=jr(e,t-16).mul(Vr),o=Kr(r.add(i),43).add(Kr(a,30)).add(s),u=qr(o,r.add(Kr(i.add(Vr),18)).add(a),n),l=jr(e,16).mul(n),c=jr(e,24),d=o.add(jr(e,t-32)).mul(n),h=u.add(jr(e,t-24)).mul(n);return qr(Kr(l.add(c),43).add(Kr(d,30)).add(h),l.add(Kr(c.add(r),18)).add(d),n)}(e,t);let r=n,i=n.mul(Wr).add(113),a=Gr(i.mul(Vr).add(113)).mul(Vr),s=[Lr.UZERO,Lr.UZERO],o=[Lr.UZERO,Lr.UZERO];r=r.mul(Vr).add(jr(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=Kr(r.add(i).add(s[0]).add(jr(e,u+8)),37).mul(Wr),i=Kr(i.add(s[1]).add(jr(e,u+48)),42).mul(Wr),r=r.xor(o[1]),i=i.add(s[0]).add(jr(e,u+40)),a=Kr(a.add(o[0]),33).mul(Wr),s=Yr(e,u,s[1].mul(Wr),r.add(o[0])),o=Yr(e,u+32,a.add(o[1]),i.add(jr(e,u+16))),[a,r]=[r,a],u+=64}while(u!==l);const d=Wr.add(a.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),s[0]=s[0].add(o[0]),o[0]=o[0].add(s[0]),r=Kr(r.add(i).add(s[0]).add(jr(e,u+8)),37).mul(d),i=Kr(i.add(s[1]).add(jr(e,u+48)),42).mul(d),r=r.xor(o[1].mul(9)),i=i.add(s[0].mul(9).add(jr(e,u+40))),a=Kr(a.add(o[0]),33).mul(d),s=Yr(e,u,s[1].mul(d),r.add(o[0])),o=Yr(e,u+32,a.add(o[1]),i.add(jr(e,u+16))),[a,r]=[r,a],qr(qr(s[0],o[0],d).add(Gr(i).mul(Mr)).add(a),qr(s[1],o[1],d).add(r),d)}function Zr(e,t){return"string"===t?ni(e):Jr([e],t)}function Jr(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ai(e)),de().getBool("DEBUG")&&z(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function ei(){return de().platform.now()}function ti(e,t){return de().platform.fetch(e,t)}function ni(e,t="utf-8"){return t=t||"utf-8",de().platform.encode(e,t)}function ri(e,t="utf-8"){return t=t||"utf-8",de().platform.decode(e,t)}function ii(e){return null!=de().platform.isTypedArray?de().platform.isTypedArray(e):Ur(e)}function ai(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||oe(e)||null==e||ii(e)&&n)t.push(e);else if(Array.isArray(e)||ii(e))for(let r=0;r<e.length;++r)ai(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let i=0;i<=r;i++)ai(e[i],t,n)}return t}class si{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ui)}profileKernel(e,t,n){let r;const i=()=>{r=n()};let a;const s=ei();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:ei()-s})}if(de().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{oi(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:i,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],i,n[2])}))}))}}function oi(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class ui{logKernelProfile(e,t,n,r,i,a){const s="number"==typeof r?_(`${r}ms`,9):r.error,o=_(e,25),u=t.rank,l=t.size,c=_(t.shape.toString(),14);let d="";for(const e in i){const n=i[e];if(null!=n){const r=n.shape||t.shape,i=r.length;d+=`${e}: ${i}D ${i>0?r:""} `}}console.log(`%c${o}\t%c${s}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const li=20,ci=3,di=7;function hi(e,t,n,r){const i=Q(t),a=function(e,t,n,r){const i=S(t),a=r[r.length-1],s=new Array(a).fill(0),o=t.length,u="complex64"===n?gi(e):e;if(o>1)for(let e=0;e<i/a;e++){const t=e*a;for(let e=0;e<a;e++)s[e]=Math.max(s[e],pi(u[t+e],0,n).length)}return s}(e,t,n,i),s=t.length,o=mi(e,t,n,i,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${s}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map((e=>"    "+e)).join("\n")),u.join("\n")}function pi(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(di))} + ${parseFloat(e[1].toFixed(di))}j`:H(e)?`'${e}'`:"bool"===n?fi(e):parseFloat(e.toFixed(di)).toString(),_(r,t)}function fi(e){return 0===e?"false":"true"}function mi(e,t,n,r,i,a=!0){const s="complex64"===n?2:1,o=t[0],u=t.length;if(0===u)return"complex64"===n?[pi(gi(e)[0],0,n)]:"bool"===n?[fi(e[0])]:[e[0].toString()];if(1===u){if(o>li){const t=ci*s;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-ci)*s,o*s));return"complex64"===n&&(r=gi(r),a=gi(a)),["["+r.map(((e,t)=>pi(e,i[t],n))).join(", ")+", ..., "+a.map(((e,t)=>pi(e,i[o-ci+t],n))).join(", ")+"]"]}return["["+("complex64"===n?gi(e):Array.from(e)).map(((e,t)=>pi(e,i[t],n))).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),d=r[0]*s,h=[];if(o>li){for(let t=0;t<ci;t++){const r=t*d,a=r+d;h.push(...mi(e.slice(r,a),l,n,c,i,!1))}h.push("...");for(let t=o-ci;t<o;t++){const r=t*d,a=r+d;h.push(...mi(e.slice(r,a),l,n,c,i,t===o-1))}}else for(let t=0;t<o;t++){const r=t*d,a=r+d;h.push(...mi(e.slice(r,a),l,n,c,i,t===o-1))}const p=2===u?",":"";h[0]="["+(o>0?h[0]+p:"");for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+p;let f=",\n";for(let e=2;e<u;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function gi(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class xi{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=S(e),null!=n){const e=n.length;k(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||L(t,this.size),this.strides=Q(e)}set(e,...t){0===t.length&&(t=[0]),k(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return bi().makeTensor(this.values,this.shape,this.dtype)}}let bi=null,yi=null,wi=null;class vi{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=S(e),this.strides=Q(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return yi.buffer(this.shape,this.dtype,e)}bufferSync(){return yi.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return J(this.shape,e,"complex64"===this.dtype)}arraySync(){return J(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=bi().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>ri(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),bi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=bi().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>ri(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await bi().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(bi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return yi.print(this,e)}clone(){return this.throwIfDisposed(),yi.clone(this)}toString(e=!1){return hi(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),yi.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),bi().makeVariable(this,e,t,n)}}Object.defineProperty(vi,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),me("Tensor",(()=>vi));class ki extends vi{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!T(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);bi().disposeTensor(this),this.dataId=e.dataId,bi().incRef(this,null)}dispose(){bi().disposeVariable(this),this.isDisposedInternal=!0}}var Ci,Ii,Si,$i,Ri;Object.defineProperty(ki,Symbol.hasInstance,{value:e=>e instanceof vi&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Ci||(Ci={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ii||(Ii={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Si||(Si={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}($i||($i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ri||(Ri={}));const Ti={float32:$i,int32:Ii,bool:Si,complex64:Ri};function Ai(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Ti[e][t]}function Ei(e){return Ai(e,"int32")}function Ni(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Di(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function _i(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ai(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Fi(e){const t=[];return Pi(e,t,new Set),t}function Pi(e,t,n){if(null==e)return;if(e instanceof vi)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const i=e;for(const e in i){const r=i[e];n.has(r)||(n.add(r),Pi(r,t,n))}}function Oi(e){return null!=e.kernelName}class Ui{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Bi{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ui}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Tr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new si(this.backendInstance),!0}setupRegisteredKernels(){Fr(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Fr(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof h||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Tr(`Initialization of backend ${e} failed`),Tr(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return Tr(`Initialization of backend ${e} failed`),Tr(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,i,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return Bi.nextTensorId++}nextVariableId(){return Bi.nextVariableId++}clone(e){const t=zi.runKernel(Nt,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return zi.runKernel(Le,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==Dr(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let i=0;n.forEach((e=>{i+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=r-t-i-a;if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let s,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Oi(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Oi(e)){const{kernelName:t,inputs:i,attrs:a}=e;null==this.backendName&&this.backend;const u=Dr(t,this.backendName);k(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),s=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:i,attrs:a,backend:this.backend});const s=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const l=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,i,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,i=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,i)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,d=Oi(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(u,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=s()})),r&&this.addTapeNode(u,l,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=_r(e);if(null!=r){const e=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(k(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const s=n.filter(((e,t)=>i[t]));return a.concat(s)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=e;"string"===n&&H(e[0])&&(i=e.map((e=>ni(e))));const a=r.write(i,t,n),s=new vi(t,n,a,this.nextTensorId());if(this.trackTensor(s,r),"string"===n){const e=this.state.tensorInfo.get(a),t=G(i);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,r){const i={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:i}=e,a=new vi(r,i,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const i=new ki(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*V(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ki||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*V(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,i,a){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:i},o=_r(e);null!=o&&(r=o.gradFunc),null!=r&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=ne(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],i,a))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Fi(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(k(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));k(i instanceof vi,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},i={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],s=a.inputs;for(const e in s){const n=s[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,i[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const s={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,s[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(i[n.id]&&s[n.id]){const e={};for(const t in n.inputs){const i=n.inputs[t];r[i.id]&&(e[t]=i)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,i);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[i.id]=null==n?function(e){const t=te(S(e),"float32");return zi.makeTensor(t,e,"float32")}(i.shape):n,function(e,t,n,r){for(let i=t.length-1;i>=0;i--){const a=t[i],s=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(s);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const i=n((()=>o[t]()));if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${i.dtype}'`);const s=a.inputs[t];if(!T(i.shape,s.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${i.shape}', which does not match the shape of the input '${s.shape}'`);if(null==e[s.id])e[s.id]=i;else{const t=e[s.id];e[s.id]=r(t,i),t.dispose()}}}}(e,a,(e=>this.tidy(e)),Mi);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(e){return k(q(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;k(t.every((e=>e instanceof vi)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,i)=>(n=e(...t,i),k(n.value instanceof vi,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),k(q(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const i=n.gradFunc(e,r),a=Array.isArray(i)?i:[i];k(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),k(a.every((e=>e instanceof vi)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return a.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ei(),n=await this.backend.time(e);return n.wallMs=ei()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ui;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Li(){const e=fe();if(null==e._tfengine){const t=new le(e);e._tfengine=new Bi(t)}var t;return t=e._tfengine.ENV,pe=t,bi=()=>e._tfengine,e._tfengine}Bi.nextTensorId=0,Bi.nextVariableId=0;const zi=Li();function Mi(e,t){const n={a:e,b:t};return zi.runKernel(ye,n)}let Wi;function Vi(e){Wi=e}function Gi(e){if(void 0!==Wi)return Wi;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Hi(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ji=de();ji.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ji.registerFlag("IS_BROWSER",(()=>Hi())),ji.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),ji.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ji.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),ji.registerFlag("PROD",(()=>!1)),ji.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ji.getBool("DEBUG"))),ji.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ji.registerFlag("IS_TEST",(()=>!1)),ji.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>ji.getBool("DEBUG"))),ji.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),ji.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),ji.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));class Xi{static join(e){return new Xi(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>ii(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),i=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],s=e+a-n.start,o=a,u=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,s,u-s);if(i.set(l,o),a+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const i=Math.floor((r-n)/2)+n,a=t(e[i]);if(0===a)return i;a<0?r=i:n=i+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}const Ki="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function qi(e){return Ki?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Yi(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function Qi(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:qi(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:qi(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Xi(e.weightData).byteLength}}class Zi{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Zi.instance&&(Zi.instance=new Zi),Zi.instance}static registerSaveRouter(e){Zi.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Zi.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Zi.getHandlers(e,"save")}static getLoadHandlers(e,t){return Zi.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Zi.getInstance().loadRouters:Zi.getInstance().saveRouters).forEach((t=>{const i=t(e,n);null!==i&&r.push(i)})),r}}const Ji="tensorflowjs",ea="models_store",ta="model_info_store";function na(){if(!de().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ra(e){const t=e.result;t.createObjectStore(ea,{keyPath:"modelPath"}),t.createObjectStore(ta,{keyPath:"modelPath"})}class ia{constructor(e){if(this.indexedDB=na(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Ji,1);r.onupgradeneeded=()=>ra(r),r.onsuccess=()=>{const i=r.result;if(null==t){const t=i.transaction(ea,"readonly"),r=t.objectStore(ea).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return i.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(i.close(),n(r.error)),t.oncomplete=()=>i.close()}else{t.weightData=Xi.join(t.weightData);const r=Qi(t),a=i.transaction(ta,"readwrite");let s,o,u=a.objectStore(ta);try{s=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}s.onsuccess=()=>{o=i.transaction(ea,"readwrite");const s=o.objectStore(ea);let l;try{l=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}l.onsuccess=()=>e({modelArtifactsInfo:r}),l.onerror=e=>{u=a.objectStore(ta);const t=u.delete(this.modelPath);t.onsuccess=()=>(i.close(),n(l.error)),t.onerror=e=>(i.close(),n(l.error))}},s.onerror=e=>(i.close(),n(s.error)),a.oncomplete=()=>{null==o?i.close():o.oncomplete=()=>i.close()}}},r.onerror=e=>n(r.error)}))}}ia.URL_SCHEME="indexeddb://";const aa=e=>{return de().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ia.URL_SCHEME)?(t=e.slice(ia.URL_SCHEME.length),new ia(t)):null;var t};Zi.registerSaveRouter(aa),Zi.registerLoadRouter(aa);class sa{constructor(){this.indexedDB=na()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Ji,1);n.onupgradeneeded=()=>ra(n),n.onsuccess=()=>{const r=n.result,i=r.transaction(ta,"readonly"),a=i.objectStore(ta).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ia.URL_SCHEME)?t.slice(ia.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Ji,1);r.onupgradeneeded=()=>ra(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(ta,"readwrite"),s=a.objectStore(ta),o=s.get(e);let u;o.onsuccess=()=>{if(null==o.result)return i.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=s.delete(e),a=()=>{u=i.transaction(ea,"readwrite");const r=u.objectStore(ea).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),i.close(),n(o.error))}},o.onerror=e=>(i.close(),n(o.error)),a.oncomplete=()=>{null==u?i.close():u.oncomplete=()=>i.close()}},r.onerror=e=>n(r.error)}))}}const oa="/",ua="tensorflowjs_models",la="info",ca="model_topology",da="weight_specs",ha="weight_data",pa="model_metadata";function fa(e){return{info:[ua,e,la].join(oa),topology:[ua,e,ca].join(oa),weightSpecs:[ua,e,da].join(oa),weightData:[ua,e,ha].join(oa),modelMetadata:[ua,e,pa].join(oa)}}function ma(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ga(e){const t=e.split(oa);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(oa)}class xa{constructor(e){if(!de().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=fa(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Qi(e),i=Xi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(Ki)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw ma(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(null!=i){const e=JSON.parse(i);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(Ki){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}xa.URL_SCHEME="localstorage://";const ba=e=>{return de().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(xa.URL_SCHEME)?(t=e.slice(xa.URL_SCHEME.length),new xa(t)):null;var t};Zi.registerSaveRouter(ba),Zi.registerLoadRouter(ba);class ya{constructor(){k(de().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),k("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=ua+oa,n=oa+la;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);i.startsWith(t)&&i.endsWith(n)&&(e[ga(i)]=JSON.parse(this.LS.getItem(i)))}return e}async removeModel(e){var t;const n=fa(e=(t=e).startsWith(xa.URL_SCHEME)?t.slice(xa.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return ma(n),r}}class wa{constructor(){this.managers={}}static getInstance(){return null==wa.instance&&(wa.instance=new wa),wa.instance}static registerManager(e,t){k(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),k(e.length>0,(()=>"scheme must not be an empty string."));const n=wa.getInstance();k(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=wa.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(wa.getInstance().managers)}}class va{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&de().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return Ur(e)}}if(de().get("IS_BROWSER")){de().setPlatform("browser",new va);try{wa.registerManager(xa.URL_SCHEME,new ya)}catch(e){}try{wa.registerManager(ia.URL_SCHEME,new sa)}catch(e){}}let ka;function Ca(e,t="float32",n){return t=t||"float32",ie(e),new xi(e,t,n)}function Ia(e,t){let n=e;if(ii(e))return"string"===t?[]:[e.length];if(Ni(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Di(e))return[e.buffer.size/(null==t?4:V(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||ii(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&de().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Sa(e,r,[]),r}function Sa(e,t,n){if(n=n||[],!Array.isArray(e)&&!ii(e))return void k(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));k(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),k(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)Sa(e[t],r,n.concat(t))}function $a(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Ra(e,t,n,r="numeric"){if(e instanceof vi)return $a(r,e.dtype,t,n),e;let i=K(e);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),$a(r,i,t,n),null==e||!ii(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Ia(e,i);ii(e)||Array.isArray(e)||(e=[e]);const s="string"!==i?Jr(e,i):ai(e,[],!0);return zi.makeTensor(s,a,i)}function Ta(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const i=(...e)=>{zi.startScope(n);try{const t=r(...e);return oe(t)&&console.error("Cannot return a Promise inside of tidy."),zi.endScope(t),t}catch(e){throw zi.endScope(null),e}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}de().get("IS_NODE")&&!de().get("IS_BROWSER")&&de().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=de().global.fetch?de().global.fetch(e,t):(null==ka&&(ka=n(410)),ka(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});const Aa=Ta({cast_:function(e,t){const n=Ra(e,"x","cast");if(!M(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},i={dtype:t};return zi.runKernel(Le,r,i)}}),Ea=Ta({clone_:function(e){const t={x:Ra(e,"x","clone","string_or_numeric")};return zi.runKernel(Nt,t)}});function Na(){return zi}function Da(e,t){return zi.tidy(e,t)}function _a(e){Fi(e).forEach((e=>e.dispose()))}function Fa(){return zi.backendName}function Pa(e,t,n=1){return zi.registerBackend(e,t,n)}function Oa(){return zi.backend}Li(),yi={buffer:Ca,cast:Aa,clone:Ea,print:function(e,t=!1){console.log(e.toString(t))}},wi=function(e){de().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const Ua=Ta({add_:function(e,t){let n=Ra(e,"a","add"),r=Ra(t,"b","add");[n,r]=_i(n,r);const i={a:n,b:r};return zi.runKernel(ye,i)}}),Ba=Ta({floorDiv_:function(e,t){let n=Ra(e,"a","floorDiv"),r=Ra(t,"b","floorDiv");[n,r]=_i(n,r);const i={a:n,b:r};return zi.runKernel(St,i)}}),La=Ta({div_:function(e,t){let n=Ra(e,"a","div"),r=Ra(t,"b","div");if([n,r]=_i(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Ba(n,r);const i={a:n,b:r};return zi.runKernel(ht,i,{})}}),za=Ta({mul_:function(e,t){let n=Ra(e,"a","mul"),r=Ra(t,"b","mul");[n,r]=_i(n,r);const i={a:n,b:r};return zi.runKernel(un,i)}}),Ma=Ta({sqrt_:function(e){const t={x:Ra(e,"x","sqrt","float32")};return zi.runKernel(Kn,t)}}),Wa=Ta({square_:function(e){const t=Ra(e,"x","square");return zi.runKernel("Square",{x:t},{})}}),Va=Ta({zerosLike_:function(e){const t={x:Ra(e,"x","zerosLike")};return zi.runKernel(vr,t)}});function Ga(e,t,n,r){if(null==r)r=K(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Di(e)||Ni(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return zi.backend.createTensorFromGPUData(e,t||n,r)}if(!ii(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ie(t);const e=S(t),r=S(n);k(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],i=e!==n.length-1||r!==S(t.slice(e));k(n[e]===t[e]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return ii(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Jr(e,r):ai(e,[],!0),zi.makeTensor(e,t,r)}function Ha(e,t){if((ii(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&ii(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ga(e,[],[],t)}const ja=new Map,Xa=new Map;class Ka{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class qa{constructor(){this.classNameMap={}}static getMap(){return null==qa.instance&&(qa.instance=new qa),qa.instance}static register(e){qa.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ya(e,t,n){k(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),k("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),k(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return qa.register(e),ja.set(r,e),Xa.set(e,r),e}class Qa extends Ka{minimize(e,t=!1,n){const{value:r,grads:i}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:i[e.name]})));this.applyGradients(e)}else this.applyGradients(i);return _a(i),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){k(q(e),(()=>"The f passed in variableGrads(f) must be a function")),k(null==t||Array.isArray(t)&&t.every((e=>e instanceof ki)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in zi.registeredVariables)t.push(zi.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,i=t.length;k((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`));const{value:a,grads:s}=zi.gradients(e,t,null,!0);k(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),k(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=s[t]&&(o[e.name]=s[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&_a(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Ha(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}function Za(e,t,n){ie(e);const r={shape:e,value:t,dtype:n=n||K(t)};return zi.runKernel(kt,{},r)}Object.defineProperty(Qa,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const Ja=Ta({pow_:function(e,t){let n=Ra(e,"base","pow"),r=Ra(t,"exp","pow");[n,r]=_i(n,r);const i={a:n,b:r};return zi.runKernel(bn,i)}}),es=Ta({sub_:function(e,t){let n=Ra(e,"a","sub"),r=Ra(t,"b","sub");[n,r]=_i(n,r);const i={a:n,b:r};return zi.runKernel(dr,i)}}),ts=Ta({abs_:function(e){const t=Ra(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return zi.runKernel(Ve,e)}{const e={x:t};return zi.runKernel(ge,e)}}});function ns(e,t){const n=e.length,r=[];for(let i=0;i<n;i++){const a=n-1-i,s=e[a]||1;(t[t.length-1-i]||1)>1&&1===s&&r.unshift(a)}return r}function rs(e,t){const n=[];for(let r=0;r<t.length;r++){const i=e[e.length-r-1],a=t.length-r-1,s=t[a];(null==i||1===i&&s>1)&&n.unshift(a)}return n}function is(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let i=0;i<n;i++){let a=e[e.length-i-1];null==a&&(a=1);let s=t[t.length-i-1];if(null==s&&(s=1),1===a)r[n-i-1]=s;else if(1===s)r[n-i-1]=a;else{if(a!==s)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-i-1]=a}}return r}const as=Ta({maximum_:function(e,t){let n=Ra(e,"a","maximum"),r=Ra(t,"b","maximum");[n,r]=_i(n,r),"bool"===n.dtype&&(n=Aa(n,"int32"),r=Aa(r,"int32")),is(n.shape,r.shape);const i={a:n,b:r};return zi.runKernel(qt,i)}});class ss extends Qa{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=zi.registeredVariables[t];Da((()=>{const e=Ua(za(this.c,r),i);i.assign(e)}))})),this.incrementIterations()}setLearningRate(e){var t;this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(t=Ha(-e),zi.keep(t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}const os=[class extends Qa{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=zi.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=zi.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Da((()=>Va(r).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Da((()=>Va(r).variable(!1)))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const a=this.accumulatedGrads[n].variable,s=this.accumulatedUpdates[n].variable;Da((()=>{const e=Ua(za(a,this.rho),za(Wa(i),1-this.rho)),t=za(La(Ma(Ua(s,this.epsilon)),Ma(Ua(a,this.epsilon))),i),n=Ua(za(s,this.rho),za(Wa(t),1-this.rho));a.assign(e),s.assign(n);const o=Ua(za(t,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(_a(this.accumulatedGrads.map((e=>e.variable))),_a(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},class extends Qa{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=zi.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Da((()=>Za(r.shape,this.initialAccumulatorValue).variable(e)))}}const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const a=this.accumulatedGrads[n].variable;Da((()=>{const e=Ua(a,Wa(i));a.assign(e);const t=Ua(za(La(i,Ma(Ua(e,zi.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&_a(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},class extends Qa{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Da((()=>{this.accBeta1=Ha(t).variable(),this.accBeta2=Ha(n).variable()})),null==r&&(this.epsilon=zi.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Da((()=>{const n=es(1,this.accBeta1),r=es(1,this.accBeta2);t.forEach(((t,i)=>{const a=zi.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:Da((()=>Va(a).variable(!1)))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:Da((()=>Va(a).variable(!1)))});const s=Array.isArray(e)?e[i].tensor:e[t];if(null==s)return;const o=this.accumulatedFirstMoment[i].variable,u=this.accumulatedSecondMoment[i].variable,l=Ua(za(o,this.beta1),za(s,1-this.beta1)),c=Ua(za(u,this.beta2),za(Wa(s),1-this.beta2)),d=La(l,n),h=La(c,r);o.assign(l),u.assign(c);const p=Ua(za(La(d,Ua(Ma(h),this.epsilon)),-this.learningRate),a);a.assign(p)})),this.accBeta1.assign(za(this.accBeta1,this.beta1)),this.accBeta2.assign(za(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&_a(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&_a(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Da((()=>{this.accBeta1.assign(Ja(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ja(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},class extends Qa{static get className(){return"Adamax"}constructor(e,t,n,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Da((()=>{this.iteration=Ha(0).variable(),this.accBeta1=Ha(t).variable()})),null==r&&(this.epsilon=zi.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Da((()=>{const n=es(1,this.accBeta1),r=La(-this.learningRate,Ua(za(this.iteration,this.decay),1));t.forEach(((t,i)=>{const a=zi.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:Va(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:Va(a).variable(!1)});const s=Array.isArray(e)?e[i].tensor:e[t];if(null==s)return;const o=this.accumulatedFirstMoment[i].variable,u=this.accumulatedWeightedInfNorm[i].variable,l=Ua(za(o,this.beta1),za(s,1-this.beta1)),c=za(u,this.beta2),d=ts(s),h=as(c,d);o.assign(l),u.assign(h);const p=Ua(za(La(r,n),La(l,Ua(h,this.epsilon))),a);a.assign(p)})),this.iteration.assign(Ua(this.iteration,1)),this.accBeta1.assign(za(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&_a(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&_a(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},class extends ss{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Ha(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=zi.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Da((()=>Va(r).variable(e)))}}const i=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Da((()=>{let e;const t=Ua(za(this.m,i),a);e=this.useNesterov?Ua(za(this.c,Ua(a,za(t,this.m))),r):Ua(za(this.c,t),r),i.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&_a(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},class extends Qa{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=zi.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=zi.registeredVariables[t],i=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Da((()=>Va(r).variable(i)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Da((()=>Va(r).variable(i)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Da((()=>Va(r).variable(i)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Da((()=>{const e=Ua(za(s,this.decay),za(Wa(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,i=Ua(za(t,this.decay),za(a,1-this.decay)),u=La(za(a,this.learningRate),Ma(es(e,Ua(Wa(i),this.epsilon)))),l=Ua(za(o,this.momentum),u);s.assign(e),t.assign(i),o.assign(l);const c=es(r,l);r.assign(c)}else{const e=Ua(za(s,this.decay),za(Wa(a),1-this.decay)),t=Ua(za(o,this.momentum),La(za(a,this.learningRate),Ma(Ua(e,this.epsilon))));s.assign(e),o.assign(t);const n=es(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&_a(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&_a(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&_a(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},ss];function us(e){return new Promise((e=>setTimeout(e))).then(e)}class ls{constructor(e){if(!de().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ls.URL_SCHEME)&&(e=e.slice(ls.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Xi.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=Yi(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),i=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=r,await us((()=>i.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await us((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Qi(e)}}}}function cs(e,t,n,r){!function(e){k(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){k(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),k(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),k(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let i=0;return Promise.all(e.map((a=>(a.then((a=>{const s=n+ ++i/e.length*(r-n);return t(s),a})),a))))}async function ds(e,t){null==t&&(t={});const n=null==t.fetchFunc?de().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),i=(null==t.onProgress?await Promise.all(r):await cs(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(i):await cs(i,t.onProgress,.5,1)}ls.URL_SCHEME="downloads://",Zi.registerSaveRouter((e=>de().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ls.URL_SCHEME)?function(e="model"){return new ls(e)}(e.slice(ls.URL_SCHEME.length)):null));class hs{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(k("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=de().platform.fetch,k(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&k(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=Yi(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Xi.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Qi(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),i=this.weightPathPrefix||n,a=function(e){const t=[];for(const n of e)t.push(...n.weights);return t}(e),s=[],o=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):s.push(i+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(o)),[a,await ds(s,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})]}}function ps(e){return null!=e.match(hs.URL_SCHEME_REGEX)}hs.URL_SCHEME_REGEX=/^https?:\/\//;const fs=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>ps(e))):ps(e),n)return function(e,t){return new hs(e,t)}(e,t)}return null};Zi.registerSaveRouter(fs),Zi.registerLoadRouter(fs);let ms,gs=!1;function xs(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,i=!1,a=!1,s=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)i=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)s=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Dr(Cr,zi.backendName)){const n={pixels:e},r={numChannels:t};return zi.runKernel(Cr,n,r)}const[u,l]=i?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(s)c=e.getContext("2d").getImageData(0,0,u,l).data;else if(r||n)c=e.data;else if(a||i||o){if(null==ms)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ms=new OffscreenCanvas(1,1).getContext("2d")}else ms=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ms.canvas.width=u,ms.canvas.height=l,ms.drawImage(e,0,0,u,l),c=ms.getImageData(0,0,u,l).data}if(4===t)d=new Int32Array(c);else{const e=u*l;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return function(e,t,n){if(I(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ia(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ga(e,t,r,n)}(d,[l,u,t],"int32")}async function bs(e,t=3){let n=null;if(de().getBool("WRAP_TO_IMAGEBITMAP")&&function(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return xs(n,t)}function ys(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function ws(e,t){let n=Ra(e,"img","toPixels");if(!(e instanceof vi)){const e=n;n=Aa(e,"int32"),e.dispose()}ys(n);const[r,i]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],s=await n.data(),o="float32"===n.dtype?255:1,u=new Uint8ClampedArray(i*r*4);for(let e=0;e<r*i;++e){const t=[0,0,0,255];for(let r=0;r<a;r++){const i=s[e*a+r];if("float32"===n.dtype){if(i<0||i>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${i}.`)}else if("int32"===n.dtype&&(i<0||i>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${i}.`);1===a?(t[0]=i*o,t[1]=i*o,t[2]=i*o):t[r]=i*o}const r=4*e;u[r+0]=Math.round(t[0]),u[r+1]=Math.round(t[1]),u[r+2]=Math.round(t[2]),u[r+3]=Math.round(t[3])}if(null!=t){gs||null!=Dr(dt,zi.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),gs=!0),t.width=i,t.height=r;const e=t.getContext("2d"),n=new ImageData(u,i,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),u}function vs(e,t,n){let r=Ra(e,"img","draw");if(!(e instanceof vi)){const e=r;r=Aa(e,"int32"),e.dispose()}ys(r),function(e){const t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);const i={image:r},a={canvas:t,options:n};zi.runKernel(dt,i,a)}const ks=Ta({fromPixels_:xs}),Cs=-2,Is=-1;function Ss(e,t,n){const r=e.shape.length;k(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),k(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let i=0;i<r;++i)k(t[i]+n[i]<=e.shape[i],(()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${e.shape[i]})`))}function $s(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Rs(e,t,n){const r=[];for(let i=0;i<e.length;i++)r[i]=Math.ceil((t[i]-e[i])/n[i]);return r}function Ts(e,t,n,r){const i=[...e];for(let e=i.length;e<r.length;e++)i.push(1);for(let e=0;e<n;e++)0===e?i[t]=1:(i.splice(t,0,1),i.pop());return i}function As(e,t,n){return n<=e?n:n-(t-1)}function Es(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Ns(e,t,n,r,i,a,s,o,u){const l=e.length;let c=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=Ds(s,u,l,r,e),d=_s(o,u,l,i,e),h=Ts(a,u,l,e)}else for(let t=0;t<l;t++)c[t]=Ps(s,r,a,e,t,u),d[t]=Os(o,i,a,e,t,u),h[t]=Fs(a,t,u);return{begin:c,end:d,strides:h}}function Ds(e,t,n,r,i){const a=[...i],s=Es(n,t);for(let i=0;i<a.length;i++)if(s.indexOf(i)>-1)a[i]=0;else{const s=As(t,n,i);let o=r[s];e&1<<s&&(o=0),a[i]=o}return a}function _s(e,t,n,r,i){const a=[...i],s=Es(n,t);for(let i=0;i<a.length;i++)if(s.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const s=As(t,n,i);let o=r[s];e&1<<s&&(o=Number.MAX_SAFE_INTEGER),a[i]=o}for(let e=0;e<a.length;e++){const t=i[e];a[e]<0&&(a[e]+=t),a[e]=g(0,a[e],i[e])}return a}function Fs(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Ps(e,t,n,r,i,a){let s=t[i];const o=n[i]||1;(e&1<<i||a&1<<i||null==s)&&(s=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[i];return s<0&&(s+=u),s=g(0,s,u-1),s}function Os(e,t,n,r,i,a){let s=t[i];const o=n[i]||1;(e&1<<i||a&1<<i||null==s)&&(s=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[i];return s<0&&(s+=u),s=o>0?g(0,s,u):g(-1,s,u-1),s}function Us(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function Bs(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Ls(e,t,n){let r;const i=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),r.forEach((e=>{k(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(k(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function zs(e,t,n,r,i,a,s,o,u){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=s&&0!=(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:i,endMask:a,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:u};for(let e=0;e<d.dims;e++)c&&0!=(1<<e&o)&&d.numAddAxisAfterEllipsis++,1<<e&s&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const i=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Cs),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Is),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],x=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(h.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const i=[h.beginMask&1<<t,h.endMask&1<<t],a=[h.strides[t]>0?0:-1,h.strides[t]>0?r:r-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[t];const s=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){const e=h.begin[t]<0?r+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=r)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=Ms(h.begin[t],0,h.strides[t],r,i,a),h.end[t]=Ms(h.end[t],1,h.strides[t],r,i,a);const e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===r;p=p&&e,f=f&&(0===t&&1===h.strides[t]||e)}else p=p&&1===h.strides[t]&&s,f=f&&(0===t&&1===h.strides[t]||s);let o,u=!1;if(h.beginValid&&h.endValid?(o=h.end[t]-h.begin[t],u=!0):n?(o=1,u=!0):s&&r>=0&&(o=h.strides[t]<0?-r:r,u=!0),u){let e;e=0===o||o<0!=h.strides[t]<0?0:Math.trunc(o/h.strides[t])+(o%h.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){const t=h.finalShapeGatherIndices[e];t>=0?x.push(g[t]):t===Cs&&x.push(1)}return{finalShapeSparse:x.filter(((e,t)=>h.finalShapeGatherIndices[t]!==Cs)),finalShape:x,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Ms(e,t,n,r,i,a){if(i[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const Ws=Ta({argMax_:function(e,t=0){const n={x:Ra(e,"x","argMax")},r={axis:t};return zi.runKernel(Ce,n,r)}}),Vs=Ta({reshape_:function(e,t){const n={x:Ra(e,"x","reshape","string_or_numeric")},r={shape:t};return zi.runKernel(Tn,n,r)}}),Gs=Ta({broadcastTo_:function(e,t){let n=Ra(e,"broadcastTo","x");const r=n.shape;if(ie(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Vs(n,e)}const i=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(i[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Ea(n);const s={x:n},o={reps:a};return zi.runKernel(fr,s,o)}}),Hs=Ta({clipByValue_:function(e,t,n){const r=Ra(e,"x","clipByValue");if(k(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Za(r.shape,t,r.dtype);const i={x:r},a={clipValueMin:t,clipValueMax:n};return zi.runKernel(Me,i,a)}}),js=Ta({concat_:function(e,t=0){k(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=function(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,i)=>Ra(e,`${t}[${i}]`,n,r)))}(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Ea(n[0]);const r=n,i={axis:t};return zi.runKernel(Ge,r,i)}}),Xs=Ta({exp_:function(e){const t={x:Ra(e,"x","exp")};return zi.runKernel(bt,t)}}),Ks=Ta({expandDims_:function(e,t=0){const n=Ra(e,"x","expandDims","string_or_numeric");k(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},i={dim:t};return zi.runKernel(yt,r,i)}}),qs=Ta({minimum_:function(e,t){let n=Ra(e,"a","minimum"),r=Ra(t,"b","minimum");[n,r]=_i(n,r),"bool"===n.dtype&&(n=Aa(n,"int32"),r=Aa(r,"int32")),is(n.shape,r.shape);const i={a:n,b:r};return zi.runKernel(rn,i)}}),Ys=Ta({mirrorPad_:function(e,t,n){k("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Ra(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const i="reflect"===n?1:0;for(let e=0;e<r.rank;e++)k(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),k(t[e][0]>=0&&t[e][0]<=r.shape[e]-i&&t[e][1]>=0&&t[e][1]<=r.shape[e]-i,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-i} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},s={x:r};return zi.runKernel(an,s,a)}}),Qs=Ta({pad_:function(e,t,n=0){const r=Ra(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:n},a={x:r};return zi.runKernel(xn,a,i)}}),Zs=Ta({sigmoid_:function(e){const t={x:Ra(e,"x","sigmoid","float32")};return zi.runKernel(jn,t)}}),Js=Ta({slice_:function(e,t,n){const r=Ra(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const i={x:r},a={begin:t,size:n};return zi.runKernel(Wn,i,a)}}),eo=Ta({squeeze_:function(e,t){const n=Ra(e,"x","squeeze","string_or_numeric");return Vs(n,U(n.shape,t).newShape)}});function to(e,t){I(e);const n=Ia(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ga(e,null,n,t)}function no(e,t,n){if(I(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ia(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ga(e,t,r,n)}const ro=Ta({complex_:function(e,t){const n=Ra(e,"real","complex"),r=Ra(t,"imag","complex");C(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:n,imag:r};return zi.runKernel(We,i)}});function io(e,t="float32"){if(ie(e),"complex64"===t){const t=io(e,"float32"),n=io(e,"float32");return ro(t,n)}const n=ne(S(e),t);return zi.makeTensor(n,e,t)}const ao=Ta({split_:function(e,t,n=0){const r={x:Ra(e,"x","split")},i={numOrSizeSplits:t,axis:n};return zi.runKernel(Qn,r,i)}}),so=Ta({cropAndResize_:function(e,t,n,r,i="bilinear",a=0){const s=Ra(e,"image","cropAndResize"),o=Ra(t,"boxes","cropAndResize","float32"),u=Ra(n,"boxInd","cropAndResize","int32"),l=o.shape[0];k(4===s.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`)),k(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`)),k(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`)),k(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),k(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),k("bilinear"===i||"nearest"===i,(()=>`method must be bilinear or nearest, but was ${i}`));const c={image:s,boxes:o,boxInd:u},d={method:i,extrapolationValue:a,cropSize:r};return zi.runKernel(tt,c,d)}}),oo=Ta({flipLeftRight_:function(e){const t=Ra(e,"image","flipLeftRight","float32");k(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return zi.runKernel(Ct,n,{})}}),uo=Ta({tile_:function(e,t){const n=Ra(e,"x","tile","string_or_numeric");k(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},i={reps:t};return zi.runKernel(fr,r,i)}}),lo=Ta({grayscaleToRGB_:function(e){const t=Ra(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];k(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),k(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const i=new Array(t.rank);return i.fill(1,0,n),i[n]=3,uo(t,i)}}),co=Ta({rotateWithOffset_:function(e,t,n=0,r=.5){const i=Ra(e,"image","rotateWithOffset","float32");k(4===i.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`));const a={image:i},s={radians:t,fillValue:n,center:r};return zi.runKernel(Ir,a,s)}});function ho(e,t,n,r,i,a){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==a&&(a=0);const s=e.shape[0];return n=Math.min(n,s),k(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),k(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),k(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),k(1===t.rank,(()=>"scores must be a 1D tensor")),k(t.shape[0]===s,(()=>`scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`)),k(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:a}}const po=Ta({nonMaxSuppression_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){const a=Ra(e,"boxes","nonMaxSuppression","float32"),s=Ra(t,"scores","nonMaxSuppression","float32"),o=ho(a,s,n,r,i),u={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:i=o.scoreThreshold};return zi.runKernel(dn,{boxes:a,scores:s},u)}});function fo(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,i=e.length,a=0,s=!1;for(;r<i;){a=r+(i-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(i=a,s=!o)}return s?r:-r-1}(e,t,n||mo)}(e,t,n),i=r<0?-(r+1):r;e.splice(i,0,t)}function mo(e,t){return e>t?1:e<t?-1:0}function go(e,t,n,r,i){return yo(e,t,n,r,i,0)}function xo(e,t,n,r,i,a){return yo(e,t,n,r,i,0,!1,a,!0)}function bo(e,t,n,r,i,a){return yo(e,t,n,r,i,a,!0)}function yo(e,t,n,r,i,a,s=!1,o=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>i&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(ko);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:s}=t;if(n<i)break;let o=!1;for(let n=d.length-1;n>=s;--n){const s=wo(e,a,d[n]);if(s>=r){o=!0;break}if(t.score=t.score*vo(r,c,s),t.score<=i)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(a),h.push(t.score)):t.score>i&&fo(l,t,ko))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return s&&(m.selectedScores=h),u&&(m.validOutputs=p),m}function wo(e,t,n){const r=e.subarray(4*t,4*t+4),i=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),s=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),h=Math.max(i[1],i[3]),p=(o-a)*(u-s),f=(d-l)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(s,c),x=Math.min(o,d),b=Math.min(u,h),y=Math.max(x-m,0)*Math.max(b-g,0);return y/(p+f-y)}function vo(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function ko(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Co=Ta({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,a=0){const s=Ra(e,"boxes","nonMaxSuppression"),o=Ra(t,"scores","nonMaxSuppression"),u=ho(s,o,n,r,i,a),l={boxes:s,scores:o},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:i=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma},d=zi.runKernel(pn,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),Io=Ta({nonMaxSuppressionPadded_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,a=!1){const s=Ra(e,"boxes","nonMaxSuppression"),o=Ra(t,"scores","nonMaxSuppression"),u=ho(s,o,n,r,i,null),l={boxes:s,scores:o},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a},d=zi.runKernel(hn,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),So=Ta({resizeBilinear_:function(e,t,n=!1,r=!1){const i=Ra(e,"images","resizeBilinear");k(3===i.rank||4===i.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`)),k(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),k(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=i,s=!1;3===i.rank&&(s=!0,a=Vs(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=zi.runKernel(Nn,o,u);return s?Vs(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),$o=Ta({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const i=Ra(e,"images","resizeNearestNeighbor");k(3===i.rank||4===i.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`)),k(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),k("float32"===i.dtype||"int32"===i.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),k(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=i,s=!1;3===i.rank&&(s=!0,a=Vs(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=zi.runKernel(An,o,u);return s?Vs(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),Ro=Ta({bincount_:function(e,t,n){const r=Ra(e,"x","bincount"),i=Ra(t,"weights","bincount");k("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),k(n>=0,(()=>`size must be non-negative, but got ${n}.`)),k(i.size===r.size||0===i.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`));const a={x:r,weights:i},s={size:n};return zi.runKernel(Oe,a,s)}}),To=Ta({lessEqual_:function(e,t){let n=Ra(e,"a","lessEqual","string_or_numeric"),r=Ra(t,"b","lessEqual","string_or_numeric");[n,r]=_i(n,r),is(n.shape,r.shape);const i={a:n,b:r};return zi.runKernel(Lt,i)}}),Ao=Ta({greater_:function(e,t){let n=Ra(e,"a","greater","string_or_numeric"),r=Ra(t,"b","greater","string_or_numeric");[n,r]=_i(n,r),is(n.shape,r.shape);const i={a:n,b:r};return zi.runKernel(At,i)}}),Eo=Ta({sum_:function(e,t=null,n=!1){let r=Ra(e,"x","sum");"bool"===r.dtype&&(r=Aa(r,"int32"));const i={x:r},a={axis:t,keepDims:n};return zi.runKernel(qn,i,a)}}),No=Ta({round_:function(e){const t={x:Ra(e,"x","round")};return zi.runKernel(Pn,t)}}),Do=Ta({where_:function(e,t,n){const r=Ra(t,"a","where"),i=Ra(n,"b","where"),a=Ra(e,"condition","where","bool"),s=is(is(a.shape,r.shape),i.shape),o={condition:Gs(a,s),t:Gs(r,s),e:Gs(i,s)};return zi.runKernel(zn,o)}});function _o(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const i={start:e,stop:t,step:n,dtype:r};return zi.runKernel(In,{},i)}const Fo=Ta({threshold_:function(e,t="binary",n=!1,r=.5){const i=Ra(e,"image","threshold"),a=i.shape[0]*i.shape[1];let s,o,u,l,c=za(to([r]),255);if(k(3===i.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`)),k(3===i.shape[2]||1===i.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`)),k("int32"===i.dtype||"float32"===i.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`)),k("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===i.shape[2]){[s,o,u]=ao(i,[1,1,1],-1);const e=za(s,.2989),t=za(o,.587),n=za(u,.114);l=Ua(Ua(e,t),n)}else l=e;var d,h;"otsu"===t&&(c=function(e,t){let n,r,i,a,s,o,u=to([-1]),l=to([0]),c=to([0]);for(let d=0;d<e.size-1;d++){n=Js(e,0,d+1),r=Js(e,d+1),s=La(Eo(n),t),o=La(Eo(r),t);const h=Eo(za(n,_o(0,n.size)));i=La(h,Eo(n));const p=Za(r.shape,n.size),f=Ua(_o(0,r.size),p),m=za(r,f);a=La(Eo(m),Eo(r));const g=es(i,a),x=es(i,a),b=za(s,o);c=za(za(b,g),x);const y=Ao(c,l);l=Do(y,c,l),u=Do(y,to([d]),u)}return u}(Ro(Aa(No(l),"int32"),Ga(d=[],undefined,Ia(d,h),h),256),a));const p=n?To(l,c):Ao(l,c);return Aa(za(p,255),"int32")}}),Po=Ta({transform_:function(e,t,n="nearest",r="constant",i=0,a){const s=Ra(e,"image","transform","float32"),o=Ra(t,"transforms","transform","float32");k(4===s.rank,(()=>`Error in transform: image must be rank 4,but got rank ${s.rank}.`)),k(2===o.rank&&(o.shape[0]===s.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),k(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const u={image:s,transforms:o},l={interpolation:n,fillMode:r,fillValue:i,outputShape:a};return zi.runKernel(gr,u,l)}});function Oo(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Uo(e,t,n){const r=e.length+t.length,i=[];let a=0,s=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?i.push(e[a++]):i.push(t[s++]);return i}function Bo(e,t){const n=[],r=e.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&n.push(e[i]);return[n,t.map((t=>e[t]))]}function Lo(e,t){return Uo(e,t.map((e=>1)),t)}function zo(e,t,n){k(Oo(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Mo(e,t){if(Oo(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Wo(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Vo(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var Go;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Go||(Go={}));const Ho=Ta({relu_:function(e){const t={x:Ra(e,"x","relu")};return zi.runKernel(Rn,t)}}),jo={flipLeftRight:oo,grayscaleToRGB:lo,resizeNearestNeighbor:$o,resizeBilinear:So,rotateWithOffset:co,cropAndResize:so,nonMaxSuppression:po,nonMaxSuppressionAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){const a=Ra(e,"boxes","nonMaxSuppressionAsync"),s=Ra(t,"scores","nonMaxSuppressionAsync"),o=ho(a,s,n,r,i);n=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const u=await Promise.all([a.data(),s.data()]),l=u[0],c=u[1],{selectedIndices:d}=go(l,c,n,r,i);return a!==e&&a.dispose(),s!==t&&s.dispose(),to(d,"int32")},nonMaxSuppressionWithScore:Co,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,a=0){const s=Ra(e,"boxes","nonMaxSuppressionAsync"),o=Ra(t,"scores","nonMaxSuppressionAsync"),u=ho(s,o,n,r,i,a);n=u.maxOutputSize,r=u.iouThreshold,i=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([s.data(),o.data()]),c=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=bo(c,d,n,r,i,a);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:to(h,"int32"),selectedScores:to(p)}},nonMaxSuppressionPadded:Io,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,a=!1){const s=Ra(e,"boxes","nonMaxSuppressionAsync"),o=Ra(t,"scores","nonMaxSuppressionAsync"),u=ho(s,o,n,r,i,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[h,p]=await Promise.all([s.data(),o.data()]),{selectedIndices:f,validOutputs:m}=xo(h,p,l,c,d,a);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:to(f,"int32"),validOutputs:Ha(m,"int32")}},threshold:Fo,transform:Po},Xo="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Ko(){return new Promise((e=>Xo((()=>e()))))}function qo(e,t){const n=e[0].length;e.forEach(((e,t)=>{k(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),k(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,i)=>{for(let a=0;a<n;a++)k(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`))}))}function Yo(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function Qo(e,t,n,r,i="NHWC",a){return eu(e,[...t,e[3]],n,a,r,null,null,cu(i))}function Zo(e,t,n,r,i,a,s="channelsLast"){const[o,u]=ru(t);let l;if("channelsLast"===s)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);l=[o,u,e[1],e[1]]}return eu(e,l,n,r,i,a,!1,s)}function Jo(e,t,n,r,i,a,s="NDHWC"){const[o,u,l]=iu(t);let c,d;if("NDHWC"===s)d="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error(`Unknown dataFormat ${s}`);d="channelsFirst",c=[o,u,l,e[1],e[1]]}return tu(e,c,n,r,i,!1,d,a)}function eu(e,t,n,r,i,a,s=!1,o="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,d,l,c]=e}const[h,p,,f]=t,[m,g]=ru(n),[x,b]=ru(r),y=au(h,x),w=au(p,b),{padInfo:v,outHeight:k,outWidth:C}=function(e,t,n,r,i,a,s,o,u){let l,c,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const i=function(e,t,n,r,i){null==r&&(r=nu(e,t,n));const a=e[1];return[su((e[0]-t+2*r)/n+1,i),su((a-t+2*r)/n+1,i)]}([t,n],a,r,e,o);c=i[0],d=i[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/i);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(d-1)*i+s-n),u=Math.floor(e/2),h=e-u,p=Math.floor(o/2);l={top:u,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-s+1)/i);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=su((t-a+h+p)/r+1,o),d=su((n-s+f+m)/i+1,o)}}return{padInfo:l,outHeight:c,outWidth:d}}(i,l,c,m,g,y,w,a,o),I=s?f*d:f;let S;return"channelsFirst"===o?S=[u,I,k,C]:"channelsLast"===o&&(S=[u,k,C,I]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:d,outHeight:k,outWidth:C,outChannels:I,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:w,dilationHeight:x,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function tu(e,t,n,r,i,a=!1,s="channelsLast",o){let[u,l,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[u,l,c,d,h]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[u,h,l,c,d]=e}const[p,f,m,,g]=t,[x,b,y]=iu(n),[w,v,k]=iu(r),C=au(p,w),I=au(f,v),S=au(m,k),{padInfo:$,outDepth:R,outHeight:T,outWidth:A}=function(e,t,n,r,i,a,s,o,u,l,c){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,i,a){null==i&&(i=nu(e,t[0],r[0]));const s=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*i>=t[n]&&(s[n]=su((e[n]-t[n]+2*i)/r[n]+1,a));return s}([t,n,r,1],[o,u,l],0,[i,a,s],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/i),p=Math.ceil(n/a),f=Math.ceil(r/s);const e=(h-1)*i+o-t,c=(p-1)*a+u-n,m=(f-1)*s+l-r,g=Math.floor(e/2),x=e-g,b=Math.floor(c/2),y=c-b,w=Math.floor(m/2);d={top:b,bottom:y,left:w,right:m-w,front:g,back:x,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(i,l,c,d,x,b,y,C,I,S,o),E=a?g*h:g;let N;return"channelsFirst"===s?N=[u,E,R,T,A]:"channelsLast"===s&&(N=[u,R,T,A,E]),{batchSize:u,dataFormat:s,inDepth:l,inHeight:c,inWidth:d,inChannels:h,outDepth:R,outHeight:T,outWidth:A,outChannels:E,padInfo:$,strideDepth:x,strideHeight:b,strideWidth:y,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:N,filterShape:t}}function nu(e,t,n,r=1){const i=au(t,r);return Math.floor((e[0]*(n-1)-n+i)/2)}function ru(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function iu(e){return"number"==typeof e?[e,e,e]:e}function au(e,t){return t<=1?e:e+(e-1)*(t-1)}function su(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ou(e){const[t,n,r]=ru(e);return 1===t&&1===n&&1===r}function uu(e,t){return ou(e)||ou(t)}function lu(e){return ru(e).every((e=>e>0))}function cu(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function du(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)k(A(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{k(A(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const hu=Ta({elu_:function(e){const t={x:Ra(e,"x","elu","float32")};return zi.runKernel(ft,t)}}),pu=Ta({leakyRelu_:function(e,t=.2){const n={x:Ra(e,"x","leakyRelu")},r={alpha:t};return zi.runKernel(Ut,n,r)}}),fu=Ta({prelu_:function(e,t){const n={x:Ra(e,"x","prelu"),alpha:Ra(t,"alpha","prelu")};return zi.runKernel(yn,n)}}),mu=Ta({relu6_:function(e){const t={x:Ra(e,"x","relu6")};return zi.runKernel(_n,t)}}),gu=Ta({step_:function(e,t=0){const n={x:Ra(e,"x","step")},r={alpha:t};return zi.runKernel(kr,n,r)}});function xu(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return za(e,gu(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function bu(e,t){let n=t;const r=rs(e.shape,t.shape);return r.length>0&&(n=Eo(n,r)),Vs(n,e.shape)}function yu(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Ho(e);if("elu"===t)return hu(e);if("relu6"===t)return mu(e);if("prelu"===t)return fu(e,n);if("leakyrelu"===t)return pu(e,r);if("sigmoid"===t)return Zs(e);throw new Error(`Unknown fused activation ${t}.`)}const wu=(e,t)=>!(e>0)||"linear"===t;var vu;function ku(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){const a=n[i],s=r[r.length-n.length+i],o=r[s];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+e}] = ${a} but shape[${i+e}] = ${o}`)}else r[s]=a}return r}function Cu(e){const t={FIRST_DIM_SIZE:vu.FIRST_DIM_SIZE,VALUE_ROWIDS:vu.VALUE_ROWIDS,ROW_LENGTHS:vu.ROW_LENGTHS,ROW_SPLITS:vu.ROW_SPLITS,ROW_LIMITS:vu.ROW_LIMITS,ROW_STARTS:vu.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Iu(e){return 0===e.length?0:e[0]===vu.FIRST_DIM_SIZE?e.length-1:e.length}function Su(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){const n=e[i],r=t[i+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-e.length}] = ${n} but ragged tensor input.flatValues.shape[${i-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(vu||(vu={}));const $u=30;function Ru(e){return e<=$u?e:Y(e,Math.floor(Math.sqrt(e)))}function Tu(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Au(e,t,n,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(e[0]/n),i=i.concat(e.slice(1));else{i=i.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)i=i.concat([e[r+1]/t[r],t[r]]);i=i.concat(e.slice(n+1))}return i}function Eu(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],i=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function Nu(e,t,n,r=!0){const i=[];r?i.push(e[0]/n):i.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?i.push(t[n-1]*e[n]):i.push(e[n]/t[n-1]):i.push(e[n]);return i}function Du(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function _u(e,t,n){const r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}function Fu(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===S(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const i=t.shape,a=i[i.length-1];let s=1;for(let e=0;e<i.length-1;++e)s*=i[e];const o=e.shape,u=i.slice();u.pop();let l=1;for(let e=a;e<n;++e)l*=o[e],u.push(o[e]);const c=[...Q(e.shape).map((e=>e/l)),1].slice(0,a);return[u,s,l,c]}function Pu(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(a+` update.rank < ${i}. `);if(e.length<r+(n.rank-i))throw new Error(a+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+e.length-r)throw new Error(a+" update.rank != "+(i+e.length-r));for(let e=0;e<i;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-i;++t)if(n.shape[t+i]!==e[t+r])throw new Error(a+` updates.shape[${t+i}] (${n.shape[t+i]}) != shape[${t+i}] (${e[t+i]})`)}function Ou(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Pu(n,t,e)}function Uu(e,t,n){const r=t.shape.length,i=r>1?t.shape[r-1]:1,a=n.length;let s=1;for(let e=i;e<a;++e)s*=n[e];const o=i<1?1:i;return{sliceRank:i,numUpdates:S(t.shape)/o,sliceSize:s,strides:[...Q(n.slice(0,i)),1],outputSize:S(n)}}const Bu=1.7580993408473768,Lu=1.0507009873554805,zu=.3275911,Mu=.254829592,Wu=-.284496736,Vu=1.421413741,Gu=-1.453152027,Hu=1.061405429;function ju(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Xu(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Ku(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function qu(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Yu(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Qu(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Zu(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){const a=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(a),r[i]=Math.sin(a)}return{real:n,imag:r}}function Ju(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const el="->",tl=/->/g,nl=",",rl="...";function il(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(tl,"").length)/el.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${el}").`);const[r,i]=e.split(el);k(-1===r.indexOf(rl),(()=>`The ellipsis notation ("${rl}") is not supported yet.`));const a=r.split(nl),s=a.length;if(t!==s)throw new Error(`Expected ${s} input tensors, received ${t}`);if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<i.length;++e){const t=i[e];if(!a.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&t!==nl&&o.push(t)}const u=new Array(a.length);for(let e=0;e<s;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);u[e]=[];for(let t=0;t<a[e].length;++t)u[e].push(o.indexOf(a[e][t]))}const l=o.length,c=[];for(let e=i.length;e<l;++e)c.push(e);return{allDims:o,summedDims:c,idDims:u}}function al(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function sl(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const i=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=i[n]:k(r[t[e][n]]===i[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(i)}, but got dimension ${i[n]}`))}}function ol(e,t){const n=e,r=[];let i=0;0===e.length&&n.push(-1),i=e.length+1;for(let e=0;e<i;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const i=ll(t,n[e]);for(const t of i)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function ul(e){return e.every(((e,t)=>e===t))}function ll(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function cl(e,t,n=0){let r=[];if("number"==typeof t)k(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{k(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const i=t.indexOf(-1);if(-1!==i){const r=t.reduce(((e,t)=>t>0?e+t:e));t[i]=e.shape[n]-r}k(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function dl(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function hl(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function pl(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function fl(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function ml(e,t){return`size ${e} must be non-negative, not ${t}`}function gl(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function xl(e,t){return`Input to reshape is a SparseTensor with ${S(e)}\n  dense values, but the requested shape requires a multiple of ${S(t)}. inputShape=${e} outputShape= ${t}`}function bl(e,t){return`Input to reshape is a tensor with ${S(e)} dense values, but the requested shape has ${S(t)}. inputShape=${e} outputShape=${t}`}function yl(){return"segment ids must be >= 0"}function wl(){return"segment ids are not increasing"}function vl(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function kl(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Cl(e,t){let n,r=!1;for(e<=$u?(n=e,r=!0):n=Y(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Y(e,n+1);return n}function Il(e,t,n){const r=[],i=e.length;for(let a=0;a<i;a++)a!==t?r.push(e[a]):r.push(n);return r}function Sl(e,t,n,r){const i=t.shape.length,a=e.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const s=e.shape[n],o=[];let u=1,l=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),u*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<i;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:s,outputShape:o}}function $l(e){try{return e.map((e=>ri(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Rl(e){return e.map((e=>ni(e)))}function Tl(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=Ca(e,"int32"),i=Ca([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),s=t*e.length;i.values.set(a,s)}return i.toTensor()}!function(){for(const e of os)Ya(e)}()},720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},a={};function s(e,t){var n,r,s;return t?(s=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=u(e,(0|e)<0?-1:0,!0),s&&(a[e]=n),n):(s=-128<=(e|=0)&&e<128)&&(r=i[e])?r:(n=u(e,e<0?-1:0,!1),s&&(i[e]=n),n)}function o(e,t){if(isNaN(e))return t?x:g;if(t){if(e<0)return x;if(e>=p)return k}else{if(e<=-f)return C;if(e+1>=f)return v}return e<0?o(-e,t).neg():u(e%h|0,e/h|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=s,n.fromNumber=o,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var i=o(l(n,8)),a=g,s=0;s<e.length;s+=8){var u=Math.min(8,e.length-s),d=parseInt(e.substring(s,s+u),n);if(u<8){var h=o(l(n,u));a=a.mul(h).add(o(d))}else a=(a=a.mul(i)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=s(1<<24),g=s(0);n.ZERO=g;var x=s(0,!0);n.UZERO=x;var b=s(1);n.ONE=b;var y=s(1,!0);n.UONE=y;var w=s(-1);n.NEG_ONE=w;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var k=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var C=u(0,-2147483648,!1);n.MIN_VALUE=C;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(C)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var i=o(l(e,6),this.unsigned),a=this,s="";;){var u=a.div(i),c=(a.sub(u.mul(i)).toInt()>>>0).toString(e);if((a=u).isZero())return c+s;for(;c.length<6;)c="0"+c;s=""+c+s}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(C)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1==(1&this.low)},I.isEven=function(){return 0==(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(C)?C:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,i=this.low>>>16,a=65535&this.low,s=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=i+l)>>>16,c+=(h+=n+o)>>>16,c+=t+s,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(C))return e.isOdd()?C:g;if(e.eq(C))return this.isOdd()?C:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,a=this.low>>>16,s=65535&this.low,l=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,x=0,b=0,y=0;return b+=(y+=s*p)>>>16,x+=(b+=a*p)>>>16,b&=65535,x+=(b+=s*h)>>>16,f+=(x+=i*p)>>>16,x&=65535,f+=(x+=a*h)>>>16,x&=65535,f+=(x+=s*c)>>>16,f+=n*p+i*h+a*c+s*l,u((b&=65535)<<16|(y&=65535),(f&=65535)<<16|(x&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,i,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return x;if(e.gt(this.shru(1)))return y;a=x}else{if(this.eq(C))return e.eq(b)||e.eq(w)?C:e.eq(C)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:w:(i=this.sub(e.mul(n)),a=n.add(i.div(e)));if(e.eq(C))return this.unsigned?x:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(i=this;i.gte(e);){n=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(n)/Math.LN2),c=s<=48?1:l(2,s-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(i);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),a=a.add(h),i=i.sub(p)}return a},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return u(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}}}]);